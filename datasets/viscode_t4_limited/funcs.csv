id,func,code,train
6963063,7,"    public static void main(String args[]) {
        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };
        int sort = 0;
        for (int j = 0; j < (mas.length); j++) {
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    sort = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = sort;
                }
            }
        }
        for (int i = 0; i < mas.length; i++) {
            System.out.print("" "" + mas[i]);
        }
    }
",1
13799349,7,"    void bubbleSort(int ids[]) {
        boolean flag = true;
        int temp;
        while (flag) {
            flag = false;
            for (int i = 0; i < ids.length - 1; i++) if (ids[i] < ids[i + 1]) {
                temp = ids[i];
                ids[i] = ids[i + 1];
                ids[i + 1] = temp;
                flag = true;
            }
        }
    }
",1
9066291,7,"    void sortIds(int a[]) {
        ExecutionTimer t = new ExecutionTimer();
        t.start();
        for (int i = a.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    int T = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = T;
                }
            }
        }
        t.end();
        TimerRecordFile timerFile = new TimerRecordFile(""sort"", ""BufferSorting"", ""sortIds"", t.duration());
    }
",1
10174628,7,"    @Override
    public T[] sort(T[] values) {
        super.compareTimes = 0;
        for (int i = 0; i < values.length; i++) {
            for (int j = 0; j < values.length - i - 1; j++) {
                super.compareTimes++;
                if (values[j].compareTo(values[j + 1]) > 0) {
                    T temp = values[j];
                    values[j] = values[j + 1];
                    values[j + 1] = temp;
                }
            }
        }
        return values;
    }
",1
2086684,7,"    private BoardPattern[] getBoardPatterns() {
        Resource[] resources = boardManager.getResources(""boards"");
        BoardPattern[] boardPatterns = new BoardPattern[resources.length];
        for (int i = 0; i < resources.length; i++) boardPatterns[i] = (BoardPattern) resources[i];
        for (int i = 0; i < resources.length; i++) {
            for (int j = 0; j < resources.length - (i + 1); j++) {
                String name1 = boardPatterns[j].getName();
                String name2 = boardPatterns[j + 1].getName();
                if (name1.compareTo(name2) > 0) {
                    BoardPattern tmp = boardPatterns[j];
                    boardPatterns[j] = boardPatterns[j + 1];
                    boardPatterns[j + 1] = tmp;
                }
            }
        }
        return boardPatterns;
    }
",1
4449697,7,"    private int[] sortNodesToGoal(Graph g, int parent, int goal) {
        float a, b;
        int tempI, tempR;
        float tempF;
        int len = g.nodeList[parent].edges.length;
        int[] nodes = new int[len];
        float[] dists = new float[len];
        int[] ref = new int[len];
        if (len == 0) return null;
        if (len == 1) {
            ref[0] = 0;
            return ref;
        }
        for (int i = 0; i < len; i++) {
            nodes[i] = g.getOtherNode(parent, g.nodeList[parent].edges[i]);
            a = g.nodeList[nodes[i]].x - g.nodeList[goal].x;
            b = g.nodeList[nodes[i]].y - g.nodeList[goal].y;
            dists[i] = (float) Math.sqrt(a * a + b * b);
            ref[i] = i;
        }
        for (int i = len - 1; i >= 0; i--) {
            for (int j = 0; j < i; j++) {
                if (dists[j] > dists[j + 1]) {
                    tempI = nodes[j];
                    nodes[j] = nodes[j + 1];
                    nodes[j + 1] = tempI;
                    tempF = dists[j];
                    dists[j] = dists[j + 1];
                    dists[j + 1] = tempF;
                    tempR = ref[j];
                    ref[j] = ref[j + 1];
                    ref[j + 1] = tempR;
                }
            }
        }
        return ref;
    }
",1
8359775,7,"    public static void shakeSort(int[] a) {
        if (a == null) {
            throw new IllegalArgumentException(""Null-pointed array"");
        }
        int k = 0;
        int left = 0;
        int right = a.length - 1;
        while (right - left > 0) {
            k = 0;
            for (int i = 0; i <= right - 1; i++) {
                if (a[i] > a[i + 1]) {
                    k = i;
                    int temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                }
            }
            right = k;
            k = a.length - 1;
            for (int i = left; i <= right - 1; i++) {
                if (a[i] > a[i + 1]) {
                    k = i;
                    int temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                }
            }
            left = k;
        }
    }
",1
81754,7,"    public void Sort(int a[]) {
        for (int i = a.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    int temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                }
            }
        }
    }
",1
8166293,7,"    public static void main(String[] args) {
        int dizi[] = { 23, 78, 45, 8, 3, 32, 56, 39, 92, 28 };
        boolean test = false;
        int kars = 0;
        int tas = 0;
        while (true) {
            for (int j = 0; j < dizi.length - 1; j++) {
                kars++;
                if (dizi[j] > dizi[j + 1]) {
                    int temp = dizi[j];
                    dizi[j] = dizi[j + 1];
                    dizi[j + 1] = temp;
                    test = true;
                    tas++;
                }
            }
            if (!test) {
                break;
            } else {
                test = false;
            }
        }
        for (int i = 0; i < dizi.length; i++) {
            System.out.print(dizi[i] + "" "");
        }
        for (int i = 0; i < 5; i++) {
            System.out.println(""i"" + i);
        }
    }
",1
3365958,7,"    private void bubbleSort(int[] mas) {
        boolean t = true;
        int temp = 0;
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    temp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = temp;
                    t = true;
                }
            }
        }
    }
",1
13295656,7,"    public static int[] BubbleSortDEC(int[] values) {
        boolean change = true;
        int aux;
        int[] indexes = new int[values.length];
        for (int i = 0; i < values.length; i++) {
            indexes[i] = i;
        }
        while (change) {
            change = false;
            for (int i = 0; i < values.length - 1; i++) {
                if (values[i] < values[i + 1]) {
                    aux = values[i];
                    values[i] = values[i + 1];
                    values[i + 1] = aux;
                    aux = indexes[i];
                    indexes[i] = indexes[i + 1];
                    indexes[i + 1] = aux;
                    change = true;
                }
            }
        }
        return (indexes);
    }
",1
6622146,7,"    public Object[] bubblesort(Object[] tosort) {
        Boolean sorting;
        int upperlimit = tosort.length - 1;
        do {
            sorting = false;
            for (int s0 = 0; s0 < upperlimit; s0++) {
                if (tosort[s0].toString().compareTo(tosort[s0 + 1].toString()) < 0) {
                } else if (tosort[s0].toString().compareTo(tosort[s0 + 1].toString()) == 0) {
                    Object[] tosortnew = new Object[tosort.length - 1];
                    for (int tmp = 0; tmp < s0; tmp++) {
                        tosortnew[tmp] = tosort[tmp];
                    }
                    for (int tmp = s0; tmp < tosortnew.length; tmp++) {
                        tosortnew[tmp] = tosort[tmp + 1];
                    }
                    tosort = tosortnew;
                    upperlimit = upperlimit - 1;
                    s0 = s0 - 1;
                } else if (tosort[s0].toString().compareTo(tosort[s0 + 1].toString()) > 0) {
                    String swap = (String) tosort[s0];
                    tosort[s0] = tosort[s0 + 1];
                    tosort[s0 + 1] = swap;
                    sorting = true;
                }
            }
            upperlimit = upperlimit - 1;
        } while (sorting);
        return tosort;
    }
",0
120983,7,"    void sort(int a[]) throws Exception {
        for (int i = a.length; --i >= 0; ) {
            boolean flipped = false;
            for (int j = 0; j < i; j++) {
                if (stopRequested) {
                    return;
                }
                if (a[j] > a[j + 1]) {
                    int T = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = T;
                    flipped = true;
                }
                pause(i, j);
            }
            if (!flipped) {
                return;
            }
        }
    }
",0
7635628,7,"    private void bubbleSort(int values[]) {
        int len = values.length - 1;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len - i; j++) {
                if (values[j] > values[j + 1]) {
                    int tmp = values[j];
                    values[j] = values[j + 1];
                    values[j + 1] = tmp;
                }
            }
        }
    }
",1
15822137,7,"    public TableDirectory(RandomAccessFile raf) throws IOException {
        version = raf.readInt();
        numTables = raf.readShort();
        searchRange = raf.readShort();
        entrySelector = raf.readShort();
        rangeShift = raf.readShort();
        entries = new DirectoryEntry[numTables];
        for (int i = 0; i < numTables; i++) {
            entries[i] = new DirectoryEntry(raf);
        }
        boolean modified = true;
        while (modified) {
            modified = false;
            for (int i = 0; i < numTables - 1; i++) {
                if (entries[i].getOffset() > entries[i + 1].getOffset()) {
                    DirectoryEntry temp = entries[i];
                    entries[i] = entries[i + 1];
                    entries[i + 1] = temp;
                    modified = true;
                }
            }
        }
    }
",1
1668091,7,"    protected static int[] sort(int[] arr) {
        for (int i = arr.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        return arr;
    }
",0
3198237,7," *
 * @version		1.0
 * @author		Alan Willamson (alan@n-ary.com)
 * @since		JDK1.1.4
 */
public class sort extends java.lang.Object {

    private static String Cal[] = { ""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December"" };

    /**
     * <P>
     * Sorts an array of Strings into asending order
     * <P>
     * @param _data         The array that is to be sorted.
     *
     */
",1
11939522,7,"    public static String[] bubbleSort(String[] unsortedString, boolean ascending) {
        if (unsortedString.length < 2) return unsortedString;
        String[] sortedString = new String[unsortedString.length];
        for (int i = 0; i < unsortedString.length; i++) {
            sortedString[i] = unsortedString[i];
        }
        if (ascending) {
            for (int i = 0; i < sortedString.length - 1; i++) {
                for (int j = 1; j < sortedString.length - 1 - i; j++) if (sortedString[j + 1].compareToIgnoreCase(sortedString[j]) < 0) {
                    String swap = sortedString[j];
                    sortedString[j] = sortedString[j + 1];
                    sortedString[j + 1] = swap;
                }
            }
        } else {
            for (int i = sortedString.length - 2; i >= 0; i--) {
                for (int j = sortedString.length - 2 - i; j >= 0; j--) if (sortedString[j + 1].compareToIgnoreCase(sortedString[j]) > 0) {
                    String swap = sortedString[j];
                    sortedString[j] = sortedString[j + 1];
                    sortedString[j + 1] = swap;
                }
            }
        }
        return sortedString;
    }
",1
477320,7,"    private final void reOrderFriendsListByOnlineStatus() {
        boolean flag = true;
        while (flag) {
            flag = false;
            for (int i = 0; i < friendsCount - 1; i++) if (friendsListOnlineStatus[i] < friendsListOnlineStatus[i + 1]) {
                int j = friendsListOnlineStatus[i];
                friendsListOnlineStatus[i] = friendsListOnlineStatus[i + 1];
                friendsListOnlineStatus[i + 1] = j;
                long l = friendsListLongs[i];
                friendsListLongs[i] = friendsListLongs[i + 1];
                friendsListLongs[i + 1] = l;
                flag = true;
            }
        }
    }
",0
9225969,7,"    public void sort(int[] mas) {
        int temp;
        boolean t = true;
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    temp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = temp;
                    t = true;
                }
            }
        }
    }
",1
7041871,7,"    public static void bubbleSort(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
            System.out.println(""��"" + (i + 1) + ""������"");
            for (int k = 0; k < array.length; k++) {
                System.out.print(array[k] + "" "");
            }
            System.out.println();
        }
    }
",1
6972162,7,"    public void removeDownload() {
        synchronized (mDownloadMgr) {
            int rowCount = mDownloadTable.getSelectedRowCount();
            if (rowCount <= 0) return;
            int[] rows = mDownloadTable.getSelectedRows();
            int[] orderedRows = new int[rows.length];
            Vector downloadFilesToRemove = new Vector();
            for (int i = 0; i < rowCount; i++) {
                int row = rows[i];
                if (row >= mDownloadMgr.getDownloadCount()) return;
                orderedRows[i] = mDownloadSorter.indexes[row];
            }
            mDownloadTable.removeRowSelectionInterval(0, mDownloadTable.getRowCount() - 1);
            for (int i = orderedRows.length - 1; i > 0; i--) {
                for (int j = 0; j < i; j++) {
                    if (orderedRows[j] > orderedRows[j + 1]) {
                        int tmp = orderedRows[j];
                        orderedRows[j] = orderedRows[j + 1];
                        orderedRows[j + 1] = tmp;
                    }
                }
            }
            for (int i = orderedRows.length - 1; i >= 0; i--) {
                mDownloadMgr.removeDownload(orderedRows[i]);
            }
            mainFrame.refreshAllActions();
        }
    }
",1
8359774,7,"    public static void bubbleSort(int[] a) {
        if (a == null) {
            throw new IllegalArgumentException(""Null-pointed array"");
        }
        int right = a.length - 1;
        int k = 0;
        while (right > 0) {
            k = 0;
            for (int i = 0; i <= right - 1; i++) {
                if (a[i] > a[i + 1]) {
                    k = i;
                    int temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                }
            }
            right = k;
        }
    }
",1
5405559,7,"    public void sort(int[] order, double[] values) {
        int temp = 0;
        boolean done = false;
        for (int i = 0; i < values.length; i++) {
            order[i] = i;
        }
        if (desendingValues) {
            while (!done) {
                done = true;
                for (int i = values.length - 2; i >= 0; i--) {
                    if (values[order[i]] < values[order[i + 1]]) {
                        done = false;
                        temp = order[i];
                        order[i] = order[i + 1];
                        order[i + 1] = temp;
                    }
                }
            }
        } else {
            while (!done) {
                done = true;
                for (int i = values.length - 2; i >= 0; i--) {
                    if (values[order[i]] > values[order[i + 1]]) {
                        done = false;
                        temp = order[i];
                        order[i] = order[i + 1];
                        order[i + 1] = temp;
                    }
                }
            }
        }
    }
",1
11374801,7,"    public void init(VerwaltungClient verClient) {
        this.setLayout(new BorderLayout());
        pnl1 = new JPanel();
        pnl1.setLayout(new FlowLayout());
        pnl1.add(new JLabel(Localization.getInstance().getString(""GameOver"")));
        pnl1.setBounds(10, 10, 200, 10);
        pnl2 = new JPanel();
        int a_punkte[];
        int punkte = 0;
        String name;
        String[] a_namen;
        a_punkte = verClient.getA_spielEndpunkte();
        a_namen = verClient.getA_Spielernamen();
        zeilen = new Object[a_punkte.length][2];
        for (int i = 0; i < a_punkte.length; i++) {
            for (int j = 0; j < a_punkte.length - 1 - i; j++) {
                if (a_punkte[j] < a_punkte[j + 1]) {
                    punkte = a_punkte[j];
                    a_punkte[j] = a_punkte[j + 1];
                    a_punkte[j + 1] = punkte;
                    name = a_namen[j];
                    a_namen[j] = a_namen[j + 1];
                    a_namen[j + 1] = name;
                }
            }
        }
        for (int i = 0; i < a_punkte.length; i++) {
            zeilen[i][0] = a_namen[i];
            zeilen[i][1] = new String("""" + a_punkte[i]);
        }
        tabelle = new JTable(zeilen, spalten);
        tabelle.setEnabled(false);
        pane = new JScrollPane(tabelle);
        pnl2.add(pane);
        pnl3 = new JPanel();
        JButton btn = new JButton(Localization.getInstance().getString(""OK""));
        btn.addActionListener(this);
        pnl3.add(btn);
        this.add(BorderLayout.CENTER, pnl2);
        this.add(BorderLayout.NORTH, pnl1);
        this.add(BorderLayout.SOUTH, pnl3);
        this.pack();
        this.setResizable(false);
        this.setVisible(true);
    }
",0
12122419,7,"    private Vector _sort(Pair[] ps, String id, int num) {
        Vector ret = new Vector();
        boolean swapped = true;
        int j = 0;
        Pair tmp;
        while (swapped) {
            swapped = false;
            j++;
            for (int i = 0; i < ps.length - j; i++) {
                if (ps[i].c > ps[i + 1].c) {
                    tmp = ps[i];
                    ps[i] = ps[i + 1];
                    ps[i + 1] = tmp;
                    swapped = true;
                }
            }
        }
        int m = Math.min(num, ps.length);
        for (int i = m - 1; i >= 0; i--) {
            if (id == null) ret.addElement(ps[i].n); else if (ps[i].n.startsWith(id) && !ps[i].n.equals(id)) ret.addElement(ps[i].n);
        }
        return ret;
    }
",1
9075137,7,"    public boolean implies(Permission permission) {
        if (!permissionClass.isInstance(permission)) {
            return false;
        }
        GCFPermission perm = (GCFPermission) permission;
        int perm_low = perm.getMinPort();
        int perm_high = perm.getMaxPort();
        Enumeration search = permissions.elements();
        int count = permissions.size();
        int port_low[] = new int[count];
        int port_high[] = new int[count];
        int port_range_count = 0;
        while (search.hasMoreElements()) {
            GCFPermission cur_perm = (GCFPermission) search.nextElement();
            if (cur_perm.impliesByHost(perm)) {
                if (cur_perm.impliesByPorts(perm)) {
                    return true;
                }
                port_low[port_range_count] = cur_perm.getMinPort();
                port_high[port_range_count] = cur_perm.getMaxPort();
                port_range_count++;
            }
        }
        for (int i = 0; i < port_range_count; i++) {
            for (int j = 0; j < port_range_count - 1; j++) {
                if (port_low[j] > port_low[j + 1]) {
                    int tmp = port_low[j];
                    port_low[j] = port_low[j + 1];
                    port_low[j + 1] = tmp;
                    tmp = port_high[j];
                    port_high[j] = port_high[j + 1];
                    port_high[j + 1] = tmp;
                }
            }
        }
        int current_low = port_low[0];
        int current_high = port_high[0];
        for (int i = 1; i < port_range_count; i++) {
            if (port_low[i] > current_high + 1) {
                if (current_low <= perm_low && current_high >= perm_high) {
                    return true;
                }
                if (perm_low <= current_high) {
                    return false;
                }
                current_low = port_low[i];
                current_high = port_high[i];
            } else {
                if (current_high < port_high[i]) {
                    current_high = port_high[i];
                }
            }
        }
        return (current_low <= perm_low && current_high >= perm_high);
    }
",1
529986,7,"    void bsort(int a[], int lo, int hi) throws Exception {
        for (int j = hi; j > lo; j--) {
            for (int i = lo; i < j; i++) {
                if (a[i] > a[i + 1]) {
                    int T = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = T;
                    pause();
                }
            }
        }
    }
",1
17630906,7,"    public static int[] sortAscending(float input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] > input[j + 1]) {
                    float mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
",1
878123,7,"    void sort(int a[]) throws Exception {
        int j;
        int limit = a.length;
        int st = -1;
        while (st < limit) {
            boolean flipped = false;
            st++;
            limit--;
            for (j = st; j < limit; j++) {
                if (stopRequested) {
                    return;
                }
                if (a[j] > a[j + 1]) {
                    int T = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = T;
                    flipped = true;
                    pause(st, limit);
                }
            }
            if (!flipped) {
                return;
            }
            for (j = limit; --j >= st; ) {
                if (stopRequested) {
                    return;
                }
                if (a[j] > a[j + 1]) {
                    int T = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = T;
                    flipped = true;
                    pause(st, limit);
                }
            }
            if (!flipped) {
                return;
            }
        }
        pause(st, limit);
    }
",1
6302678,7,"    public ISpieler[] sortiereSpielerRamsch(ISpieler[] spieler) {
        for (int i = 0; i < spieler.length; i++) {
            for (int j = 0; j < spieler.length - 1; j++) {
                if (werteAugen(spieler[j].getStiche()) > werteAugen(spieler[j + 1].getStiche())) {
                    ISpieler a = spieler[j];
                    spieler[j] = spieler[j + 1];
                    spieler[j + 1] = a;
                }
            }
        }
        return spieler;
    }
",1
1920567,7,"    public static void sortSeries(double[] series) {
        if (series == null) {
            throw new IllegalArgumentException(""Incorrect series. It's null-pointed"");
        }
        int k = 0;
        int right = series.length - 1;
        while (right > 0) {
            k = 0;
            for (int i = 0; i <= right - 1; i++) {
                if (series[i] > series[i + 1]) {
                    k = i;
                    double tmp = series[i];
                    series[i] = series[i + 1];
                    series[i + 1] = tmp;
                }
            }
            right = k;
        }
    }
",1
17630907,7,"    public static int[] sortDescending(int input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] < input[j + 1]) {
                    int mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
",1
12483251,7,"    private void weightAndPlaceClasses() {
        int rows = getRows();
        for (int curRow = _maxPackageRank; curRow < rows; curRow++) {
            xPos = getHGap() / 2;
            BOTLObjectSourceDiagramNode[] rowObject = getObjectsInRow(curRow);
            for (int i = 0; i < rowObject.length; i++) {
                if (curRow == _maxPackageRank) {
                    int nDownlinks = rowObject[i].getDownlinks().size();
                    rowObject[i].setWeight((nDownlinks > 0) ? (1 / nDownlinks) : 2);
                } else {
                    Vector uplinks = rowObject[i].getUplinks();
                    int nUplinks = uplinks.size();
                    if (nUplinks > 0) {
                        float average_col = 0;
                        for (int j = 0; j < uplinks.size(); j++) {
                            average_col += ((BOTLObjectSourceDiagramNode) (uplinks.elementAt(j))).getColumn();
                        }
                        average_col /= nUplinks;
                        rowObject[i].setWeight(average_col);
                    } else {
                        rowObject[i].setWeight(1000);
                    }
                }
            }
            int[] pos = new int[rowObject.length];
            for (int i = 0; i < pos.length; i++) {
                pos[i] = i;
            }
            boolean swapped = true;
            while (swapped) {
                swapped = false;
                for (int i = 0; i < pos.length - 1; i++) {
                    if (rowObject[pos[i]].getWeight() > rowObject[pos[i + 1]].getWeight()) {
                        int temp = pos[i];
                        pos[i] = pos[i + 1];
                        pos[i + 1] = temp;
                        swapped = true;
                    }
                }
            }
            for (int i = 0; i < pos.length; i++) {
                rowObject[pos[i]].setColumn(i);
                if ((i > _vMax) && (rowObject[pos[i]].getUplinks().size() == 0) && (rowObject[pos[i]].getDownlinks().size() == 0)) {
                    if (getColumns(rows - 1) > _vMax) {
                        rows++;
                    }
                    rowObject[pos[i]].setRank(rows - 1);
                } else {
                    rowObject[pos[i]].setLocation(new Point(xPos, yPos));
                    xPos += rowObject[pos[i]].getSize().getWidth() + getHGap();
                }
            }
            yPos += getRowHeight(curRow) + getVGap();
        }
    }
",1
17583188,7,"    byte[] toByteArray() throws IOException {
        DataElement element = new DataElement(DataElement.DATSEQ);
        final boolean sort = true;
        if (sort) {
            int[] sortIDs = new int[attributes.size()];
            int k = 0;
            for (Enumeration e = attributes.keys(); e.hasMoreElements(); ) {
                Integer key = (Integer) e.nextElement();
                sortIDs[k] = key.intValue();
                k++;
            }
            for (int i = 0; i < sortIDs.length; i++) {
                for (int j = 0; j < sortIDs.length - i - 1; j++) {
                    if (sortIDs[j] > sortIDs[j + 1]) {
                        int temp = sortIDs[j];
                        sortIDs[j] = sortIDs[j + 1];
                        sortIDs[j + 1] = temp;
                    }
                }
            }
            for (int i = 0; i < sortIDs.length; i++) {
                element.addElement(new DataElement(DataElement.U_INT_2, sortIDs[i]));
                element.addElement(getAttributeValue(sortIDs[i]));
            }
        } else {
            for (Enumeration e = attributes.keys(); e.hasMoreElements(); ) {
                Integer key = (Integer) e.nextElement();
                element.addElement(new DataElement(DataElement.U_INT_2, key.intValue()));
                element.addElement((DataElement) attributes.get(key));
            }
        }
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        (new SDPOutputStream(out)).writeElement(element);
        return out.toByteArray();
    }
",0
15287811,7,"    public static int[] sort(int[] v) {
        int i;
        int l = v.length;
        int[] index = new int[l];
        for (i = 0; i < l; i++) index[i] = i;
        int tmp;
        boolean change = true;
        while (change) {
            change = false;
            for (i = 0; i < l - 1; i++) {
                if (v[index[i]] > v[index[i + 1]]) {
                    tmp = index[i];
                    index[i] = index[i + 1];
                    index[i + 1] = tmp;
                    change = true;
                }
            }
        }
        return index;
    }
",0
11261440,7,"    private static String func(String sf) {
        int total = 0, temp;
        String fnctn[] = { ""sin"", ""cos"", ""tan"", ""log"", ""ln"", ""sqrt"", ""!"" }, temp2 = """";
        int pos[] = new int[7];
        for (int n = 0; n < fnctn.length; n++) {
            pos[n] = sf.lastIndexOf(fnctn[n]);
        }
        for (int m = 0; m < fnctn.length; m++) {
            total += pos[m];
        }
        if (total == -7) {
            return sf;
        }
        for (int i = pos.length; i > 1; i--) {
            for (int j = 0; j < i - 1; j++) {
                if (pos[j] < pos[j + 1]) {
                    temp = pos[j];
                    pos[j] = pos[j + 1];
                    pos[j + 1] = temp;
                    temp2 = fnctn[j];
                    fnctn[j] = fnctn[j + 1];
                    fnctn[j + 1] = temp2;
                }
            }
        }
        if (fnctn[0].equals(""sin"")) {
            if ((pos[0] == 0 || sf.charAt(pos[0] - 1) != 'a')) {
                return func(Functions.sine(sf, pos[0], false));
            } else {
                return func(Functions.asin(sf, pos[0], false));
            }
        } else if (fnctn[0].equals(""cos"")) {
            if ((pos[0] == 0 || sf.charAt(pos[0] - 1) != 'a')) {
                return func(Functions.cosine(sf, pos[0], false));
            } else {
                return func(Functions.acos(sf, pos[0], false));
            }
        } else if (fnctn[0].equals(""tan"")) {
            if ((pos[0] == 0 || sf.charAt(pos[0] - 1) != 'a')) {
                return func(Functions.tangent(sf, pos[0], false));
            } else {
                return func(Functions.atan(sf, pos[0], false));
            }
        } else if (fnctn[0].equals(""log"")) {
            return func(Functions.logarithm(sf, pos[0]));
        } else if (fnctn[0].equals(""ln"")) {
            return func(Functions.lnat(sf, pos[0]));
        } else if (fnctn[0].equals(""sqrt"")) {
            return func(Functions.sqroot(sf, pos[0]));
        } else {
            return func(Functions.factorial(sf, pos[0]));
        }
    }
",0
15609433,7,"    public static int[] bubbleSort2(int[] source) {
        if (null != source && source.length > 0) {
            boolean flag = false;
            while (!flag) {
                for (int i = 0; i < source.length - 1; i++) {
                    if (source[i] > source[i + 1]) {
                        int temp = source[i];
                        source[i] = source[i + 1];
                        source[i + 1] = temp;
                        break;
                    } else if (i == source.length - 2) {
                        flag = true;
                    }
                }
            }
        }
        return source;
    }
",1
7227330,7,"    private void sort() {
        boolean unsortiert = true;
        Datei tmp = null;
        while (unsortiert) {
            unsortiert = false;
            for (int i = 0; i < this.size - 1; i++) {
                if (dateien[i] != null && dateien[i + 1] != null) {
                    if (dateien[i].compareTo(dateien[i + 1]) < 0) {
                        tmp = dateien[i];
                        dateien[i] = dateien[i + 1];
                        dateien[i + 1] = tmp;
                        unsortiert = true;
                    }
                }
            }
        }
    }
",0
6016307,7,"    public static int[] rank(double[] data) {
        int[] rank = new int[data.length];
        for (int i = 0; i < data.length; i++) rank[i] = i;
        boolean swapped;
        double dtmp;
        int i, j, itmp;
        for (i = 0; i < data.length - 1; i++) {
            swapped = false;
            for (j = 0; j < data.length - 1 - i; j++) {
                if (data[j] < data[j + 1]) {
                    dtmp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = dtmp;
                    itmp = rank[j];
                    rank[j] = rank[j + 1];
                    rank[j + 1] = itmp;
                    swapped = true;
                }
            }
        }
        return rank;
    }
",1
3338750,7,"    public void sortPlayersTurn() {
        Token tempT = new Token();
        Player tempP = new Player(""test name"", tempT);
        int tempN = 0;
        boolean exchangeMade = true;
        for (int i = 0; i < playerNum - 1 && exchangeMade; i++) {
            exchangeMade = false;
            for (int j = 0; j < playerNum - 1 - i; j++) {
                if (diceSum[j] < diceSum[j + 1]) {
                    tempP = players[j];
                    tempN = diceSum[j];
                    players[j] = players[j + 1];
                    diceSum[j] = diceSum[j + 1];
                    players[j + 1] = tempP;
                    diceSum[j + 1] = tempN;
                    exchangeMade = true;
                }
            }
        }
    }
",1
5682569,7,"    public void metodo1() {
        int temp;
        boolean flagDesordenado = true;
        while (flagDesordenado) {
            flagDesordenado = false;
            for (int i = 0; i < this.tamanoTabla - 1; i++) {
                if (tabla[i] > tabla[i + 1]) {
                    flagDesordenado = true;
                    temp = tabla[i];
                    tabla[i] = tabla[i + 1];
                    tabla[i + 1] = temp;
                }
            }
        }
    }
",0
15069644,7,"    public String elementsSearch() {
        int index = 0;
        for (int i1 = 0; i1 < 6; i1++) {
            for (int i2 = 0; i2 < 5; i2++) {
                if (index < 5) {
                    if (initialMatrix[i1][i2] > 0) {
                        finalMatrix[index] = initialMatrix[i1][i2];
                        index++;
                    }
                } else break;
            }
        }
        int temp;
        for (int i = 0; i < finalMatrix.length; i++) {
            for (int j = 0; j < finalMatrix.length - 1; j++) {
                if (finalMatrix[j] < finalMatrix[j + 1]) {
                    temp = finalMatrix[j];
                    finalMatrix[j] = finalMatrix[j + 1];
                    finalMatrix[j + 1] = temp;
                }
            }
        }
        String result = """";
        for (int k : finalMatrix) result += k + "" "";
        return result;
    }
",0
21273056,7,"    public RobotList<Resource> sort_decr_Resource(RobotList<Resource> list, String field) {
        int length = list.size();
        Index_value[] resource_dist = new Index_value[length];
        if (field.equals("""") || field.equals(""location"")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals(""energy"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).energy);
            }
        } else if (field.equals(""ammostash"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).ammostash);
            }
        } else if (field.equals(""speed"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).speed);
            }
        } else if (field.equals(""health"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say(""impossible to sort list - nothing modified"");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (resource_dist[i].value < resource_dist[i + 1].value) {
                    Index_value a = resource_dist[i];
                    resource_dist[i] = resource_dist[i + 1];
                    resource_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Resource> new_resource_list = new RobotList<Resource>(Resource.class);
        for (int i = 0; i < length; i++) {
            new_resource_list.addLast(list.get(resource_dist[i].index));
        }
        return new_resource_list;
    }
",1
8054454,7,"    public void sortIndexes() {
        int i, j, count;
        int t;
        count = m_ItemIndexes.length;
        for (i = 1; i < count; i++) {
            for (j = 0; j < count - i; j++) {
                if (m_ItemIndexes[j] > m_ItemIndexes[j + 1]) {
                    t = m_ItemIndexes[j];
                    m_ItemIndexes[j] = m_ItemIndexes[j + 1];
                    m_ItemIndexes[j + 1] = t;
                }
            }
        }
    }
",1
7327761,7,"    private void fillProductResult() {
        this.ProductResult = new int[this.linearDim + 1][this.linearDim + 1];
        for (int j = 1; j < this.linearDim + 1; j++) {
            this.ProductResult[1][j] = j;
            this.ProductResult[j][1] = j;
        }
        int[] doubleSort = new int[2 * this.GradeCount - 1];
        int permuteCounter = 0;
        int doubleKey = 0;
        int j = 2;
        int k = 2;
        int m = 1;
        int n = 1;
        int tempSort = 0;
        for (j = 2; j < this.linearDim + 1; j++) {
            for (k = 2; k < this.linearDim + 1; k++) {
                permuteCounter = 0;
                doubleKey = 0;
                for (m = 1; m < this.GradeCount; m++) {
                    doubleSort[m] = this.ABasis.getBasis(j, m);
                    doubleSort[m + this.GradeCount - 1] = this.ABasis.getBasis(k, m);
                }
                m = 1;
                for (m = 1; m < 2 * this.GradeCount - 1; m++) {
                    for (n = 1; n < 2 * this.GradeCount - 2; n++) {
                        if (doubleSort[n] > doubleSort[n + 1]) {
                            tempSort = doubleSort[n];
                            doubleSort[n] = doubleSort[n + 1];
                            doubleSort[n + 1] = tempSort;
                            if (!(doubleSort[n] == 0 || doubleSort[n + 1] == 0)) {
                                permuteCounter += 1;
                            }
                        }
                    }
                    n = 1;
                }
                m = 1;
                permuteCounter = permuteCounter % 2;
                for (m = 1; m < 2 * this.GradeCount - 2; m++) {
                    if (doubleSort[m] == 0) continue;
                    if (doubleSort[m] == doubleSort[m + 1]) {
                        tempSort = doubleSort[m];
                        doubleSort[m] = 0;
                        doubleSort[m + 1] = 0;
                        m += 1;
                        permuteCounter += intSignature[tempSort - 1];
                    }
                }
                m = 1;
                permuteCounter = permuteCounter % 2;
                for (m = 1; m < 2 * this.GradeCount - 1; m++) {
                    for (n = 1; n < 2 * this.GradeCount - 2; n++) {
                        if (doubleSort[n] > doubleSort[n + 1]) {
                            tempSort = doubleSort[n];
                            doubleSort[n] = doubleSort[n + 1];
                            doubleSort[n + 1] = tempSort;
                            if (!(doubleSort[n] == 0 || doubleSort[n + 1] == 0)) {
                                permuteCounter += 1;
                            }
                        }
                    }
                    n = 1;
                }
                m = 1;
                permuteCounter = permuteCounter % 2;
                for (m = 1; m < 2 * this.GradeCount - 1; m++) {
                    doubleKey += (int) doubleSort[m] * Math.pow(this.GradeCount, 2 * this.GradeCount - 2 - m);
                }
                m = 1;
                this.ProductResult[j][k] = 0;
                for (m = 1; m < this.linearDim + 1; m++) {
                    if (doubleKey == this.ABasis.getBasisKey(m)) {
                        this.ProductResult[j][k] = m * (int) Math.pow(-1.0, permuteCounter);
                        break;
                    }
                }
                m = 1;
            }
            k = 2;
        }
    }
",1
17630910,7,"    public static int[] sortDescending(double input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] < input[j + 1]) {
                    double mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
",1
521113,7,"    int[] slowSort() {
        int[] values = getValues();
        int n = values.length;
        for (int pass = 1; pass < n; pass++) {
            for (int i = 0; i < n - pass; i++) {
                if (values[i] > values[i + 1]) {
                    int temp = values[i];
                    values[i] = values[i + 1];
                    values[i + 1] = temp;
                }
            }
        }
        return values;
    }
",1
13243880,7,"    public int[] bubbleSort(int[] data) {
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data.length - i - 1; j++) {
                if (data[j] > data[j + 1]) {
                    int temp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = temp;
                }
            }
        }
        return data;
    }
",1
17630908,7,"    public static int[] sortDescending(float input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] < input[j + 1]) {
                    float mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
",1
6920765,7,"    public static final void sequence(int[] list, int above) {
        int temp, max, min;
        boolean tag = true;
        for (int i = list.length - 1; i >= 0; i--) {
            for (int j = 0; j < i; j++) {
                if (above < 0) {
                    if (list[j] < list[j + 1]) {
                        temp = list[j];
                        list[j] = list[j + 1];
                        list[j + 1] = temp;
                        tag = true;
                    }
                } else {
                    if (list[j] > list[j + 1]) {
                        temp = list[j];
                        list[j] = list[j + 1];
                        list[j + 1] = temp;
                        tag = true;
                    }
                }
            }
            if (tag == false) break;
        }
    }
",1
13696846,7,"    protected void sort(int a) {
        int[] masiv = new int[a];
        Random rand = new Random();
        for (int i = 0; i <= a; i++) {
            masiv[i] = rand.nextInt(200);
        }
        int d;
        for (int j = 0; j < a; j++) {
            for (int i = 0; i < a; i++) {
                if (masiv[i] < masiv[i + 1]) {
                } else {
                    d = masiv[i];
                    masiv[i] = masiv[i + 1];
                    masiv[i + 1] = d;
                }
            }
        }
        while (a != 0) {
            System.out.println(""sort: "" + masiv[a]);
            a--;
        }
    }
",0
6925921,7,"    public static void bubbleSort(int[] polje) {
        boolean swapped;
        int temp;
        int n = polje.length;
        do {
            swapped = false;
            n--;
            for (int i = 0; i < n - 1; i++) {
                if (polje[i] > polje[i + 1]) {
                    temp = polje[i];
                    polje[i] = polje[i + 1];
                    polje[i + 1] = temp;
                    swapped = true;
                }
            }
        } while (swapped);
    }
",0
11371499,7,"    public void sortArray() {
        int a;
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - 1; j++) {
                if (array[j] < array[j + 1]) {
                    a = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = a;
                }
            }
        }
    }
",1
1363,7,"    public static int[] bubbleSortOtimizado(int... a) {
        boolean swapped;
        int n = a.length - 2;
        do {
            swapped = false;
            for (int i = 0; i <= n; i++) {
                if (a[i] > a[i + 1]) {
                    int tmp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = tmp;
                    swapped = true;
                }
            }
            n = n - 1;
        } while (swapped);
        return a;
    }
",1
22088424,7,"    public static void main(String[] args) {
        int[] mas = { 5, 10, 20, -30, 55, -60, 9, -40, -20 };
        int next;
        for (int a = 0; a < mas.length; a++) {
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    next = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = next;
                }
            }
        }
        for (int i = 0; i < mas.length; i++) System.out.print("" "" + mas[i]);
    }
",1
17985016,7,"    public void setRandom(boolean random) {
        this.random = random;
        if (random) {
            possibleScores = new int[NUM_SCORES];
            for (int i = 0; i < NUM_SCORES - 1; i++) {
                getRandomScore: while (true) {
                    int score = (int) (Math.random() * 20) + 1;
                    for (int j = 0; j < i; j++) {
                        if (score == possibleScores[j]) {
                            continue getRandomScore;
                        }
                    }
                    possibleScores[i] = score;
                    break;
                }
            }
            possibleScores[NUM_SCORES - 1] = 25;
            boolean sorted = false;
            while (!sorted) {
                sorted = true;
                for (int i = 0; i < NUM_SCORES - 1; i++) {
                    if (possibleScores[i] > possibleScores[i + 1]) {
                        int t = possibleScores[i];
                        possibleScores[i] = possibleScores[i + 1];
                        possibleScores[i + 1] = t;
                        sorted = false;
                    }
                }
            }
            setPossibleScores(possibleScores);
        }
    }
",0
14132423,7,"    public static void bubble_sort(int[] objects, int len) {
        for (int i = len; --i >= 0; ) {
            boolean flipped = false;
            for (int j = 0; j < i; j++) {
                if (objects[j + 1] < objects[j]) {
                    int tmp = objects[j];
                    objects[j] = objects[j + 1];
                    objects[j + 1] = tmp;
                    flipped = true;
                }
            }
            if (!flipped) return;
        }
    }
",1
16375558,7,"    private void sort() {
        for (int i = 0; i < density.length; i++) {
            for (int j = density.length - 2; j >= i; j--) {
                if (density[j] > density[j + 1]) {
                    KDNode n = nonEmptyNodesArray[j];
                    nonEmptyNodesArray[j] = nonEmptyNodesArray[j + 1];
                    nonEmptyNodesArray[j + 1] = n;
                    double d = density[j];
                    density[j] = density[j + 1];
                    density[j + 1] = d;
                }
            }
        }
    }
",1
14132422,7,"    public static void bubble_sort(Sortable[] objects) {
        for (int i = objects.length; --i >= 0; ) {
            boolean flipped = false;
            for (int j = 0; j < i; j++) {
                if (objects[j].greater_than(objects[j + 1])) {
                    Sortable tmp = objects[j];
                    objects[j] = objects[j + 1];
                    objects[j + 1] = tmp;
                    flipped = true;
                }
            }
            if (!flipped) return;
        }
    }
",1
3673682,7,"    private void DrawModel(Graphics offg, int obj_num, boolean object, float h, float s, int vt_num, int fc_num) {
        int px[] = new int[3];
        int py[] = new int[3];
        int count = 0;
        int tmp[] = new int[fc_num];
        double tmp_depth[] = new double[fc_num];
        rotate(vt_num);
        offg.setColor(Color.black);
        for (int i = 0; i < fc_num; i++) {
            double a1 = fc[i].vt1.x - fc[i].vt0.x;
            double a2 = fc[i].vt1.y - fc[i].vt0.y;
            double a3 = fc[i].vt1.z - fc[i].vt0.z;
            double b1 = fc[i].vt2.x - fc[i].vt1.x;
            double b2 = fc[i].vt2.y - fc[i].vt1.y;
            double b3 = fc[i].vt2.z - fc[i].vt1.z;
            fc[i].nx = a2 * b3 - a3 * b2;
            fc[i].ny = a3 * b1 - a1 * b3;
            fc[i].nz = a1 * b2 - a2 * b1;
            if (fc[i].nz < 0) {
                fc[i].nx = a2 * b3 - a3 * b2;
                fc[i].ny = a3 * b1 - a1 * b3;
                tmp[count] = i;
                tmp_depth[count] = fc[i].getDepth();
                count++;
            }
        }
        int lim = count - 1;
        do {
            int m = 0;
            for (int n = 0; n <= lim - 1; n++) {
                if (tmp_depth[n] < tmp_depth[n + 1]) {
                    double t = tmp_depth[n];
                    tmp_depth[n] = tmp_depth[n + 1];
                    tmp_depth[n + 1] = t;
                    int ti = tmp[n];
                    tmp[n] = tmp[n + 1];
                    tmp[n + 1] = ti;
                    m = n;
                }
            }
            lim = m;
        } while (lim != 0);
        for (int m = 0; m < count; m++) {
            int i = tmp[m];
            double l = Math.sqrt(fc[i].nx * fc[i].nx + fc[i].ny * fc[i].ny + fc[i].nz * fc[i].nz);
            test(offg, i, l, h, s);
            px[0] = (int) (fc[i].vt0.x * m_Scale + centerp.x);
            py[0] = (int) (-fc[i].vt0.y * m_Scale + centerp.y);
            px[1] = (int) (fc[i].vt1.x * m_Scale + centerp.x);
            py[1] = (int) (-fc[i].vt1.y * m_Scale + centerp.y);
            px[2] = (int) (fc[i].vt2.x * m_Scale + centerp.x);
            py[2] = (int) (-fc[i].vt2.y * m_Scale + centerp.y);
            offg.fillPolygon(px, py, 3);
        }
        if (labelFlag && object) {
            offg.setFont(Fonts.FONT_REAL);
            offg.drawString(d_con.getPointerData().getRealObjName(obj_num), (int) ((fc[0].vt0.x + 10) * m_Scale + centerp.x), (int) (-(fc[0].vt0.y + 10) * m_Scale + centerp.y));
        }
    }
",1
8786313,7,"    @DeclarePerfMonTimer(""SortingTest.bubbleSort"")
    private void bubbleSort(int values[]) {
        int len = values.length - 1;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len - i; j++) {
                if (values[j] > values[j + 1]) {
                    int tmp = values[j];
                    values[j] = values[j + 1];
                    values[j + 1] = tmp;
                }
            }
        }
    }
",0
2086683,7,"    private PieceSet[] getPieceSets() {
        Resource[] resources = boardManager.getResources(""pieces"");
        PieceSet[] pieceSets = new PieceSet[resources.length];
        for (int i = 0; i < resources.length; i++) pieceSets[i] = (PieceSet) resources[i];
        for (int i = 0; i < resources.length; i++) {
            for (int j = 0; j < resources.length - (i + 1); j++) {
                String name1 = pieceSets[j].getName();
                String name2 = pieceSets[j + 1].getName();
                if (name1.compareTo(name2) > 0) {
                    PieceSet tmp = pieceSets[j];
                    pieceSets[j] = pieceSets[j + 1];
                    pieceSets[j + 1] = tmp;
                }
            }
        }
        return pieceSets;
    }
",1
2067794,7,"    public SingularValueDecomposition(Matrix Arg) {
        double[][] A = Arg.getArrayCopy();
        m = Arg.getRowDimension();
        n = Arg.getColumnDimension();
        int nu = Math.min(m, n);
        s = new double[Math.min(m + 1, n)];
        U = new double[m][nu];
        V = new double[n][n];
        double[] e = new double[n];
        double[] work = new double[m];
        boolean wantu = true;
        boolean wantv = true;
        int nct = Math.min(m - 1, n);
        int nrt = Math.max(0, Math.min(n - 2, m));
        for (int k = 0; k < Math.max(nct, nrt); k++) {
            if (k < nct) {
                s[k] = 0;
                for (int i = k; i < m; i++) {
                    s[k] = Maths.hypot(s[k], A[i][k]);
                }
                if (s[k] != 0.0) {
                    if (A[k][k] < 0.0) {
                        s[k] = -s[k];
                    }
                    for (int i = k; i < m; i++) {
                        A[i][k] /= s[k];
                    }
                    A[k][k] += 1.0;
                }
                s[k] = -s[k];
            }
            for (int j = k + 1; j < n; j++) {
                if ((k < nct) & (s[k] != 0.0)) {
                    double t = 0;
                    for (int i = k; i < m; i++) {
                        t += A[i][k] * A[i][j];
                    }
                    t = -t / A[k][k];
                    for (int i = k; i < m; i++) {
                        A[i][j] += t * A[i][k];
                    }
                }
                e[j] = A[k][j];
            }
            if (wantu & (k < nct)) {
                for (int i = k; i < m; i++) {
                    U[i][k] = A[i][k];
                }
            }
            if (k < nrt) {
                e[k] = 0;
                for (int i = k + 1; i < n; i++) {
                    e[k] = Maths.hypot(e[k], e[i]);
                }
                if (e[k] != 0.0) {
                    if (e[k + 1] < 0.0) {
                        e[k] = -e[k];
                    }
                    for (int i = k + 1; i < n; i++) {
                        e[i] /= e[k];
                    }
                    e[k + 1] += 1.0;
                }
                e[k] = -e[k];
                if ((k + 1 < m) & (e[k] != 0.0)) {
                    for (int i = k + 1; i < m; i++) {
                        work[i] = 0.0;
                    }
                    for (int j = k + 1; j < n; j++) {
                        for (int i = k + 1; i < m; i++) {
                            work[i] += e[j] * A[i][j];
                        }
                    }
                    for (int j = k + 1; j < n; j++) {
                        double t = -e[j] / e[k + 1];
                        for (int i = k + 1; i < m; i++) {
                            A[i][j] += t * work[i];
                        }
                    }
                }
                if (wantv) {
                    for (int i = k + 1; i < n; i++) {
                        V[i][k] = e[i];
                    }
                }
            }
        }
        int p = Math.min(n, m + 1);
        if (nct < n) {
            s[nct] = A[nct][nct];
        }
        if (m < p) {
            s[p - 1] = 0.0;
        }
        if (nrt + 1 < p) {
            e[nrt] = A[nrt][p - 1];
        }
        e[p - 1] = 0.0;
        if (wantu) {
            for (int j = nct; j < nu; j++) {
                for (int i = 0; i < m; i++) {
                    U[i][j] = 0.0;
                }
                U[j][j] = 1.0;
            }
            for (int k = nct - 1; k >= 0; k--) {
                if (s[k] != 0.0) {
                    for (int j = k + 1; j < nu; j++) {
                        double t = 0;
                        for (int i = k; i < m; i++) {
                            t += U[i][k] * U[i][j];
                        }
                        t = -t / U[k][k];
                        for (int i = k; i < m; i++) {
                            U[i][j] += t * U[i][k];
                        }
                    }
                    for (int i = k; i < m; i++) {
                        U[i][k] = -U[i][k];
                    }
                    U[k][k] = 1.0 + U[k][k];
                    for (int i = 0; i < k - 1; i++) {
                        U[i][k] = 0.0;
                    }
                } else {
                    for (int i = 0; i < m; i++) {
                        U[i][k] = 0.0;
                    }
                    U[k][k] = 1.0;
                }
            }
        }
        if (wantv) {
            for (int k = n - 1; k >= 0; k--) {
                if ((k < nrt) & (e[k] != 0.0)) {
                    for (int j = k + 1; j < nu; j++) {
                        double t = 0;
                        for (int i = k + 1; i < n; i++) {
                            t += V[i][k] * V[i][j];
                        }
                        t = -t / V[k + 1][k];
                        for (int i = k + 1; i < n; i++) {
                            V[i][j] += t * V[i][k];
                        }
                    }
                }
                for (int i = 0; i < n; i++) {
                    V[i][k] = 0.0;
                }
                V[k][k] = 1.0;
            }
        }
        int pp = p - 1;
        int iter = 0;
        double eps = Math.pow(2.0, -52.0);
        double tiny = Math.pow(2.0, -966.0);
        while (p > 0) {
            int k, kase;
            for (k = p - 2; k >= -1; k--) {
                if (k == -1) {
                    break;
                }
                if (Math.abs(e[k]) <= tiny + eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {
                    e[k] = 0.0;
                    break;
                }
            }
            if (k == p - 2) {
                kase = 4;
            } else {
                int ks;
                for (ks = p - 1; ks >= k; ks--) {
                    if (ks == k) {
                        break;
                    }
                    double t = (ks != p ? Math.abs(e[ks]) : 0.) + (ks != k + 1 ? Math.abs(e[ks - 1]) : 0.);
                    if (Math.abs(s[ks]) <= tiny + eps * t) {
                        s[ks] = 0.0;
                        break;
                    }
                }
                if (ks == k) {
                    kase = 3;
                } else if (ks == p - 1) {
                    kase = 1;
                } else {
                    kase = 2;
                    k = ks;
                }
            }
            k++;
            switch(kase) {
                case 1:
                    {
                        double f = e[p - 2];
                        e[p - 2] = 0.0;
                        for (int j = p - 2; j >= k; j--) {
                            double t = Maths.hypot(s[j], f);
                            double cs = s[j] / t;
                            double sn = f / t;
                            s[j] = t;
                            if (j != k) {
                                f = -sn * e[j - 1];
                                e[j - 1] = cs * e[j - 1];
                            }
                            if (wantv) {
                                for (int i = 0; i < n; i++) {
                                    t = cs * V[i][j] + sn * V[i][p - 1];
                                    V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                                    V[i][j] = t;
                                }
                            }
                        }
                    }
                    break;
                case 2:
                    {
                        double f = e[k - 1];
                        e[k - 1] = 0.0;
                        for (int j = k; j < p; j++) {
                            double t = Maths.hypot(s[j], f);
                            double cs = s[j] / t;
                            double sn = f / t;
                            s[j] = t;
                            f = -sn * e[j];
                            e[j] = cs * e[j];
                            if (wantu) {
                                for (int i = 0; i < m; i++) {
                                    t = cs * U[i][j] + sn * U[i][k - 1];
                                    U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                                    U[i][j] = t;
                                }
                            }
                        }
                    }
                    break;
                case 3:
                    {
                        double scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));
                        double sp = s[p - 1] / scale;
                        double spm1 = s[p - 2] / scale;
                        double epm1 = e[p - 2] / scale;
                        double sk = s[k] / scale;
                        double ek = e[k] / scale;
                        double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
                        double c = (sp * epm1) * (sp * epm1);
                        double shift = 0.0;
                        if ((b != 0.0) | (c != 0.0)) {
                            shift = Math.sqrt(b * b + c);
                            if (b < 0.0) {
                                shift = -shift;
                            }
                            shift = c / (b + shift);
                        }
                        double f = (sk + sp) * (sk - sp) + shift;
                        double g = sk * ek;
                        for (int j = k; j < p - 1; j++) {
                            double t = Maths.hypot(f, g);
                            double cs = f / t;
                            double sn = g / t;
                            if (j != k) {
                                e[j - 1] = t;
                            }
                            f = cs * s[j] + sn * e[j];
                            e[j] = cs * e[j] - sn * s[j];
                            g = sn * s[j + 1];
                            s[j + 1] = cs * s[j + 1];
                            if (wantv) {
                                for (int i = 0; i < n; i++) {
                                    t = cs * V[i][j] + sn * V[i][j + 1];
                                    V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                                    V[i][j] = t;
                                }
                            }
                            t = Maths.hypot(f, g);
                            cs = f / t;
                            sn = g / t;
                            s[j] = t;
                            f = cs * e[j] + sn * s[j + 1];
                            s[j + 1] = -sn * e[j] + cs * s[j + 1];
                            g = sn * e[j + 1];
                            e[j + 1] = cs * e[j + 1];
                            if (wantu && (j < m - 1)) {
                                for (int i = 0; i < m; i++) {
                                    t = cs * U[i][j] + sn * U[i][j + 1];
                                    U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                                    U[i][j] = t;
                                }
                            }
                        }
                        e[p - 2] = f;
                        iter = iter + 1;
                    }
                    break;
                case 4:
                    {
                        if (s[k] <= 0.0) {
                            s[k] = (s[k] < 0.0 ? -s[k] : 0.0);
                            if (wantv) {
                                for (int i = 0; i <= pp; i++) {
                                    V[i][k] = -V[i][k];
                                }
                            }
                        }
                        while (k < pp) {
                            if (s[k] >= s[k + 1]) {
                                break;
                            }
                            double t = s[k];
                            s[k] = s[k + 1];
                            s[k + 1] = t;
                            if (wantv && (k < n - 1)) {
                                for (int i = 0; i < n; i++) {
                                    t = V[i][k + 1];
                                    V[i][k + 1] = V[i][k];
                                    V[i][k] = t;
                                }
                            }
                            if (wantu && (k < m - 1)) {
                                for (int i = 0; i < m; i++) {
                                    t = U[i][k + 1];
                                    U[i][k + 1] = U[i][k];
                                    U[i][k] = t;
                                }
                            }
                            k++;
                        }
                        iter = 0;
                        p--;
                    }
                    break;
            }
        }
    }
",1
12176858,7,"    void sortclasses() {
        int i, j;
        boolean domore;
        vclassptr = new int[numc];
        for (i = 0; i < numc; i++) vclassptr[i] = i;
        domore = true;
        while (domore == true) {
            domore = false;
            for (i = 0; i < numc - 1; i++) {
                if (vclassctr[vclassptr[i]] < vclassctr[vclassptr[i + 1]]) {
                    int temp = vclassptr[i];
                    vclassptr[i] = vclassptr[i + 1];
                    vclassptr[i + 1] = temp;
                    domore = true;
                }
            }
        }
    }
",1
4272289,7,"    public static int[] sortstring(int[] a1) {
        int temp;
        for (int j = 0; j < (a1.length * a1.length); j++) {
            for (int i = 0; i < a1.length - 1; i++) {
                if (a1[i] > a1[i + 1]) {
                    temp = a1[i];
                    a1[i] = a1[i + 1];
                    a1[i + 1] = temp;
                }
            }
        }
        return a1;
    }
",1
22026286,7,"    public static void main(String args[]) {
        int i, j, l;
        short NUMNUMBERS = 100;
        short numbers[] = new short[NUMNUMBERS];
        printIntro();
        int time = (int) System.currentTimeMillis();
        for (i = 0; i < NUMNUMBERS; i++) {
            numbers[i] = (short) (NUMNUMBERS - 1 - i);
        }
        for (i = 0; i < NUMNUMBERS; i++) {
            for (j = 0; j < NUMNUMBERS - i - 1; j++) {
                if (numbers[j] > numbers[j + 1]) {
                    short temp = numbers[j];
                    numbers[j] = numbers[j + 1];
                    numbers[j + 1] = temp;
                }
            }
            if (WANT_PROGRESS) {
                printProgress();
            }
        }
        time = (int) System.currentTimeMillis() - time;
        System.out.print(time);
        System.out.print(""End\n"");
    }
",1
9221721,7,"    public SOCTradeOffer makeOffer(SOCPossiblePiece targetPiece) {
        D.ebugPrintln(""***** MAKE OFFER *****"");
        if (targetPiece == null) {
            return null;
        }
        SOCTradeOffer offer = null;
        SOCResourceSet targetResources = null;
        switch(targetPiece.getType()) {
            case SOCPossiblePiece.CARD:
                targetResources = SOCGame.CARD_SET;
                break;
            case SOCPossiblePiece.ROAD:
                targetResources = SOCGame.ROAD_SET;
                break;
            case SOCPossiblePiece.SETTLEMENT:
                targetResources = SOCGame.SETTLEMENT_SET;
                break;
            case SOCPossiblePiece.CITY:
                targetResources = SOCGame.CITY_SET;
                break;
        }
        SOCResourceSet ourResources = ourPlayerData.getResources();
        D.ebugPrintln(""*** targetResources = "" + targetResources);
        D.ebugPrintln(""*** ourResources = "" + ourResources);
        if (ourResources.contains(targetResources)) {
            return offer;
        }
        if (ourResources.getAmount(SOCResourceConstants.UNKNOWN) > 0) {
            D.ebugPrintln(""AGG WE HAVE UNKNOWN RESOURCES !!!! %%%%%%%%%%%%%%%%%%%%%%%%%%%%"");
            return offer;
        }
        SOCTradeOffer batna = getOfferToBank(targetResources);
        D.ebugPrintln(""*** BATNA = "" + batna);
        SOCBuildingSpeedEstimate estimate = new SOCBuildingSpeedEstimate(ourPlayerData.getNumbers());
        SOCResourceSet giveResourceSet = new SOCResourceSet();
        SOCResourceSet getResourceSet = new SOCResourceSet();
        int batnaBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
        D.ebugPrintln(""*** batnaBuildingTime = "" + batnaBuildingTime);
        if (batna != null) {
            batnaBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, batna.getGiveSet(), batna.getGetSet(), estimate);
        }
        D.ebugPrintln(""*** batnaBuildingTime = "" + batnaBuildingTime);
        int[] rollsPerResource = estimate.getRollsPerResource();
        int[] neededRsrc = new int[5];
        int[] notNeededRsrc = new int[5];
        int neededRsrcCount = 0;
        int notNeededRsrcCount = 0;
        for (int rsrcType = SOCResourceConstants.CLAY; rsrcType <= SOCResourceConstants.WOOD; rsrcType++) {
            if (targetResources.getAmount(rsrcType) > 0) {
                neededRsrc[neededRsrcCount] = rsrcType;
                neededRsrcCount++;
            } else {
                notNeededRsrc[notNeededRsrcCount] = rsrcType;
                notNeededRsrcCount++;
            }
        }
        for (int j = neededRsrcCount - 1; j >= 0; j--) {
            for (int i = 0; i < j; i++) {
                if (rollsPerResource[neededRsrc[i]] > rollsPerResource[neededRsrc[i + 1]]) {
                    int tmp = neededRsrc[i];
                    neededRsrc[i] = neededRsrc[i + 1];
                    neededRsrc[i + 1] = tmp;
                }
            }
        }
        if (D.ebugOn) {
            for (int i = 0; i < neededRsrcCount; i++) {
                D.ebugPrintln(""NEEDED RSRC: "" + neededRsrc[i] + "" : "" + rollsPerResource[neededRsrc[i]]);
            }
        }
        for (int j = notNeededRsrcCount - 1; j >= 0; j--) {
            for (int i = 0; i < j; i++) {
                if (rollsPerResource[notNeededRsrc[i]] > rollsPerResource[notNeededRsrc[i + 1]]) {
                    int tmp = notNeededRsrc[i];
                    notNeededRsrc[i] = notNeededRsrc[i + 1];
                    notNeededRsrc[i + 1] = tmp;
                }
            }
        }
        if (D.ebugOn) {
            for (int i = 0; i < notNeededRsrcCount; i++) {
                D.ebugPrintln(""NOT-NEEDED RSRC: "" + notNeededRsrc[i] + "" : "" + rollsPerResource[notNeededRsrc[i]]);
            }
        }
        boolean[] someoneIsSellingResource = new boolean[SOCResourceConstants.MAXPLUSONE];
        for (int rsrcType = SOCResourceConstants.CLAY; rsrcType <= SOCResourceConstants.WOOD; rsrcType++) {
            someoneIsSellingResource[rsrcType] = false;
            for (int pn = 0; pn < SOCGame.MAXPLAYERS; pn++) {
                if ((pn != ourPlayerData.getPlayerNumber()) && (isSellingResource[pn][rsrcType])) {
                    someoneIsSellingResource[rsrcType] = true;
                    D.ebugPrintln(""*** player "" + pn + "" is selling "" + rsrcType);
                    break;
                }
            }
        }
        int getRsrcIdx = neededRsrcCount - 1;
        while ((getRsrcIdx >= 0) && ((ourResources.getAmount(neededRsrc[getRsrcIdx]) >= targetResources.getAmount(neededRsrc[getRsrcIdx])) || (!someoneIsSellingResource[neededRsrc[getRsrcIdx]]))) {
            getRsrcIdx--;
        }
        if (getRsrcIdx >= 0) {
            D.ebugPrintln(""*** getRsrc = "" + neededRsrc[getRsrcIdx]);
            getResourceSet.add(1, neededRsrc[getRsrcIdx]);
            D.ebugPrintln(""*** offer should be null : offer = "" + offer);
            int giveRsrcIdx = 0;
            while ((giveRsrcIdx < notNeededRsrcCount) && (offer == null)) {
                D.ebugPrintln(""*** ourResources.getAmount("" + notNeededRsrc[giveRsrcIdx] + "") = "" + ourResources.getAmount(notNeededRsrc[giveRsrcIdx]));
                if (ourResources.getAmount(notNeededRsrc[giveRsrcIdx]) > 0) {
                    giveResourceSet.clear();
                    giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx]);
                    offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                    D.ebugPrintln(""*** offer = "" + offer);
                    int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                }
                giveRsrcIdx++;
            }
            D.ebugPrintln(""*** ourResources = "" + ourResources);
            if (offer == null) {
                int giveRsrcIdx1 = 0;
                while ((giveRsrcIdx1 < neededRsrcCount) && (offer == null)) {
                    D.ebugPrintln(""*** ourResources.getAmount("" + neededRsrc[giveRsrcIdx1] + "") = "" + ourResources.getAmount(neededRsrc[giveRsrcIdx1]));
                    D.ebugPrintln(""*** targetResources.getAmount("" + neededRsrc[giveRsrcIdx1] + "") = "" + targetResources.getAmount(neededRsrc[giveRsrcIdx1]));
                    if ((ourResources.getAmount(neededRsrc[giveRsrcIdx1]) > targetResources.getAmount(neededRsrc[giveRsrcIdx1])) && (neededRsrc[giveRsrcIdx1] != neededRsrc[getRsrcIdx])) {
                        giveResourceSet.clear();
                        giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                        int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                        if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                            offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                            D.ebugPrintln(""*** offer = "" + offer);
                            D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                        }
                    }
                    giveRsrcIdx1++;
                }
            }
            D.ebugPrintln(""*** ourResources = "" + ourResources);
            SOCResourceSet leftovers = ourResources.copy();
            leftovers.subtract(targetResources);
            D.ebugPrintln(""*** leftovers = "" + leftovers);
            if (offer == null) {
                int giveRsrcIdx1 = 0;
                int giveRsrcIdx2 = 0;
                while ((giveRsrcIdx1 < notNeededRsrcCount) && (offer == null)) {
                    if (ourResources.getAmount(notNeededRsrc[giveRsrcIdx1]) > 0) {
                        while ((giveRsrcIdx2 < notNeededRsrcCount) && (offer == null)) {
                            giveResourceSet.clear();
                            giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx1]);
                            giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx2]);
                            if (ourResources.contains(giveResourceSet)) {
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                    D.ebugPrintln(""*** offer = "" + offer);
                                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                }
                            }
                            giveRsrcIdx2++;
                        }
                        giveRsrcIdx2 = 0;
                        while ((giveRsrcIdx2 < neededRsrcCount) && (offer == null)) {
                            if (neededRsrc[giveRsrcIdx2] != neededRsrc[getRsrcIdx]) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx1]);
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx2]);
                                if (leftovers.contains(giveResourceSet)) {
                                    int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                    if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                        offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                        D.ebugPrintln(""*** offer = "" + offer);
                                        D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                    }
                                }
                            }
                            giveRsrcIdx2++;
                        }
                    }
                    giveRsrcIdx1++;
                }
                giveRsrcIdx1 = 0;
                giveRsrcIdx2 = 0;
                while ((giveRsrcIdx1 < neededRsrcCount) && (offer == null)) {
                    if ((leftovers.getAmount(neededRsrc[giveRsrcIdx1]) > 0) && (neededRsrc[giveRsrcIdx1] != neededRsrc[getRsrcIdx])) {
                        while ((giveRsrcIdx2 < notNeededRsrcCount) && (offer == null)) {
                            giveResourceSet.clear();
                            giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                            giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx2]);
                            if (leftovers.contains(giveResourceSet)) {
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                    D.ebugPrintln(""*** offer = "" + offer);
                                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                }
                            }
                            giveRsrcIdx2++;
                        }
                        giveRsrcIdx2 = 0;
                        while ((giveRsrcIdx2 < neededRsrcCount) && (offer == null)) {
                            if (neededRsrc[giveRsrcIdx2] != neededRsrc[getRsrcIdx]) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx2]);
                                if (leftovers.contains(giveResourceSet)) {
                                    int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                    if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                        offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                        D.ebugPrintln(""*** offer = "" + offer);
                                        D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                    }
                                }
                            }
                            giveRsrcIdx2++;
                        }
                    }
                    giveRsrcIdx1++;
                }
            }
        }
        if (offer == null) {
            SOCResourceSet leftovers = ourResources.copy();
            leftovers.subtract(targetResources);
            D.ebugPrintln(""*** leftovers = "" + leftovers);
            int getRsrcIdx2 = notNeededRsrcCount - 1;
            while ((getRsrcIdx2 >= 0) && (!someoneIsSellingResource[neededRsrc[getRsrcIdx2]])) {
                getRsrcIdx2--;
            }
            while ((getRsrcIdx2 >= 0) && (offer == null)) {
                getResourceSet.clear();
                getResourceSet.add(1, notNeededRsrc[getRsrcIdx2]);
                leftovers.add(1, notNeededRsrc[getRsrcIdx2]);
                if (offer == null) {
                    int giveRsrcIdx1 = 0;
                    while ((giveRsrcIdx1 < notNeededRsrcCount) && (offer == null)) {
                        if ((leftovers.getAmount(notNeededRsrc[giveRsrcIdx1]) > 0) && (notNeededRsrc[giveRsrcIdx1] != notNeededRsrc[getRsrcIdx2])) {
                            leftovers.subtract(1, notNeededRsrc[giveRsrcIdx1]);
                            if (getOfferToBank(targetResources, leftovers) != null) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx1]);
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if (offerBuildingTime < batnaBuildingTime) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, notNeededRsrc[getRsrcIdx2]);
                                    D.ebugPrintln(""*** offer = "" + offer);
                                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                }
                            }
                            leftovers.add(1, notNeededRsrc[giveRsrcIdx1]);
                        }
                        giveRsrcIdx1++;
                    }
                }
                if (offer == null) {
                    int giveRsrcIdx1 = 0;
                    while ((giveRsrcIdx1 < neededRsrcCount) && (offer == null)) {
                        if (leftovers.getAmount(neededRsrc[giveRsrcIdx1]) > 0) {
                            leftovers.subtract(1, neededRsrc[giveRsrcIdx1]);
                            if (getOfferToBank(targetResources, leftovers) != null) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if (offerBuildingTime < batnaBuildingTime) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, notNeededRsrc[getRsrcIdx2]);
                                    D.ebugPrintln(""*** offer = "" + offer);
                                    D.ebugPrintln(""*** offerBuildingTime = "" + offerBuildingTime);
                                }
                            }
                            leftovers.add(1, neededRsrc[giveRsrcIdx1]);
                        }
                        giveRsrcIdx1++;
                    }
                }
                leftovers.subtract(1, notNeededRsrc[getRsrcIdx2]);
                getRsrcIdx2--;
            }
        }
        return offer;
    }
",1
15757836,7,"    private int[] sort(int n) {
        int[] mas = new int[n];
        Random rand = new Random();
        for (int i = 0; i < n; i++) {
            mas[i] = rand.nextInt(10) + 1;
        }
        boolean t = true;
        int tmp = 0;
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    tmp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = tmp;
                    t = true;
                }
            }
        }
        return mas;
    }
",0
19972831,7,"    public static int[] simplex_reverse_sort(int[] vertices) {
        if (vertices.length <= 1) return vertices;
        for (int j = vertices.length - 1; j > 0; j--) {
            for (int i = 0; i < j; i++) {
                if (vertices[i + 1] > vertices[i]) {
                    int dummy = vertices[i];
                    vertices[i] = vertices[i + 1];
                    vertices[i + 1] = dummy;
                }
            }
        }
        return vertices;
    }
",1
8794510,7,"    public static void bubbleSort(Auto[] xs) {
        boolean unsorted = true;
        while (unsorted) {
            unsorted = false;
            for (int i = 0; i < xs.length - 1; i++) {
                if (!(xs[i].getPreis() >= xs[i + 1].getPreis())) {
                    Auto dummy = xs[i];
                    xs[i] = xs[i + 1];
                    xs[i + 1] = dummy;
                    unsorted = true;
                }
            }
        }
    }
",1
12065181,7,"    private void sortMasters() {
        masterCounter = 0;
        for (int i = 0; i < maxID; i++) {
            if (users[i].getMasterPoints() > 0) {
                masterHandleList[masterCounter] = users[i].getHandle();
                masterPointsList[masterCounter] = users[i].getMasterPoints();
                masterCounter = masterCounter + 1;
            }
        }
        for (int i = masterCounter; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (masterPointsList[j] > masterPointsList[j + 1]) {
                    int tempp = masterPointsList[j];
                    String temppstring = masterHandleList[j];
                    masterPointsList[j] = masterPointsList[j + 1];
                    masterHandleList[j] = masterHandleList[j + 1];
                    masterPointsList[j + 1] = tempp;
                    masterHandleList[j + 1] = temppstring;
                }
            }
        }
    }
",1
10479536,7,"    private void bubbleSort(int values[]) {
        PerfMonTimer timerOuter = PerfMonTimer.start(""SortingTest.bubbleSort"");
        try {
            int len = values.length - 1;
            for (int i = 0; i < len; i++) {
                for (int j = 0; j < len - i; j++) {
                    if (values[j] > values[j + 1]) {
                        int tmp = values[j];
                        values[j] = values[j + 1];
                        values[j + 1] = tmp;
                    }
                }
            }
        } finally {
            PerfMonTimer.stop(timerOuter);
        }
    }
",1
21100204,7,"    public void greatestIncrease(int maxIterations) {
        double[] increase = new double[numModels];
        int[] id = new int[numModels];
        Model md = new Model();
        double oldPerf = 1;
        for (int i = 0; i < numModels; i++) {
            md.addModel(models[i], false);
            increase[i] = oldPerf - md.getLoss();
            id[i] = i;
            oldPerf = md.getLoss();
        }
        for (int i = 0; i < numModels; i++) {
            for (int j = 0; j < numModels - 1 - i; j++) {
                if (increase[j] < increase[j + 1]) {
                    double increasetemp = increase[j];
                    int temp = id[j];
                    increase[j] = increase[j + 1];
                    id[j] = id[j + 1];
                    increase[j + 1] = increasetemp;
                    id[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < maxIterations; i++) {
            addToEnsemble(models[id[i]]);
            if (report) ensemble.report(models[id[i]].getName(), allSets);
            updateBestModel();
        }
    }
",1
12646326,7,"    private void weightAndPlaceClasses() {
        int rows = getRows();
        for (int curRow = _maxPackageRank; curRow < rows; curRow++) {
            xPos = getHGap() / 2;
            BOTLRuleDiagramNode[] rowObject = getObjectsInRow(curRow);
            for (int i = 0; i < rowObject.length; i++) {
                if (curRow == _maxPackageRank) {
                    int nDownlinks = rowObject[i].getDownlinks().size();
                    rowObject[i].setWeight((nDownlinks > 0) ? (1 / nDownlinks) : 2);
                } else {
                    Vector uplinks = rowObject[i].getUplinks();
                    int nUplinks = uplinks.size();
                    if (nUplinks > 0) {
                        float average_col = 0;
                        for (int j = 0; j < uplinks.size(); j++) {
                            average_col += ((BOTLRuleDiagramNode) (uplinks.elementAt(j))).getColumn();
                        }
                        average_col /= nUplinks;
                        rowObject[i].setWeight(average_col);
                    } else {
                        rowObject[i].setWeight(1000);
                    }
                }
            }
            int[] pos = new int[rowObject.length];
            for (int i = 0; i < pos.length; i++) {
                pos[i] = i;
            }
            boolean swapped = true;
            while (swapped) {
                swapped = false;
                for (int i = 0; i < pos.length - 1; i++) {
                    if (rowObject[pos[i]].getWeight() > rowObject[pos[i + 1]].getWeight()) {
                        int temp = pos[i];
                        pos[i] = pos[i + 1];
                        pos[i + 1] = temp;
                        swapped = true;
                    }
                }
            }
            for (int i = 0; i < pos.length; i++) {
                rowObject[pos[i]].setColumn(i);
                if ((i > _vMax) && (rowObject[pos[i]].getUplinks().size() == 0) && (rowObject[pos[i]].getDownlinks().size() == 0)) {
                    if (getColumns(rows - 1) > _vMax) {
                        rows++;
                    }
                    rowObject[pos[i]].setRank(rows - 1);
                } else {
                    rowObject[pos[i]].setLocation(new Point(xPos, yPos));
                    xPos += rowObject[pos[i]].getSize().getWidth() + getHGap();
                }
            }
            yPos += getRowHeight(curRow) + getVGap();
        }
    }
",0
22307690,7,"    public static void main(String args[]) {
        int summ = 0;
        int temp = 0;
        int[] a1 = { 0, 6, -7, -7, 61, 8, 20, 0, 8, 3, 6, 2, 7, 99, 0, 23, 12, 7, 9, 5, 33, 1, 3, 99, 99, 61, 99, 99, 99, 61, 61, 61, -3, -3, -3, -3 };
        for (int j = 0; j < (a1.length * a1.length); j++) {
            for (int i = 0; i < a1.length - 1; i++) {
                if (a1[i] > a1[i + 1]) {
                    temp = a1[i];
                    a1[i] = a1[i + 1];
                    a1[i + 1] = temp;
                }
            }
        }
        for (int i = 0; i < a1.length; i++) {
            System.out.print("" "" + a1[i]);
        }
        int min = 0;
        int max = 0;
        summ = (a1[1]) + (a1[a1.length - 1]);
        for (int i = 0; i < a1.length; i++) {
            if (a1[i] > a1[0] && a1[i] != a1[0]) {
                min = a1[i];
                break;
            }
        }
        for (int i = a1.length - 1; i > 0; i--) {
            if (a1[i] < a1[a1.length - 1] & a1[i] != a1[a1.length - 1]) {
                max = a1[i];
                break;
            }
        }
        System.out.println();
        System.out.print(""summa 2 min N 2 max = "" + summ);
        System.out.println(min);
        System.out.println(max);
        System.out.println(""summa 2 min N 2 max = "" + (min + max));
    }
",0
16123665,7,"    public static void bubbleSort(Drawable[] list) {
        boolean swapped;
        do {
            swapped = false;
            for (int i = 0; i < list.length - 1; ++i) {
                if (list[i].getSortValue() > list[i + 1].getSortValue()) {
                    Drawable temp = list[i];
                    list[i] = list[i + 1];
                    list[i + 1] = temp;
                    swapped = true;
                }
            }
        } while (swapped);
    }
",1
22137813,7,"    public static ObjectID[] sortDecending(ObjectID[] oids) {
        for (int i = 1; i < oids.length; i++) {
            ObjectID iId = oids[i];
            for (int j = 0; j < oids.length - i; j++) {
                if (oids[j].getTypePrefix() > oids[j + 1].getTypePrefix()) {
                    ObjectID temp = oids[j];
                    oids[j] = oids[j + 1];
                    oids[j + 1] = temp;
                }
            }
        }
        return oids;
    }
",1
4860089,7,"    public int[] sort() {
        int i, tmp;
        int[] newIndex = new int[nrows];
        for (i = 0; i < nrows; i++) {
            newIndex[i] = i;
        }
        boolean change = true;
        if (this.ascending) {
            if (data[0][column] instanceof Comparable) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if (((Comparable) data[newIndex[i]][column]).compareTo((Comparable) data[newIndex[i + 1]][column]) > 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
                return newIndex;
            }
            if (data[0][column] instanceof String || data[0][column] instanceof ClassLabel) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if ((data[newIndex[i]][column].toString()).compareTo(data[newIndex[i + 1]][column].toString()) > 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
            }
            return newIndex;
        }
        if (!this.ascending) {
            if (data[0][column] instanceof Comparable) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if (((Comparable) data[newIndex[i]][column]).compareTo((Comparable) data[newIndex[i + 1]][column]) < 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
                return newIndex;
            }
            if (data[0][column] instanceof String || data[0][column] instanceof ClassLabel) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if ((data[newIndex[i]][column].toString()).compareTo(data[newIndex[i + 1]][column].toString()) < 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
            }
            return newIndex;
        } else return newIndex;
    }
",1
10606028,7,"    public void bubble() {
        boolean test = false;
        int kars = 0, tas = 0;
        while (true) {
            for (int j = 0; j < dizi.length - 1; j++) {
                kars++;
                if (dizi[j] > dizi[j + 1]) {
                    int temp = dizi[j];
                    dizi[j] = dizi[j + 1];
                    dizi[j + 1] = temp;
                    test = true;
                    tas++;
                }
            }
            if (!test) {
                break;
            } else {
                test = false;
            }
        }
        System.out.print(kars + "" "" + tas);
    }
",1
1362,7,"    public static int[] bubbleSort(int... a) {
        boolean swapped;
        do {
            swapped = false;
            for (int i = 0; i < a.length - 1; i++) {
                if (a[i] > a[i + 1]) {
                    int tmp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = tmp;
                    swapped = true;
                }
            }
        } while (swapped);
        return a;
    }
",1
23089693,7,"    public int NthLowestSkill(int n) {
        int[] skillIds = new int[] { 0, 1, 2, 3 };
        for (int j = 0; j < 3; j++) {
            for (int i = 0; i < 3 - j; i++) {
                if (Skills()[skillIds[i]] > Skills()[skillIds[i + 1]]) {
                    int temp = skillIds[i];
                    skillIds[i] = skillIds[i + 1];
                    skillIds[i + 1] = temp;
                }
            }
        }
        return skillIds[n - 1];
    }
",1
21273058,7,"    public RobotList<Percentage> sort_decr_Percentage(RobotList<Percentage> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i).percent);
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value < distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Percentage> sol = new RobotList<Percentage>(Percentage.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Percentage(distri[i].value));
        }
        return sol;
    }
",1
8227164,7,"    static int[] bubble(int[] s) {
        boolean f = true;
        while (f) {
            f = false;
            for (int i = 0; i < s.length - 1; i++) {
                if (s[i] > s[i + 1]) {
                    int t = s[i];
                    s[i] = s[i + 1];
                    s[i + 1] = t;
                    f = true;
                }
            }
        }
        return s;
    }
",0
17630905,7,"    public static int[] sortAscending(int input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] > input[j + 1]) {
                    int mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
",1
14632238,7,"    public static void bubble(double[] a) {
        for (int i = a.length - 1; i > 0; i--) for (int j = 0; j < i; j++) if (a[j] > a[j + 1]) {
            double temp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = temp;
        }
    }
",1
21273054,7,"    public RobotList<Enemy> sort_decr_Enemy(RobotList<Enemy> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        if (field.equals("""") || field.equals(""location"")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals(""health"")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say(""impossible to sort list - nothing modified"");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value < enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Enemy> new_enemy_list = new RobotList<Enemy>(Enemy.class);
        for (int i = 0; i < length; i++) {
            new_enemy_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_enemy_list;
    }
",1
12747342,7,"    public void bubbleSort(final int[] s) {
        source = s;
        if (source.length < 2) return;
        boolean go = true;
        while (go) {
            go = false;
            for (int i = 0; i < source.length - 1; i++) {
                int temp = source[i];
                if (temp > source[i + 1]) {
                    source[i] = source[i + 1];
                    source[i + 1] = temp;
                    go = true;
                }
            }
        }
    }
",1
11892804,7,"    private int[] Tri(int[] pertinence, int taille) {
        boolean change = true;
        int tmp;
        while (change) {
            change = false;
            for (int i = 0; i < taille - 2; i++) {
                if (pertinence[i] < pertinence[i + 1]) {
                    tmp = pertinence[i];
                    pertinence[i] = pertinence[i + 1];
                    pertinence[i + 1] = tmp;
                    change = true;
                }
            }
        }
        return pertinence;
    }
",1
12561704,7,"    private void bubbleSort(int[] mas) {
        boolean t = true;
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    int temp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = temp;
                    t = true;
                }
            }
        }
    }
",0
21273051,7,"    public RobotList<Float> sort_incr_Float(RobotList<Float> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i));
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value > distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Float> sol = new RobotList<Float>(Float.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Float(distri[i].value));
        }
        return sol;
    }
",1
21273060,7,"    public RobotList<Location> sort_decr_Location(RobotList<Location> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        if (field.equals("""") || field.equals(""location"")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i)));
            }
        } else if (field.equals(""x"")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).x);
            }
        } else if (field.equals(""y"")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).y);
            }
        } else {
            say(""impossible to sort list - nothing modified"");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value < enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Location> new_location_list = new RobotList<Location>(Location.class);
        for (int i = 0; i < length; i++) {
            new_location_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_location_list;
    }
",1
10598170,7,"    private static String sort(final String item) {
        final char[] chars = item.toCharArray();
        for (int i = 1; i < chars.length; i++) {
            for (int j = 0; j < chars.length - 1; j++) {
                if (chars[j] > chars[j + 1]) {
                    final char temp = chars[j];
                    chars[j] = chars[j + 1];
                    chars[j + 1] = temp;
                }
            }
        }
        return String.valueOf(chars);
    }
",1
15195064,7,"    public int[] do_it(final int[] x) {
        int temp = 0;
        int j = x.length;
        while (j > 0) {
            for (int i = 0; i < j - 1; i++) {
                if (x[i] > x[i + 1]) {
                    temp = x[i];
                    x[i] = x[i + 1];
                    x[i + 1] = temp;
                }
                ;
            }
            ;
            j--;
        }
        ;
        return x;
    }
",1
3197876,7,"    public ArrayList<String> showTopLetters() {
        int[] tempArray = new int[engCountLetters.length];
        char[] tempArrayLetters = new char[abcEng.length];
        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();
        tempArray = engCountLetters.clone();
        tempArrayLetters = abcEng.clone();
        int tempCount;
        char tempLetters;
        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {
            for (int i = 0; i < abcEng.length - 1; i++) {
                if (tempArray[i] > tempArray[i + 1]) {
                    tempCount = tempArray[i];
                    tempLetters = tempArrayLetters[i];
                    tempArray[i] = tempArray[i + 1];
                    tempArrayLetters[i] = tempArrayLetters[i + 1];
                    tempArray[i + 1] = tempCount;
                    tempArrayLetters[i + 1] = tempLetters;
                }
            }
        }
        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {
            resultTopFiveLetters.add(tempArrayLetters[i] + "":"" + tempArray[i]);
        }
        return resultTopFiveLetters;
    }
",1
20181656,7,"    private int[] sortRows(int[] rows) {
        for (int i = 0; i < rows.length; i++) {
            for (int j = 0; j < rows.length - 1; j++) {
                if (rows[j] > rows[j + 1]) {
                    int temp = rows[j];
                    rows[j] = rows[j + 1];
                    rows[j + 1] = temp;
                }
            }
        }
        return rows;
    }
",0
22486940,7,"    public void sortingByBubble(int[] array) {
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
",1
5127007,7,"    public static void bubbleSort(int[] a) {
        for (int i = a.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    int tmp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = tmp;
                }
            }
        }
    }
",1
21273057,7,"    public RobotList<Percentage> sort_incr_Percentage(RobotList<Percentage> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i).percent);
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value > distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Percentage> sol = new RobotList<Percentage>(Percentage.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Percentage(distri[i].value));
        }
        return sol;
    }
",0
16064530,7,"    private void bubbleSort() {
        for (int i = 0; i < testfield.length; i++) {
            for (int j = 0; j < testfield.length - i - 1; j++) if (testfield[j] > testfield[j + 1]) {
                short temp = testfield[j];
                testfield[j] = testfield[j + 1];
                testfield[j + 1] = temp;
            }
        }
    }
",0
20680657,7,"    protected void sort(int a) {
        int[] masiv = new int[a + 1];
        Random fff = new Random();
        for (int i = 0; i <= a; i++) {
            masiv[i] = fff.nextInt(9);
        }
        int d;
        for (int j = 0; j < a; j++) {
            for (int i = 0; i < a; i++) {
                if (masiv[i] < masiv[i + 1]) {
                } else {
                    d = masiv[i];
                    masiv[i] = masiv[i + 1];
                    masiv[i + 1] = d;
                }
            }
        }
        while (a != 0) {
            System.out.println(""sort: "" + masiv[a]);
            a--;
        }
    }
",1
18378776,7,"    public int[] getRandMas(int n) {
        boolean t = true;
        int interim = 0;
        int[] mas = new int[n];
        Random rand = new Random();
        for (int i = 0; i < n; i++) {
            mas[i] = rand.nextInt(10) + 1;
        }
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    interim = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = interim;
                    t = true;
                }
            }
        }
        return mas;
    }
",1
17583193,7,"    public boolean populateRecord(int[] attrIDs) throws IOException {
        if (device == null) {
            throw new RuntimeException(""This is local device service record"");
        }
        if (attrIDs == null) {
            throw new NullPointerException(""attrIDs is null"");
        }
        if (attrIDs.length == 0) {
            throw new IllegalArgumentException();
        }
        for (int i = 0; i < attrIDs.length; i++) {
            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {
                throw new IllegalArgumentException();
            }
        }
        int[] sortIDs = new int[attrIDs.length];
        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);
        for (int i = 0; i < sortIDs.length; i++) {
            for (int j = 0; j < sortIDs.length - i - 1; j++) {
                if (sortIDs[j] > sortIDs[j + 1]) {
                    int temp = sortIDs[j];
                    sortIDs[j] = sortIDs[j + 1];
                    sortIDs[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < sortIDs.length - 1; i++) {
            if (sortIDs[i] == sortIDs[i + 1]) {
                throw new IllegalArgumentException();
            }
            DebugLog.debug0x(""query for "", sortIDs[i]);
        }
        DebugLog.debug0x(""query for "", sortIDs[sortIDs.length - 1]);
        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);
    }
",1
21273055,7,"    public RobotList<Resource> sort_incr_Resource(RobotList<Resource> list, String field) {
        int length = list.size();
        Index_value[] resource_dist = new Index_value[length];
        if (field.equals("""") || field.equals(""location"")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals(""energy"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).energy);
            }
        } else if (field.equals(""ammostash"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).ammostash);
            }
        } else if (field.equals(""speed"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).speed);
            }
        } else if (field.equals(""health"")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say(""impossible to sort list - nothing modified"");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (resource_dist[i].value > resource_dist[i + 1].value) {
                    Index_value a = resource_dist[i];
                    resource_dist[i] = resource_dist[i + 1];
                    resource_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Resource> new_resource_list = new RobotList<Resource>(Resource.class);
        for (int i = 0; i < length; i++) {
            new_resource_list.addLast(list.get(resource_dist[i].index));
        }
        return new_resource_list;
    }
",1
15609432,7,"    public static int[] bubbleSort(int[] source) {
        if (source != null && source.length > 0) {
            boolean flag = true;
            while (flag) {
                flag = false;
                for (int i = 0; i < source.length - 1; i++) {
                    if (source[i] > source[i + 1]) {
                        int temp = source[i];
                        source[i] = source[i + 1];
                        source[i + 1] = temp;
                        flag = true;
                    }
                }
            }
        }
        return source;
    }
",1
6480424,7,"    public void method31() {
        boolean flag = true;
        while (flag) {
            flag = false;
            for (int i = 0; i < anInt772 - 1; i++) if (anIntArray774[i] < anIntArray774[i + 1]) {
                int j = anIntArray774[i];
                anIntArray774[i] = anIntArray774[i + 1];
                anIntArray774[i + 1] = j;
                long l = aLongArray773[i];
                aLongArray773[i] = aLongArray773[i + 1];
                aLongArray773[i + 1] = l;
                flag = true;
            }
        }
    }
",1
22326008,7,"    @Override
    public void sortArray(int[] array) {
        boolean sorted = false;
        while (sorted == false) {
            sorted = true;
            for (int i = 0; i <= array.length - 2; i++) {
                if (array[i] > array[i + 1]) {
                    int temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                    sorted = false;
                }
            }
        }
    }
",1
17630909,7,"    public static int[] sortAscending(double input[]) {
        int[] order = new int[input.length];
        for (int i = 0; i < order.length; i++) order[i] = i;
        for (int i = input.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (input[j] > input[j + 1]) {
                    double mem = input[j];
                    input[j] = input[j + 1];
                    input[j + 1] = mem;
                    int id = order[j];
                    order[j] = order[j + 1];
                    order[j + 1] = id;
                }
            }
        }
        return order;
    }
",1
9385633,7,"    protected void setRankOrder() {
        this.rankOrder = new int[values.length];
        for (int i = 0; i < rankOrder.length; i++) {
            rankOrder[i] = i;
            assert (!Double.isNaN(values[i]));
        }
        for (int i = rankOrder.length - 1; i >= 0; i--) {
            boolean swapped = false;
            for (int j = 0; j < i; j++) if (values[rankOrder[j]] < values[rankOrder[j + 1]]) {
                int r = rankOrder[j];
                rankOrder[j] = rankOrder[j + 1];
                rankOrder[j + 1] = r;
            }
        }
    }
",0
21273059,7,"    public RobotList<Location> sort_incr_Location(RobotList<Location> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        Location cur_loc = this.getLocation();
        for (int i = 0; i < length; i++) {
            enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i)));
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value > enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Location> new_location_list = new RobotList<Location>(Location.class);
        for (int i = 0; i < length; i++) {
            new_location_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_location_list;
    }
",1
22486941,7,"    public void modifyBubble(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i % 2 != 0) {
                for (int j = array.length - i / 2 - 2; j >= i / 2; j--) {
                    if (array[j] >= array[j + 1]) {
                        int temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                    }
                }
            } else {
                for (int j = i / 2; j < array.length - 1 - i / 2; j++) {
                    if (array[j] >= array[j + 1]) {
                        int temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                    }
                }
            }
        }
    }
",1
9210368,13,"    public ThreadChoiceFromSet randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            ThreadInfo tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
",1
9883524,13,"    private void choose() {
        final int n = operators.length;
        if (nPick < n) {
            if (unequalWeights) {
                chooseUsingWeights();
            } else {
                for (int k = 0; k < nPick; ++k) {
                    final int which = k + MathUtils.nextInt(n - k);
                    final MCMCOperator tmp = currentRound[k];
                    currentRound[k] = currentRound[which];
                    currentRound[which] = tmp;
                }
            }
        }
    }
",0
6138230,13,"    public DoubleChoiceFromSet randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            String tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
",1
966813,13,"    void shuffle(MersenneTwisterFast random) {
        int numObjs = fitnesses.length;
        float[] fitnesses = this.fitnesses;
        int[] indices = this.indices;
        float f;
        int i;
        int rand;
        for (int x = numObjs - 1; x >= 1; x--) {
            rand = random.nextInt(x + 1);
            f = fitnesses[x];
            fitnesses[x] = fitnesses[rand];
            fitnesses[rand] = f;
            i = indices[x];
            indices[x] = indices[rand];
            indices[rand] = i;
        }
    }
",1
17621068,13,"    public static synchronized <T> void shuffle(T[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            T temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
",1
3894025,13,"    public void shuffle() {
        Random rand = new Random();
        for (int i = size() - 1; i > 0; i--) {
            int newIndex = rand.nextInt(i + 1);
            T temp = get(newIndex);
            set(newIndex, get(i));
            set(i, temp);
        }
    }
",1
7670209,13,"    public static void shuffleList(List<Integer> a) {
        int n = a.size();
        Random random = new Random();
        random.nextInt();
        for (int i = 0; i < n; i++) {
            int change = i + random.nextInt(n - i);
            swap(a, i, change);
        }
    }
",1
3596847,13,"    private static void solve_l2r_l1l2_svc(Problem prob, double[] w, double eps, double Cp, double Cn, SolverType solver_type) {
        int l = prob.l;
        int w_size = prob.n;
        int i, s, iter = 0;
        double C, d, G;
        double[] QD = new double[l];
        int max_iter = 1000;
        int[] index = new int[l];
        double[] alpha = new double[l];
        byte[] y = new byte[l];
        int active_size = l;
        double PG;
        double PGmax_old = Double.POSITIVE_INFINITY;
        double PGmin_old = Double.NEGATIVE_INFINITY;
        double PGmax_new, PGmin_new;
        double diag[] = new double[] { 0.5 / Cn, 0, 0.5 / Cp };
        double upper_bound[] = new double[] { Double.POSITIVE_INFINITY, 0, Double.POSITIVE_INFINITY };
        if (solver_type == SolverType.L2R_L1LOSS_SVC_DUAL) {
            diag[0] = 0;
            diag[2] = 0;
            upper_bound[0] = Cn;
            upper_bound[2] = Cp;
        }
        for (i = 0; i < w_size; i++) w[i] = 0;
        for (i = 0; i < l; i++) {
            alpha[i] = 0;
            if (prob.y[i] > 0) {
                y[i] = +1;
            } else {
                y[i] = -1;
            }
            QD[i] = diag[GETI(y, i)];
            for (FeatureNode xi : prob.x[i]) {
                QD[i] += xi.value * xi.value;
            }
            index[i] = i;
        }
        while (iter < max_iter) {
            PGmax_new = Double.NEGATIVE_INFINITY;
            PGmin_new = Double.POSITIVE_INFINITY;
            for (i = 0; i < active_size; i++) {
                int j = i + random.nextInt(active_size - i);
                swap(index, i, j);
            }
            for (s = 0; s < active_size; s++) {
                i = index[s];
                G = 0;
                byte yi = y[i];
                for (FeatureNode xi : prob.x[i]) {
                    G += w[xi.index - 1] * xi.value;
                }
                G = G * yi - 1;
                C = upper_bound[GETI(y, i)];
                G += alpha[i] * diag[GETI(y, i)];
                PG = 0;
                if (alpha[i] == 0) {
                    if (G > PGmax_old) {
                        active_size--;
                        swap(index, s, active_size);
                        s--;
                        continue;
                    } else if (G < 0) {
                        PG = G;
                    }
                } else if (alpha[i] == C) {
                    if (G < PGmin_old) {
                        active_size--;
                        swap(index, s, active_size);
                        s--;
                        continue;
                    } else if (G > 0) {
                        PG = G;
                    }
                } else {
                    PG = G;
                }
                PGmax_new = Math.max(PGmax_new, PG);
                PGmin_new = Math.min(PGmin_new, PG);
                if (Math.abs(PG) > 1.0e-12) {
                    double alpha_old = alpha[i];
                    alpha[i] = Math.min(Math.max(alpha[i] - G / QD[i], 0.0), C);
                    d = (alpha[i] - alpha_old) * yi;
                    for (FeatureNode xi : prob.x[i]) {
                        w[xi.index - 1] += d * xi.value;
                    }
                }
            }
            iter++;
            if (iter % 10 == 0) info(""."");
            if (PGmax_new - PGmin_new <= eps) {
                if (active_size == l) break; else {
                    active_size = l;
                    info(""*"");
                    PGmax_old = Double.POSITIVE_INFINITY;
                    PGmin_old = Double.NEGATIVE_INFINITY;
                    continue;
                }
            }
            PGmax_old = PGmax_new;
            PGmin_old = PGmin_new;
            if (PGmax_old <= 0) PGmax_old = Double.POSITIVE_INFINITY;
            if (PGmin_old >= 0) PGmin_old = Double.NEGATIVE_INFINITY;
        }
        info(NL + ""optimization finished, #iter = %d"" + NL, iter);
        if (iter >= max_iter) info(""%nWARNING: reaching max number of iterations%nUsing -s 2 may be faster (also see FAQ)%n%n"");
        double v = 0;
        int nSV = 0;
        for (i = 0; i < w_size; i++) v += w[i] * w[i];
        for (i = 0; i < l; i++) {
            v += alpha[i] * (alpha[i] * diag[GETI(y, i)] - 2);
            if (alpha[i] > 0) ++nSV;
        }
        info(""Objective value = %f"" + NL, v / 2);
        info(""nSV = %d"" + NL, nSV);
    }
",1
7079645,13,"    public synchronized boolean setSource(File file) {
        if (!file.isDirectory()) {
            return false;
        }
        m_current = -1;
        Random rand = new Random();
        m_files = file.listFiles(new ValidFileFilter());
        if (m_random) {
            List<File> fileList = Arrays.asList(m_files);
            Collections.shuffle(fileList, rand);
            m_files = fileList.toArray(m_files);
        }
        m_innerCount = 0;
        m_multiStimuliParsers = false;
        List<int[]> orderList = new LinkedList<int[]>();
        int[] order = null;
        StimuliParser parser = new FolderParser(m_maxsize, m_spp, 1, m_controls, false);
        StimuliParser parser2 = null;
        if (m_spp > 1) parser2 = new FolderParser(m_maxsize, m_spp - 1, 1, m_controls, false);
        if (parser.setSource(m_files[0])) {
            List<int[]> singleOrderList = new LinkedList<int[]>();
            m_multiStimuliParsers = true;
            order = new int[2];
            order[0] = 0;
            int thiscount = parser.getInnerStimuliCount();
            for (int i = 0; i < thiscount; ++i) {
                order[1] = i;
                singleOrderList.add(order.clone());
            }
            m_innerCount += thiscount;
            if (m_random) {
                Collections.shuffle(singleOrderList, rand);
            }
            orderList.addAll(singleOrderList);
        } else if (m_spp > 1) {
            File tiedFolder = getTiedFolder(m_files[0]);
            if (tiedFolder.isDirectory()) {
                List<int[]> singleOrderList = new LinkedList<int[]>();
                m_multiStimuliParsers = true;
                parser2.setSource(tiedFolder);
                order = new int[2];
                order[0] = 0;
                int thiscount = parser2.getInnerStimuliCount();
                for (int i = 0; i < thiscount; ++i) {
                    order[1] = i;
                    singleOrderList.add(order.clone());
                }
                m_innerCount += thiscount;
                if (m_random) Collections.shuffle(singleOrderList, rand);
                orderList.addAll(singleOrderList);
            }
        }
        if (m_multiStimuliParsers) {
            for (int i = 1; i < m_files.length; ++i) {
                List<int[]> singleOrderList = new LinkedList<int[]>();
                order[0] = i;
                int thiscount;
                if (!parser.setSource(m_files[i])) {
                    File tiedFolder = getTiedFolder(m_files[i]);
                    parser2.setSource(tiedFolder);
                    thiscount = parser2.getInnerStimuliCount();
                } else thiscount = parser.getInnerStimuliCount();
                for (int j = 0; j < thiscount; ++j) {
                    order[1] = j;
                    singleOrderList.add(order.clone());
                }
                m_innerCount += thiscount;
                if (m_random) {
                    Collections.shuffle(singleOrderList, rand);
                }
                orderList.addAll(singleOrderList);
            }
        } else {
            order = new int[m_spp];
            for (int i = 0; i < m_spp; ++i) order[i] = i;
            int h = 0;
            int choices = 0;
            while (true) {
                orderList.add(order.clone());
                ++choices;
                if (order[h] == m_files.length - m_spp + h) {
                    if (h == 0) break;
                    ++order[--h];
                    for (int i = h + 1; i < m_spp; ++i) order[i] = order[i - 1] + 1;
                } else {
                    h = m_spp - 1;
                    ++order[h];
                }
            }
            m_innerCount = choices;
            if (m_random) Collections.shuffle(orderList, rand);
        }
        if (m_sequences > 1) {
            m_innerCount *= m_sequences;
            List<int[]> holder = new LinkedList<int[]>(orderList);
            for (int i = 1; i < m_sequences; ++i) {
                List<int[]> temp = new LinkedList<int[]>();
                for (int[] v : orderList) temp.add(v.clone());
                Collections.shuffle(temp, rand);
                holder.addAll(temp);
            }
            orderList = holder;
        }
        m_order = orderList.toArray(new int[m_innerCount][order.length]);
        if (!m_multiStimuliParsers && m_random) {
            int temp;
            for (int[] v : m_order) {
                for (int i = 1; i < v.length; ++i) {
                    int swapi = rand.nextInt(i + 1);
                    if (swapi != i) {
                        temp = v[i];
                        v[i] = v[swapi];
                        v[swapi] = temp;
                    }
                }
            }
        }
        m_parsers = new StimuliParser[m_order[0].length];
        return true;
    }
",1
2423912,13,"    public static void shuffle(double[] source, Random randomizer) {
        int n = source.length;
        for (int i = n - 1; i > 0; i--) {
            int j = randomizer.nextInt(i + 1);
            double k = source[j];
            source[j] = source[i];
            source[i] = k;
        }
    }
",1
5172908,13,"    private static void shufflePool(List<Letter> a) {
        int n = a.toArray().length;
        Random random = new Random();
        random.nextInt();
        for (int i = 0; i < n; i++) {
            int change = i + random.nextInt(n - i);
            swap(a, i, change);
        }
    }
",1
7848932,13,"        private Target randomize(Target t) {
            if (t != null && t.getNext() != null) {
                ArrayList list = new ArrayList();
                while (t != null) {
                    list.add(t);
                    t = t.getNext();
                }
                Target[] arr = (Target[]) list.toArray(new Target[list.size()]);
                if (true) {
                    Arrays.sort(arr, new Comparator() {

                        public int compare(Object lhs, Object rhs) {
                            return ((Target) rhs).name.compareTo(((Target) lhs).name);
                        }
                    });
                    for (int i = 0; i < arr.length; ++i) {
                        t = arr[i].setNext(t);
                    }
                }
                if (params.random != null) {
                    t = null;
                    Random r = params.random;
                    for (int i = arr.length; --i >= 1; ) {
                        int x = r.nextInt(i + 1);
                        t = arr[x].setNext(t);
                        arr[x] = arr[i];
                    }
                    t = arr[0].setNext(t);
                }
            }
            return t;
        }
",1
19654781,13,"    public static void shuffle(double[] a) {
        Random random = new Random();
        for (int i = a.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            double swap = a[i];
            a[i] = a[j];
            a[j] = swap;
        }
    }
",1
8533735,13,"    public void shuffle() {
        Card tempCard = new Card();
        for (int i = 0; i < NUM_CARDS; i++) {
            int j = i + r.nextInt(NUM_CARDS - i);
            tempCard = cards[j];
            cards[j] = cards[i];
            cards[i] = tempCard;
        }
        position = 0;
    }
",1
10496866,13,"    public static void svm_cross_validation(svm_problem prob, svm_parameter param, int nr_fold, double[] target) {
        int i;
        int[] fold_start = new int[nr_fold + 1];
        int l = prob.l;
        int[] perm = new int[l];
        if ((param.svm_type == svm_parameter.C_SVC || param.svm_type == svm_parameter.NU_SVC) && nr_fold < l) {
            int[] tmp_nr_class = new int[1];
            int[][] tmp_label = new int[1][];
            int[][] tmp_start = new int[1][];
            int[][] tmp_count = new int[1][];
            svm_group_classes(prob, tmp_nr_class, tmp_label, tmp_start, tmp_count, perm);
            int nr_class = tmp_nr_class[0];
            int[] start = tmp_start[0];
            int[] count = tmp_count[0];
            int[] fold_count = new int[nr_fold];
            int c;
            int[] index = new int[l];
            for (i = 0; i < l; i++) index[i] = perm[i];
            for (c = 0; c < nr_class; c++) for (i = 0; i < count[c]; i++) {
                int j = i + rand.nextInt(count[c] - i);
                do {
                    int _ = index[start[c] + j];
                    index[start[c] + j] = index[start[c] + i];
                    index[start[c] + i] = _;
                } while (false);
            }
            for (i = 0; i < nr_fold; i++) {
                fold_count[i] = 0;
                for (c = 0; c < nr_class; c++) fold_count[i] += (i + 1) * count[c] / nr_fold - i * count[c] / nr_fold;
            }
            fold_start[0] = 0;
            for (i = 1; i <= nr_fold; i++) fold_start[i] = fold_start[i - 1] + fold_count[i - 1];
            for (c = 0; c < nr_class; c++) for (i = 0; i < nr_fold; i++) {
                int begin = start[c] + i * count[c] / nr_fold;
                int end = start[c] + (i + 1) * count[c] / nr_fold;
                for (int j = begin; j < end; j++) {
                    perm[fold_start[i]] = index[j];
                    fold_start[i]++;
                }
            }
            fold_start[0] = 0;
            for (i = 1; i <= nr_fold; i++) fold_start[i] = fold_start[i - 1] + fold_count[i - 1];
        } else {
            for (i = 0; i < l; i++) perm[i] = i;
            for (i = 0; i < l; i++) {
                int j = i + rand.nextInt(l - i);
                do {
                    int _ = perm[i];
                    perm[i] = perm[j];
                    perm[j] = _;
                } while (false);
            }
            for (i = 0; i <= nr_fold; i++) fold_start[i] = i * l / nr_fold;
        }
        for (i = 0; i < nr_fold; i++) {
            int begin = fold_start[i];
            int end = fold_start[i + 1];
            int j, k;
            svm_problem subprob = new svm_problem();
            subprob.l = l - (end - begin);
            subprob.x = new svm_node[subprob.l][];
            subprob.y = new double[subprob.l];
            k = 0;
            for (j = 0; j < begin; j++) {
                subprob.x[k] = prob.x[perm[j]];
                subprob.y[k] = prob.y[perm[j]];
                ++k;
            }
            for (j = end; j < l; j++) {
                subprob.x[k] = prob.x[perm[j]];
                subprob.y[k] = prob.y[perm[j]];
                ++k;
            }
            svm_model submodel = svm_train(subprob, param);
            if (param.probability == 1 && (param.svm_type == svm_parameter.C_SVC || param.svm_type == svm_parameter.NU_SVC)) {
                double[] prob_estimates = new double[svm_get_nr_class(submodel)];
                for (j = begin; j < end; j++) target[perm[j]] = svm_predict_probability(submodel, prob.x[perm[j]], prob_estimates);
            } else for (j = begin; j < end; j++) target[perm[j]] = svm_predict(submodel, prob.x[perm[j]]);
        }
    }
",0
15064,13,"    private int[] randomiseCars(int n) {
        int[] cars = new int[n];
        for (int i = 0; i < n; i++) cars[i] = i;
        Random r = new Random();
        for (int i = 0; i < n; i++) {
            int j = i + r.nextInt(n - i);
            int tmp = cars[i];
            cars[i] = cars[j];
            cars[j] = tmp;
        }
        return cars;
    }
",1
6938966,13,"    public static void shuffleArray(int[] a) {
        int n = a.length;
        Random random = new Random();
        random.nextInt();
        for (int i = 0; i < n; i++) {
            int change = i + random.nextInt(n - i);
            swap(a, i, change);
        }
    }
",1
16380022,13,"    public void shuffle(Random rand) {
        for (int i = cards.length - 1; i >= 0; i--) {
            int r = rand.nextInt(i + 1);
            Card t = cards[i];
            cards[i] = cards[r];
            cards[r] = t;
        }
        nextCard = 0;
    }
",1
19654780,13,"    public static void shuffle(int[] a) {
        Random random = new Random();
        for (int i = a.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            int swap = a[i];
            a[i] = a[j];
            a[j] = swap;
        }
    }
",1
1721214,13,"    public boolean shufflePatterns() {
        this.checker.init(""shufflePatterns"");
        this.checker.addCheck(this.patterns != null, ""The pattern list is a null pointer."");
        this.checker.addCheck(this.patterns.size() > 0, ""The pattern list is empty."");
        if (this.checker.isSecure()) {
            Random r = new Random();
            int j = 0;
            for (int i = 0; i < this.patterns.size(); i++) {
                j = r.nextInt(i + 1);
                Pattern temp = this.patterns.get(i);
                this.patterns.set(i, this.patterns.get(j));
                this.patterns.set(j, temp);
            }
            return true;
        }
        return false;
    }
",1
3596849,13,"    private static void solve_l1r_l2_svc(Problem prob_col, double[] w, double eps, double Cp, double Cn) {
        int l = prob_col.l;
        int w_size = prob_col.n;
        int j, s, iter = 0;
        int max_iter = 1000;
        int active_size = w_size;
        int max_num_linesearch = 20;
        double sigma = 0.01;
        double d, G_loss, G, H;
        double Gmax_old = Double.POSITIVE_INFINITY;
        double Gmax_new;
        double Gmax_init = 0;
        double d_old, d_diff;
        double loss_old = 0;
        double loss_new;
        double appxcond, cond;
        int[] index = new int[w_size];
        byte[] y = new byte[l];
        double[] b = new double[l];
        double[] xj_sq = new double[w_size];
        double[] C = new double[] { Cn, 0, Cp };
        for (j = 0; j < l; j++) {
            b[j] = 1;
            if (prob_col.y[j] > 0) y[j] = 1; else y[j] = -1;
        }
        for (j = 0; j < w_size; j++) {
            w[j] = 0;
            index[j] = j;
            xj_sq[j] = 0;
            for (FeatureNode xi : prob_col.x[j]) {
                int ind = xi.index - 1;
                double val = xi.value;
                xi.value *= y[ind];
                xj_sq[j] += C[GETI(y, ind)] * val * val;
            }
        }
        while (iter < max_iter) {
            Gmax_new = 0;
            for (j = 0; j < active_size; j++) {
                int i = j + random.nextInt(active_size - j);
                swap(index, i, j);
            }
            for (s = 0; s < active_size; s++) {
                j = index[s];
                G_loss = 0;
                H = 0;
                for (FeatureNode xi : prob_col.x[j]) {
                    int ind = xi.index - 1;
                    if (b[ind] > 0) {
                        double val = xi.value;
                        double tmp = C[GETI(y, ind)] * val;
                        G_loss -= tmp * b[ind];
                        H += tmp * val;
                    }
                }
                G_loss *= 2;
                G = G_loss;
                H *= 2;
                H = Math.max(H, 1e-12);
                double Gp = G + 1;
                double Gn = G - 1;
                double violation = 0;
                if (w[j] == 0) {
                    if (Gp < 0) violation = -Gp; else if (Gn > 0) violation = Gn; else if (Gp > Gmax_old / l && Gn < -Gmax_old / l) {
                        active_size--;
                        swap(index, s, active_size);
                        s--;
                        continue;
                    }
                } else if (w[j] > 0) violation = Math.abs(Gp); else violation = Math.abs(Gn);
                Gmax_new = Math.max(Gmax_new, violation);
                if (Gp <= H * w[j]) d = -Gp / H; else if (Gn >= H * w[j]) d = -Gn / H; else d = -w[j];
                if (Math.abs(d) < 1.0e-12) continue;
                double delta = Math.abs(w[j] + d) - Math.abs(w[j]) + G * d;
                d_old = 0;
                int num_linesearch;
                for (num_linesearch = 0; num_linesearch < max_num_linesearch; num_linesearch++) {
                    d_diff = d_old - d;
                    cond = Math.abs(w[j] + d) - Math.abs(w[j]) - sigma * delta;
                    appxcond = xj_sq[j] * d * d + G_loss * d + cond;
                    if (appxcond <= 0) {
                        for (FeatureNode x : prob_col.x[j]) {
                            b[x.index - 1] += d_diff * x.value;
                        }
                        break;
                    }
                    if (num_linesearch == 0) {
                        loss_old = 0;
                        loss_new = 0;
                        for (FeatureNode x : prob_col.x[j]) {
                            int ind = x.index - 1;
                            if (b[ind] > 0) {
                                loss_old += C[GETI(y, ind)] * b[ind] * b[ind];
                            }
                            double b_new = b[ind] + d_diff * x.value;
                            b[ind] = b_new;
                            if (b_new > 0) {
                                loss_new += C[GETI(y, ind)] * b_new * b_new;
                            }
                        }
                    } else {
                        loss_new = 0;
                        for (FeatureNode x : prob_col.x[j]) {
                            int ind = x.index - 1;
                            double b_new = b[ind] + d_diff * x.value;
                            b[ind] = b_new;
                            if (b_new > 0) {
                                loss_new += C[GETI(y, ind)] * b_new * b_new;
                            }
                        }
                    }
                    cond = cond + loss_new - loss_old;
                    if (cond <= 0) break; else {
                        d_old = d;
                        d *= 0.5;
                        delta *= 0.5;
                    }
                }
                w[j] += d;
                if (num_linesearch >= max_num_linesearch) {
                    info(""#"");
                    for (int i = 0; i < l; i++) b[i] = 1;
                    for (int i = 0; i < w_size; i++) {
                        if (w[i] == 0) continue;
                        for (FeatureNode x : prob_col.x[i]) {
                            b[x.index - 1] -= w[i] * x.value;
                        }
                    }
                }
            }
            if (iter == 0) Gmax_init = Gmax_new;
            iter++;
            if (iter % 10 == 0) info(""."");
            if (Gmax_new <= eps * Gmax_init) {
                if (active_size == w_size) break; else {
                    active_size = w_size;
                    info(""*"");
                    Gmax_old = Double.POSITIVE_INFINITY;
                    continue;
                }
            }
            Gmax_old = Gmax_new;
        }
        info(""%noptimization finished, #iter = %d%n"", iter);
        if (iter >= max_iter) info(""%nWARNING: reaching max number of iterations%n"");
        double v = 0;
        int nnz = 0;
        for (j = 0; j < w_size; j++) {
            for (FeatureNode x : prob_col.x[j]) {
                x.value *= prob_col.y[x.index - 1];
            }
            if (w[j] != 0) {
                v += Math.abs(w[j]);
                nnz++;
            }
        }
        for (j = 0; j < l; j++) if (b[j] > 0) v += C[GETI(y, j)] * b[j] * b[j];
        info(""Objective value = %f%n"", v);
        info(""#nonzeros/#features = %d/%d%n"", nnz, w_size);
    }
",0
3596848,13,"    private static void solve_l2r_lr_dual(Problem prob, double w[], double eps, double Cp, double Cn) {
        int l = prob.l;
        int w_size = prob.n;
        int i, s, iter = 0;
        double xTx[] = new double[l];
        int max_iter = 1000;
        int index[] = new int[l];
        double alpha[] = new double[2 * l];
        byte y[] = new byte[l];
        int max_inner_iter = 100;
        double innereps = 1e-2;
        double innereps_min = Math.min(1e-8, eps);
        double upper_bound[] = new double[] { Cn, 0, Cp };
        for (i = 0; i < w_size; i++) w[i] = 0;
        for (i = 0; i < l; i++) {
            if (prob.y[i] > 0) {
                y[i] = +1;
            } else {
                y[i] = -1;
            }
            alpha[2 * i] = Math.min(0.001 * upper_bound[GETI(y, i)], 1e-8);
            alpha[2 * i + 1] = upper_bound[GETI(y, i)] - alpha[2 * i];
            xTx[i] = 0;
            for (FeatureNode xi : prob.x[i]) {
                xTx[i] += (xi.value) * (xi.value);
                w[xi.index - 1] += y[i] * alpha[2 * i] * xi.value;
            }
            index[i] = i;
        }
        while (iter < max_iter) {
            for (i = 0; i < l; i++) {
                int j = i + random.nextInt(l - i);
                swap(index, i, j);
            }
            int newton_iter = 0;
            double Gmax = 0;
            for (s = 0; s < l; s++) {
                i = index[s];
                byte yi = y[i];
                double C = upper_bound[GETI(y, i)];
                double ywTx = 0, xisq = xTx[i];
                for (FeatureNode xi : prob.x[i]) {
                    ywTx += w[xi.index - 1] * xi.value;
                }
                ywTx *= y[i];
                double a = xisq, b = ywTx;
                int ind1 = 2 * i, ind2 = 2 * i + 1, sign = 1;
                if (0.5 * a * (alpha[ind2] - alpha[ind1]) + b < 0) {
                    ind1 = 2 * i + 1;
                    ind2 = 2 * i;
                    sign = -1;
                }
                double alpha_old = alpha[ind1];
                double z = alpha_old;
                if (C - z < 0.5 * C) z = 0.1 * z;
                double gp = a * (z - alpha_old) + sign * b + Math.log(z / (C - z));
                Gmax = Math.max(Gmax, Math.abs(gp));
                final double eta = 0.1;
                int inner_iter = 0;
                while (inner_iter <= max_inner_iter) {
                    if (Math.abs(gp) < innereps) break;
                    double gpp = a + C / (C - z) / z;
                    double tmpz = z - gp / gpp;
                    if (tmpz <= 0) z *= eta; else z = tmpz;
                    gp = a * (z - alpha_old) + sign * b + Math.log(z / (C - z));
                    newton_iter++;
                    inner_iter++;
                }
                if (inner_iter > 0) {
                    alpha[ind1] = z;
                    alpha[ind2] = C - z;
                    for (FeatureNode xi : prob.x[i]) {
                        w[xi.index - 1] += sign * (z - alpha_old) * yi * xi.value;
                    }
                }
            }
            iter++;
            if (iter % 10 == 0) info(""."");
            if (Gmax < eps) break;
            if (newton_iter < l / 10) innereps = Math.max(innereps_min, 0.1 * innereps);
        }
        info(""%noptimization finished, #iter = %d%n"", iter);
        if (iter >= max_iter) info(""%nWARNING: reaching max number of iterations%nUsing -s 0 may be faster (also see FAQ)%n%n"");
        double v = 0;
        for (i = 0; i < w_size; i++) v += w[i] * w[i];
        v *= 0.5;
        for (i = 0; i < l; i++) v += alpha[2 * i] * Math.log(alpha[2 * i]) + alpha[2 * i + 1] * Math.log(alpha[2 * i + 1]) - upper_bound[GETI(y, i)] * Math.log(upper_bound[GETI(y, i)]);
        info(""Objective value = %f%n"", v);
    }
",0
3596828,13,"    public static void crossValidation(Problem prob, Parameter param, int nr_fold, int[] target) {
        int i;
        int[] fold_start = new int[nr_fold + 1];
        int l = prob.l;
        int[] perm = new int[l];
        for (i = 0; i < l; i++) perm[i] = i;
        for (i = 0; i < l; i++) {
            int j = i + random.nextInt(l - i);
            swap(perm, i, j);
        }
        for (i = 0; i <= nr_fold; i++) fold_start[i] = i * l / nr_fold;
        for (i = 0; i < nr_fold; i++) {
            int begin = fold_start[i];
            int end = fold_start[i + 1];
            int j, k;
            Problem subprob = new Problem();
            subprob.bias = prob.bias;
            subprob.n = prob.n;
            subprob.l = l - (end - begin);
            subprob.x = new FeatureNode[subprob.l][];
            subprob.y = new int[subprob.l];
            k = 0;
            for (j = 0; j < begin; j++) {
                subprob.x[k] = prob.x[perm[j]];
                subprob.y[k] = prob.y[perm[j]];
                ++k;
            }
            for (j = end; j < l; j++) {
                subprob.x[k] = prob.x[perm[j]];
                subprob.y[k] = prob.y[perm[j]];
                ++k;
            }
            Model submodel = train(subprob, param);
            for (j = begin; j < end; j++) target[perm[j]] = predict(submodel, prob.x[perm[j]]);
        }
    }
",1
17621071,13,"    public static synchronized void shuffle(float[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            float temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
",1
7436917,13,"    public IntChoiceFromSet randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            String tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
",1
10868405,13,"    public void shuffle() {
        Random rng = new Random();
        int n = this.cards.size();
        while (--n > 0) {
            int k = rng.nextInt(n + 1);
            Card temp = this.cards.get(n);
            this.cards.set(n, this.cards.get(k));
            this.cards.set(k, temp);
        }
    }
",1
17510245,13,"    void permute(int[] a, int n) {
        for (int i = 0; i < n; i++) {
            int j = random.nextInt(i + 1);
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }
",1
19654782,13,"    public static void shuffle(long[] a) {
        Random random = new Random();
        for (int i = a.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            long swap = a[i];
            a[i] = a[j];
            a[j] = swap;
        }
    }
",1
7839340,13,"    public static void shuffle(int[] array, Random rng) {
        for (int i = array.length - 1; i >= 0; i--) {
            int index = rng.nextInt(i + 1);
            int a = array[index];
            array[index] = array[i];
            array[i] = a;
        }
    }
",1
2315719,13,"    public TypedObjectChoice randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            int tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
",1
13912756,13,"    public RandomOrderIntCG(IntChoiceGenerator sub) {
        super(sub.id);
        setPreviousChoiceGenerator(sub.getPreviousChoiceGenerator());
        choices = new int[sub.getTotalNumberOfChoices()];
        for (int i = 0; i < choices.length; i++) {
            sub.advance();
            choices[i] = sub.getNextChoice();
        }
        for (int i = choices.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            int tmp = choices[i];
            choices[i] = choices[j];
            choices[j] = tmp;
        }
        nextIdx = -1;
    }
",1
7200130,13,"    public static void shuffle(int[] a, Random rand) {
        for (int i = a.length - 1; i >= 1; i--) {
            int j = rand.nextInt(i + 1);
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
        }
    }
",1
5936119,13,"    public boolean batchFinished() throws Exception {
        Instances data = getInputFormat();
        if (data == null) throw new IllegalStateException(""No input instance format defined"");
        if (m_Converter == null) {
            int[] randomIndices = new int[m_ClassCounts.length];
            for (int i = 0; i < randomIndices.length; i++) {
                randomIndices[i] = i;
            }
            for (int j = randomIndices.length - 1; j > 0; j--) {
                int toSwap = m_Random.nextInt(j + 1);
                int tmpIndex = randomIndices[j];
                randomIndices[j] = randomIndices[toSwap];
                randomIndices[toSwap] = tmpIndex;
            }
            double[] randomizedCounts = new double[m_ClassCounts.length];
            for (int i = 0; i < randomizedCounts.length; i++) {
                randomizedCounts[i] = m_ClassCounts[randomIndices[i]];
            }
            if (m_ClassOrder == RANDOM) {
                m_Converter = randomIndices;
                m_ClassCounts = randomizedCounts;
            } else {
                int[] sorted = Utils.sort(randomizedCounts);
                m_Converter = new int[sorted.length];
                if (m_ClassOrder == FREQ_ASCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[i]];
                    }
                } else if (m_ClassOrder == FREQ_DESCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[sorted.length - i - 1]];
                    }
                } else {
                    throw new IllegalArgumentException(""Class order not defined!"");
                }
                double[] tmp2 = new double[m_ClassCounts.length];
                for (int i = 0; i < m_Converter.length; i++) {
                    tmp2[i] = m_ClassCounts[m_Converter[i]];
                }
                m_ClassCounts = tmp2;
            }
            FastVector values = new FastVector(data.classAttribute().numValues());
            for (int i = 0; i < data.numClasses(); i++) {
                values.addElement(data.classAttribute().value(m_Converter[i]));
            }
            FastVector newVec = new FastVector(data.numAttributes());
            for (int i = 0; i < data.numAttributes(); i++) {
                if (i == data.classIndex()) {
                    newVec.addElement(new Attribute(data.classAttribute().name(), values, data.classAttribute().getMetadata()));
                } else {
                    newVec.addElement(data.attribute(i));
                }
            }
            Instances newInsts = new Instances(data.relationName(), newVec, 0);
            newInsts.setClassIndex(data.classIndex());
            setOutputFormat(newInsts);
            int[] temp = new int[m_Converter.length];
            for (int i = 0; i < temp.length; i++) {
                temp[m_Converter[i]] = i;
            }
            m_Converter = temp;
            for (int xyz = 0; xyz < data.numInstances(); xyz++) {
                Instance datum = data.instance(xyz);
                if (!datum.isMissing(datum.classIndex())) {
                    datum.setClassValue((float) m_Converter[(int) datum.classValue()]);
                }
                push(datum);
            }
        }
        flushInput();
        m_NewBatch = true;
        return (numPendingOutput() != 0);
    }
",1
2451218,13,"    public TaggedDoubleChoiceFromSet randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            double tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
",1
7357528,13,"    private ArrayList<Move> shuffle(ArrayList<Move> list) {
        Random random = new Random();
        for (int index = (list.size() - 1); index > 0; index--) {
            int other = random.nextInt(index + 1);
            Move temp = list.get(other);
            list.set(other, list.get(index));
            list.set(index, temp);
        }
        return list;
    }
",1
7839341,13,"    public static void shuffle(Object[] array, Random rng) {
        for (int i = array.length - 1; i >= 0; i--) {
            int index = rng.nextInt(i + 1);
            Object a = array[index];
            array[index] = array[i];
            array[i] = a;
        }
    }
",1
5226973,13,"    void shuffle() {
        Random random = new Random();
        for (int i = cards.size() - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            Card c = cards.get(j);
            cards.set(j, cards.get(i));
            cards.set(i, c);
        }
    }
",1
11205237,13,"    public ChoiceGenerator randomize() {
        for (int i = values.size() - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            SCEvent tmp = values.get(i);
            values.set(i, values.get(j));
            values.set(j, tmp);
        }
        return this;
    }
",0
13088707,13,"    public static void shuffle(int[] array, int n) {
        for (int i = 1; i < n; ++i) {
            int swap = s_random.nextInt(i + 1);
            int temp = array[swap];
            array[swap] = array[i];
            array[i] = temp;
        }
    }
",1
13088706,13,"    public static void shuffle(Object[] array) {
        int n = array.length;
        Object temp;
        for (int i = 1; i < n; ++i) {
            int swap = s_random.nextInt(i + 1);
            temp = array[swap];
            array[swap] = array[i];
            array[i] = temp;
        }
    }
",1
17621072,13,"    public static synchronized void shuffle(char[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            char temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
",1
1313371,13,"    public static int[] permute(int N, Random rand) {
        int[] a = new int[N];
        for (int i = 0; i < N; i++) a[i] = i;
        for (int i = 0; i < N; i++) {
            int r = rand.nextInt(i + 1);
            int swap = a[r];
            a[r] = a[i];
            a[i] = swap;
        }
        return a;
    }
",1
17621070,13,"    public static synchronized void shuffle(double[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            double temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
",1
20328639,13,"    public static final void shuffle(boolean[] list) {
        for (int i = list.length - 1; i >= 0; i--) {
            int j = rand.nextInt(i + 1);
            if (i == j) {
                continue;
            }
            boolean tmp = list[i];
            list[i] = list[j];
            list[j] = tmp;
        }
    }
",1
19119522,13,"    private void generateShuffleOrder() {
        if (mShuffleOrder == null || mShuffleOrder.length != mAllImages.getCount()) {
            mShuffleOrder = new int[mAllImages.getCount()];
            for (int i = 0, n = mShuffleOrder.length; i < n; i++) {
                mShuffleOrder[i] = i;
            }
        }
        for (int i = mShuffleOrder.length - 1; i >= 0; i--) {
            int r = mRandom.nextInt(i + 1);
            if (r != i) {
                int tmp = mShuffleOrder[r];
                mShuffleOrder[r] = mShuffleOrder[i];
                mShuffleOrder[i] = tmp;
            }
        }
    }
",1
17621069,13,"    public static synchronized void shuffle(int[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            int temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
",1
10258420,13,"    private short[] geraConfInicial(int n, short[] array) {
        int swap;
        short aux;
        Random random = new Random();
        for (int pos = n - 1; pos > 0; --pos) {
            swap = random.nextInt(pos + 1);
            aux = array[pos];
            array[pos] = array[swap];
            array[swap] = aux;
        }
        return array;
    }
",1
19076717,13,"    @SuppressWarnings(""unused"")
    public static void main(String[] args) {
        int angleCount = 10800;
        float[] angles = new float[angleCount];
        float[] sinerror = new float[angleCount];
        float[] coserror = new float[angleCount];
        float[] atanerror = new float[angleCount];
        for (int i = 0; i < angleCount; i++) {
            float angle = (float) (Math.PI * 2 * i / angleCount);
            angles[i] = angle;
            float rs = (float) Math.sin(angle);
            float ls = sin(angle);
            sinerror[i] = Math.abs(rs - ls);
            float rc = (float) Math.cos(angle);
            float lc = cos(angle);
            coserror[i] = Math.abs(rc - lc);
            float ratan = (float) Math.atan2(100 * rs, 100 * rc);
            float latan = atan2(100 * rs, 100 * rc);
            atanerror[i] = MathUtils.angleDiff(ratan, latan);
        }
        float maxSin = -1, minSin = Float.MAX_VALUE, meanSin = 0;
        float maxCos = -1, minCos = Float.MAX_VALUE, meanCos = 0;
        float maxAtan = -1, minAtan = Float.MAX_VALUE, meanAtan = 0;
        for (int i = 0; i < angleCount; i++) {
            maxSin = Math.max(maxSin, sinerror[i]);
            minSin = Math.min(minSin, sinerror[i]);
            maxCos = Math.max(maxCos, coserror[i]);
            minCos = Math.min(minCos, coserror[i]);
            maxAtan = Math.max(maxAtan, atanerror[i]);
            minAtan = Math.min(minAtan, atanerror[i]);
            meanSin += sinerror[i];
            meanCos += coserror[i];
            meanAtan += atanerror[i];
        }
        meanSin /= angleCount;
        meanCos /= angleCount;
        meanAtan /= angleCount;
        System.out.println(""Accuracy:"");
        System.out.println(""sin/cos table size = "" + sin.length);
        System.out.println(""Sin\tmin\t\tmax\t\tmean"");
        System.out.println(""\t"" + minSin + ""\t"" + maxSin + ""\t"" + meanSin);
        System.out.println(""Cos\tmin\t\tmax\t\tmean"");
        System.out.println(""\t"" + minCos + ""\t"" + maxCos + ""\t"" + meanCos);
        System.out.println(""atan2 table size = "" + atan2.length);
        System.out.println(""Atan2\tmin\t\tmax\t\tmean (in degrees)"");
        System.out.println(""\t"" + Math.toDegrees(minAtan) + ""\t"" + Math.toDegrees(maxAtan) + ""\t"" + Math.toDegrees(meanAtan));
        System.out.println(""Performance:"");
        Random rng = new Random();
        for (int i = angles.length - 1; i >= 0; i--) {
            int index = rng.nextInt(i + 1);
            float a = angles[index];
            angles[index] = angles[i];
            angles[i] = a;
        }
        System.out.println(""testing"");
        int tests = (int) 2E7;
        for (int i = 0; i < 10; i++) {
            long t = System.currentTimeMillis();
            float jm = testMathSin(tests, angles);
            long duration = System.currentTimeMillis() - t;
            double jp = (double) tests / duration;
            t = System.currentTimeMillis();
            float fm = testFastSin(tests, angles);
            duration = System.currentTimeMillis() - t;
            double fp = (double) tests / duration;
            System.out.println(""Fast sin is "" + fp / jp + "" times faster than java sin"");
        }
        float[] coords = new float[100];
        float r = 100;
        for (int i = 0; i < coords.length; i++) {
            coords[i] = rng.nextFloat() * 2 * r - r;
        }
        for (int i = 0; i < 10; i++) {
            long t = System.currentTimeMillis();
            float jm = testMathAtan(tests, coords);
            long duration = System.currentTimeMillis() - t;
            double jp = (double) tests / duration;
            t = System.currentTimeMillis();
            float fm = testFastAtan(tests, coords);
            duration = System.currentTimeMillis() - t;
            double fp = (double) tests / duration;
            System.out.println(""Fast atan is "" + fp / jp + "" times faster than java atan"");
        }
    }
",1
22181822,13,"    public int[] shuffle(int[] d) {
        int n = d.length;
        int[] res = new int[n];
        System.arraycopy(d, 0, res, 0, n);
        for (int i = 0; i < n; i++) {
            int p = i + random.nextInt(n - i);
            int q = res[p];
            res[p] = res[i];
            res[i] = q;
        }
        return (res);
    }
",0
4490317,13,"    public static void randomize(int[] arr, int start, int end) {
        for (int i = end; i > 1 + start; i--) {
            int rnd_index = start + rnd.nextInt(i - start);
            int tmp = arr[i - 1];
            arr[i - 1] = arr[rnd_index];
            arr[rnd_index] = tmp;
        }
    }
",1
19654783,13,"    public static <T> void shuffle(T[] a) {
        Random random = new Random();
        for (int i = a.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            T swap = a[i];
            a[i] = a[j];
            a[j] = swap;
        }
    }
",0
8586224,13,"    protected void permute(int v[], Random random) {
        for (int i = v.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            if (i != j) {
                int tmp = v[i];
                v[i] = v[j];
                v[j] = tmp;
            }
        }
    }
",1
22648484,13,"    public ChoiceGenerator randomize() {
        for (int i = values.size() - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            UIAction tmp = values.get(i);
            values.set(i, values.get(j));
            values.set(j, tmp);
        }
        return this;
    }
",0
20328640,13,"    public static final void shuffle(Object[] list) {
        for (int i = list.length - 1; i >= 0; i--) {
            int j = rand.nextInt(i + 1);
            if (i == j) {
                continue;
            }
            Object tmp = list[i];
            list[i] = list[j];
            list[j] = tmp;
        }
    }
",1
13160464,13,"    public void shuffle() {
        currentDeckPosition = 0;
        int n = 52;
        while (--n > 0) {
            int k = rand.nextInt(n + 1);
            int temp = deck[n];
            deck[n] = deck[k];
            deck[k] = temp;
        }
    }
",0
20740028,13,"    public static String computeSignature(List words) {
        if (words.size() == 0) return ""(empty word list)"";
        readCaches();
        firstNew = true;
        int len = words.size() + 1;
        String[] word = new String[len];
        words.toArray(word);
        word[len - 1] = String.valueOf((char) 0xffff);
        Arrays.sort(word);
        List list = new ArrayList();
        String prev = word[0];
        int c = 0;
        for (int i = 0, imax = len; i < imax; i++) {
            String w = word[i];
            if (w.equals(prev)) c++; else {
                int freq = getFreq(prev);
                if (freq < Integer.MAX_VALUE) list.add(new WordFreq(prev, c, freq));
                prev = w;
                c = 1;
            }
        }
        if (list.size() == 0) return ""(no valid words)"";
        WordFreq[] bogus = new WordFreq[0];
        WordFreq[] wordfreq = (WordFreq[]) list.toArray(bogus);
        int validlen = Math.min(SignatureLength, wordfreq.length);
        if (""tfidf"".equals(Algorithm)) {
            Arrays.sort(wordfreq, new byRelFreq());
        } else if (""rarest"".equals(Algorithm)) {
            Arrays.sort(wordfreq, new byWebFreq());
        } else if (""random"".equals(Algorithm)) {
            Random rand = new Random();
            for (int i = 0, imax = validlen; i < imax; i++) {
                int swapi = rand.nextInt(imax);
                WordFreq tmp = wordfreq[i];
                wordfreq[i] = wordfreq[swapi];
                wordfreq[swapi] = tmp;
            }
        } else if (""random100k"".equals(Algorithm)) {
            Random rand = new Random();
            validlen = 0;
            for (int i = 0, imax = wordfreq.length; i < imax; i++) {
                WordFreq tmp = wordfreq[i];
                if (tmp.webcnt < 100000) {
                    int swapi = rand.nextInt(validlen + 1);
                    wordfreq[i] = wordfreq[validlen];
                    wordfreq[validlen] = wordfreq[swapi];
                    wordfreq[swapi] = tmp;
                    validlen++;
                }
            }
            validlen = Math.min(validlen, SignatureLength);
        } else {
            Arrays.sort(wordfreq, new byRoFreq());
        }
        if (DEBUG) {
            System.out.println(""* Rankings *"");
            for (int i = 0; i < Math.min(25, wordfreq.length); i++) System.out.println(wordfreq[i]);
        }
        StringBuffer sigsb = new StringBuffer(100);
        for (int i = 0, imax = validlen; i < imax; i++) {
            if (i > 0) sigsb.append(' ');
            sigsb.append(wordfreq[i].word);
            if (StudyOut != null) StudyOut.print(wordfreq[i].pagecnt + ""/"" + wordfreq[i].webcnt + "" "");
        }
        if (StudyOut != null) StudyOut.println();
        if (Verbose && newwords.size() > 0) {
            System.out.println();
        }
        writeCache();
        return sigsb.substring(0);
    }
",1
6088697,13,"    private void assertComparatorYieldsOrder(String[] orderedObjects, Comparator<String> comparator) {
        String[] keys = (String[]) orderedObjects.clone();
        boolean isInNewOrder = false;
        while (keys.length > 1 && isInNewOrder == false) {
            shuffle: {
                Random rand = new Random();
                for (int i = keys.length - 1; i > 0; i--) {
                    String swap = keys[i];
                    int j = rand.nextInt(i + 1);
                    keys[i] = keys[j];
                    keys[j] = swap;
                }
            }
            testShuffle: {
                for (int i = 0; i < keys.length && !isInNewOrder; i++) {
                    if (!orderedObjects[i].equals(keys[i])) {
                        isInNewOrder = true;
                    }
                }
            }
        }
        Arrays.sort(keys, comparator);
        for (int i = 0; i < orderedObjects.length; i++) {
            assertEquals(orderedObjects[i], keys[i]);
        }
    }
",1
14009710,13,"    public DoubleThresholdGenerator randomize() {
        for (int i = values.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            double tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        return this;
    }
",0
13140215,13,"    @Override
    public void shuffleInstances() {
        Random random = new Random(seed);
        for (int i = 0; i < userRecords.length; i++) {
            for (int j = userRecords[i].length - 1; j > 0; j--) {
                Rating r = userRecords[i][j];
                int k = random.nextInt(j + 1);
                userRecords[i][j] = userRecords[i][k];
                userRecords[i][k] = r;
            }
        }
    }
",0
17467511,13,"    public static final void randomShuffle(int[] v, Random r) {
        int n = v.length;
        while (--n > 0) {
            int k = r.nextInt(n + 1);
            int temp = v[n];
            v[n] = v[k];
            v[k] = temp;
        }
    }
",1
17621073,13,"    public static synchronized void shuffle(byte[] anArray) {
        int n = anArray.length;
        for (int i = n - 1; i >= 1; i--) {
            int j = randomSource.nextInt(i + 1);
            byte temp = anArray[j];
            anArray[j] = anArray[i];
            anArray[i] = temp;
        }
    }
",1
23677156,13,"	public static void shuffle2(int[] a) {
		//Alternate Fisher-Yates/Knuth Shuffle
		Random random = new Random();
		random.nextInt();
		
		for(int i = a.length-1; i >= 1; i--) {
			//Choose index to swap from 0 <= j <= i
			int j = random.nextInt(i+1);
			
			//Swap
			int tmp = a[i];
			a[i] = a[j];
			a[j] = tmp;
		}
	}
",1
531920,44,"    public static boolean isPalindrome(String numberString) {
        if (numberString.length() % 2 == 0) {
            String firstHalf = numberString.substring(0, numberString.length() / 2);
            String secondHalf = numberString.substring(numberString.length() / 2);
            String secondHalfReverse = (new StringBuffer(secondHalf)).reverse().toString();
            return firstHalf.equals(secondHalfReverse);
        }
        return false;
    }
",1
8972522,44,"    public static boolean isPalindrome(String stringToTest) {
        String workingCopyString = removeJunk(stringToTest);
        String reversedCopyString = reverse(stringToTest);
        return reversedCopyString.equalsIgnoreCase(workingCopyString);
    }
",0
22060129,44,"    public static boolean isPalindrome(String string) {
        int limit = string.length() / 2;
        if (limit == 0) {
            return true;
        }
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++, backward--) {
            if (string.charAt(forward) != string.charAt(backward)) {
                return false;
            }
        }
        return true;
    }
",1
103828,44,"    public static boolean isPalindrome(String word) {
        int left = 0;
        int right = word.length() - 1;
        while (left < right) {
            if (word.charAt(left) != word.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
",1
16152856,44,"    private static final boolean isPalindrome(final String s) {
        String opposite = """";
        for (int i = s.length() - 1; i >= 0; i--) opposite = opposite + s.charAt(i);
        return s.equals(opposite);
    }
",1
4758170,44,"    public static boolean test(String possiblePalindrome) {
        int endOfFirstHalf;
        int startOfSecondHalf;
        if (possiblePalindrome.length() % 2 == 0) {
            endOfFirstHalf = possiblePalindrome.length() / 2;
            startOfSecondHalf = endOfFirstHalf + 1;
        } else {
            endOfFirstHalf = possiblePalindrome.length() / 2;
            startOfSecondHalf = endOfFirstHalf + 2;
        }
        String first = possiblePalindrome.substring(0, endOfFirstHalf);
        String second = possiblePalindrome.substring(startOfSecondHalf - 1);
        return first.equals(reverse(second));
    }
",1
4328782,44,"    public static boolean isPalindrome(String string) {
        if (string.length() == 0) return true;
        int limit = string.length() / 2;
        for (int forward = 0, backward = string.length() - 1; forward < limit; forward++) if (string.charAt(forward) != string.charAt(backward)) return false;
        return true;
    }
",1
950313,44,"    private static boolean checkPalindrome(String string) {
        int length = string.length() / 2;
        int fullLength = string.length();
        for (int k = 0; k < length; k++) {
            if (string.charAt(k) != string.charAt(fullLength - 1 - k)) return false;
        }
        return true;
    }
",1
9755674,44,"    private boolean isPalindrome(String w) {
        for (int i = 0; i < w.length() / 2; i++) {
            if (w.charAt(i) != w.charAt(w.length() - 1 - i)) {
                return false;
            }
        }
        return true;
    }
",0
590962,44,"    private static boolean isPalindrome(String string) {
        for (int k = 0; k < string.length() / 2; k++) {
            if (string.charAt(k) != string.charAt(string.length() - (k + 1))) return false;
        }
        return true;
    }
",1
23355904,44,"    public static boolean checkPalindrome(String string) {
        if (string == null) {
            return false;
        }
        String reverse = new StringBuilder(string).reverse().toString();
        if (string.equals(reverse)) {
            return true;
        }
        return false;
    }
",1
10067403,44,"    private boolean isPalindrome(int i) {
        String s = String.valueOf(i);
        return s.equals(StringUtils.reverse(s));
    }
",1
3868943,44,"    public static boolean isPalindrome(String word) {
        boolean result = false;
        if (word.length() <= 1) result = true; else if (word.charAt(0) == word.charAt(word.length() - 1)) result = isPalindrome(word.substring(1, word.length() - 1));
        return result;
    }
",1
4128381,44,"    public boolean isPalindrome(String s) {
        return new StringBuilder(s).reverse().toString().equals(s);
    }
",1
426940,44,"    public static boolean isPalindrome(String str) {
        int begin = 0;
        int end = str.length() - 1;
        if (str == null) return false;
        while (begin < (int) (str.length() / 2)) {
            if (str.charAt(begin) != str.charAt(end)) return false; else {
                begin++;
                end--;
            }
        }
        return true;
    }
",1
136941,44,"    private static boolean isPalindrome(String sub) {
        int length = sub.length() / 2;
        for (int k = 0; k < length; k++) {
            if (sub.charAt(k) != sub.charAt(sub.length() - k - 1)) return false;
        }
        return true;
    }
",1
13839383,44,"    private boolean isPalindrome(int[] m) {
        for (int i = 0; i < m.length / 2; i++) {
            if (m[i] != m[m.length - 1 - i]) {
                return false;
            }
        }
        return true;
    }
",1
9524753,7,"    private void doMoveDown() {
        int which = curveList.getSelectedIndex();
        ObjectInfo swap1 = curve[which];
        curve[which] = curve[which + 1];
        curve[which + 1] = swap1;
        boolean swap2 = reverse[which];
        reverse[which] = reverse[which + 1];
        reverse[which + 1] = swap2;
        Object swap3 = curveList.getItem(which);
        curveList.remove(which);
        curveList.add(which + 1, swap3);
        curveList.setSelected(which + 1, true);
        makeObject();
        updateComponents();
    }
",1
19956071,7,"    public static byte[] getUTF16PrepairedBytes(byte[] data, int offset, int length) {
        if (data == null) return null;
        byte[] buffer = ByteReader.getBytes(data, offset, length);
        byte swapElement;
        if (buffer == null) return null;
        assert ((buffer.length & 1) == 0);
        for (int i = 0; i < buffer.length; i += 2) {
            swapElement = buffer[i];
            buffer[i] = buffer[i + 1];
            buffer[i + 1] = swapElement;
        }
        return buffer;
    }
",1
19546,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
1984915,7,"    public synchronized Raster getTile(int tileX, int tileY) {
        if ((tileX < 0) || (tileX >= tilesX) || (tileY < 0) || (tileY >= tilesY)) {
            throw new IllegalArgumentException(""TIFFImage12"");
        }
        byte bdata[] = null;
        short sdata[] = null;
        int idata[] = null;
        SampleModel sampleModel = getSampleModel();
        WritableRaster tile = makeTile(tileX, tileY);
        DataBuffer buffer = tile.getDataBuffer();
        int dataType = sampleModel.getDataType();
        if (dataType == DataBuffer.TYPE_BYTE) {
            bdata = ((DataBufferByte) buffer).getData();
        } else if (dataType == DataBuffer.TYPE_USHORT) {
            sdata = ((DataBufferUShort) buffer).getData();
        } else if (dataType == DataBuffer.TYPE_SHORT) {
            sdata = ((DataBufferShort) buffer).getData();
        } else if (dataType == DataBuffer.TYPE_INT) {
            idata = ((DataBufferInt) buffer).getData();
        }
        byte bswap;
        short sswap;
        int iswap;
        long save_offset = 0;
        try {
            save_offset = stream.getFilePointer();
            stream.seek(tileOffsets[tileY * tilesX + tileX]);
        } catch (IOException ioe) {
            throw new RuntimeException(""TIFFImage13"");
        }
        int byteCount = (int) tileByteCounts[tileY * tilesX + tileX];
        Rectangle newRect;
        if (!tiled) newRect = tile.getBounds(); else newRect = new Rectangle(tile.getMinX(), tile.getMinY(), tileWidth, tileHeight);
        int unitsInThisTile = newRect.width * newRect.height * numBands;
        byte data[] = compression != COMP_NONE || imageType == TYPE_PALETTE ? new byte[byteCount] : null;
        if (imageType == TYPE_BILEVEL) {
            try {
                if (compression == COMP_PACKBITS) {
                    stream.readFully(data, 0, byteCount);
                    int bytesInThisTile;
                    if ((newRect.width % 8) == 0) {
                        bytesInThisTile = (newRect.width / 8) * newRect.height;
                    } else {
                        bytesInThisTile = (newRect.width / 8 + 1) * newRect.height;
                    }
                    decodePackbits(data, bytesInThisTile, bdata);
                } else if (compression == COMP_LZW) {
                    stream.readFully(data, 0, byteCount);
                    lzwDecoder.decode(data, bdata, newRect.height);
                } else if (compression == COMP_FAX_G3_1D) {
                    stream.readFully(data, 0, byteCount);
                    decoder.decode1D(bdata, data, 0, newRect.height);
                } else if (compression == COMP_FAX_G3_2D) {
                    stream.readFully(data, 0, byteCount);
                    decoder.decode2D(bdata, data, 0, newRect.height, tiffT4Options);
                } else if (compression == COMP_FAX_G4_2D) {
                    stream.readFully(data, 0, byteCount);
                    decoder.decodeT6(bdata, data, 0, newRect.height, tiffT6Options);
                } else if (compression == COMP_DEFLATE) {
                    stream.readFully(data, 0, byteCount);
                    inflate(data, bdata);
                } else if (compression == COMP_NONE) {
                    stream.readFully(bdata, 0, byteCount);
                }
                stream.seek(save_offset);
            } catch (IOException ioe) {
                throw new RuntimeException(""TIFFImage13"");
            }
        } else if (imageType == TYPE_PALETTE) {
            if (sampleSize == 16) {
                if (decodePaletteAsShorts) {
                    short tempData[] = null;
                    int unitsBeforeLookup = unitsInThisTile / 3;
                    int entries = unitsBeforeLookup * 2;
                    try {
                        if (compression == COMP_PACKBITS) {
                            stream.readFully(data, 0, byteCount);
                            byte byteArray[] = new byte[entries];
                            decodePackbits(data, entries, byteArray);
                            tempData = new short[unitsBeforeLookup];
                            interpretBytesAsShorts(byteArray, tempData, unitsBeforeLookup);
                        } else if (compression == COMP_LZW) {
                            stream.readFully(data, 0, byteCount);
                            byte byteArray[] = new byte[entries];
                            lzwDecoder.decode(data, byteArray, newRect.height);
                            tempData = new short[unitsBeforeLookup];
                            interpretBytesAsShorts(byteArray, tempData, unitsBeforeLookup);
                        } else if (compression == COMP_DEFLATE) {
                            stream.readFully(data, 0, byteCount);
                            byte byteArray[] = new byte[entries];
                            inflate(data, byteArray);
                            tempData = new short[unitsBeforeLookup];
                            interpretBytesAsShorts(byteArray, tempData, unitsBeforeLookup);
                        } else if (compression == COMP_NONE) {
                            tempData = new short[byteCount / 2];
                            readShorts(byteCount / 2, tempData);
                        }
                        stream.seek(save_offset);
                    } catch (IOException ioe) {
                        throw new RuntimeException(""TIFFImage13"");
                    }
                    if (dataType == DataBuffer.TYPE_USHORT) {
                        int cmapValue;
                        int count = 0, lookup, len = colormap.length / 3;
                        int len2 = len * 2;
                        for (int i = 0; i < unitsBeforeLookup; i++) {
                            lookup = tempData[i] & 0xffff;
                            cmapValue = colormap[lookup + len2];
                            sdata[count++] = (short) (cmapValue & 0xffff);
                            cmapValue = colormap[lookup + len];
                            sdata[count++] = (short) (cmapValue & 0xffff);
                            cmapValue = colormap[lookup];
                            sdata[count++] = (short) (cmapValue & 0xffff);
                        }
                    } else if (dataType == DataBuffer.TYPE_SHORT) {
                        int cmapValue;
                        int count = 0, lookup, len = colormap.length / 3;
                        int len2 = len * 2;
                        for (int i = 0; i < unitsBeforeLookup; i++) {
                            lookup = tempData[i] & 0xffff;
                            cmapValue = colormap[lookup + len2];
                            sdata[count++] = (short) cmapValue;
                            cmapValue = colormap[lookup + len];
                            sdata[count++] = (short) cmapValue;
                            cmapValue = colormap[lookup];
                            sdata[count++] = (short) cmapValue;
                        }
                    }
                } else {
                    try {
                        if (compression == COMP_PACKBITS) {
                            stream.readFully(data, 0, byteCount);
                            int bytesInThisTile = unitsInThisTile * 2;
                            byte byteArray[] = new byte[bytesInThisTile];
                            decodePackbits(data, bytesInThisTile, byteArray);
                            interpretBytesAsShorts(byteArray, sdata, unitsInThisTile);
                        } else if (compression == COMP_LZW) {
                            stream.readFully(data, 0, byteCount);
                            byte byteArray[] = new byte[unitsInThisTile * 2];
                            lzwDecoder.decode(data, byteArray, newRect.height);
                            interpretBytesAsShorts(byteArray, sdata, unitsInThisTile);
                        } else if (compression == COMP_DEFLATE) {
                            stream.readFully(data, 0, byteCount);
                            byte byteArray[] = new byte[unitsInThisTile * 2];
                            inflate(data, byteArray);
                            interpretBytesAsShorts(byteArray, sdata, unitsInThisTile);
                        } else if (compression == COMP_NONE) {
                            readShorts(byteCount / 2, sdata);
                        }
                        stream.seek(save_offset);
                    } catch (IOException ioe) {
                        throw new RuntimeException(""TIFFImage13"");
                    }
                }
            } else if (sampleSize == 8) {
                if (decodePaletteAsShorts) {
                    byte tempData[] = null;
                    int unitsBeforeLookup = unitsInThisTile / 3;
                    try {
                        if (compression == COMP_PACKBITS) {
                            stream.readFully(data, 0, byteCount);
                            tempData = new byte[unitsBeforeLookup];
                            decodePackbits(data, unitsBeforeLookup, tempData);
                        } else if (compression == COMP_LZW) {
                            stream.readFully(data, 0, byteCount);
                            tempData = new byte[unitsBeforeLookup];
                            lzwDecoder.decode(data, tempData, newRect.height);
                        } else if (compression == COMP_JPEG_TTN2) {
                            stream.readFully(data, 0, byteCount);
                            Raster tempTile = decodeJPEG(data, decodeParam, colorConvertJPEG, tile.getMinX(), tile.getMinY());
                            int[] tempPixels = new int[unitsBeforeLookup];
                            tempTile.getPixels(tile.getMinX(), tile.getMinY(), tile.getWidth(), tile.getHeight(), tempPixels);
                            tempData = new byte[unitsBeforeLookup];
                            for (int i = 0; i < unitsBeforeLookup; i++) {
                                tempData[i] = (byte) tempPixels[i];
                            }
                        } else if (compression == COMP_DEFLATE) {
                            stream.readFully(data, 0, byteCount);
                            tempData = new byte[unitsBeforeLookup];
                            inflate(data, tempData);
                        } else if (compression == COMP_NONE) {
                            tempData = new byte[byteCount];
                            stream.readFully(tempData, 0, byteCount);
                        }
                        stream.seek(save_offset);
                    } catch (IOException ioe) {
                        throw new RuntimeException(""TIFFImage13"");
                    }
                    int cmapValue;
                    int count = 0, lookup, len = colormap.length / 3;
                    int len2 = len * 2;
                    for (int i = 0; i < unitsBeforeLookup; i++) {
                        lookup = tempData[i] & 0xff;
                        cmapValue = colormap[lookup + len2];
                        sdata[count++] = (short) (cmapValue & 0xffff);
                        cmapValue = colormap[lookup + len];
                        sdata[count++] = (short) (cmapValue & 0xffff);
                        cmapValue = colormap[lookup];
                        sdata[count++] = (short) (cmapValue & 0xffff);
                    }
                } else {
                    try {
                        if (compression == COMP_PACKBITS) {
                            stream.readFully(data, 0, byteCount);
                            decodePackbits(data, unitsInThisTile, bdata);
                        } else if (compression == COMP_LZW) {
                            stream.readFully(data, 0, byteCount);
                            lzwDecoder.decode(data, bdata, newRect.height);
                        } else if (compression == COMP_JPEG_TTN2) {
                            stream.readFully(data, 0, byteCount);
                            tile.setRect(decodeJPEG(data, decodeParam, colorConvertJPEG, tile.getMinX(), tile.getMinY()));
                        } else if (compression == COMP_DEFLATE) {
                            stream.readFully(data, 0, byteCount);
                            inflate(data, bdata);
                        } else if (compression == COMP_NONE) {
                            stream.readFully(bdata, 0, byteCount);
                        }
                        stream.seek(save_offset);
                    } catch (IOException ioe) {
                        throw new RuntimeException(""TIFFImage13"");
                    }
                }
            } else if (sampleSize == 4) {
                int padding = (newRect.width % 2 == 0) ? 0 : 1;
                int bytesPostDecoding = ((newRect.width / 2 + padding) * newRect.height);
                if (decodePaletteAsShorts) {
                    byte tempData[] = null;
                    try {
                        stream.readFully(data, 0, byteCount);
                        stream.seek(save_offset);
                    } catch (IOException ioe) {
                        throw new RuntimeException(""TIFFImage13"");
                    }
                    if (compression == COMP_PACKBITS) {
                        tempData = new byte[bytesPostDecoding];
                        decodePackbits(data, bytesPostDecoding, tempData);
                    } else if (compression == COMP_LZW) {
                        tempData = new byte[bytesPostDecoding];
                        lzwDecoder.decode(data, tempData, newRect.height);
                    } else if (compression == COMP_DEFLATE) {
                        tempData = new byte[bytesPostDecoding];
                        inflate(data, tempData);
                    } else if (compression == COMP_NONE) {
                        tempData = data;
                    }
                    int bytes = unitsInThisTile / 3;
                    data = new byte[bytes];
                    int srcCount = 0, dstCount = 0;
                    for (int j = 0; j < newRect.height; j++) {
                        for (int i = 0; i < newRect.width / 2; i++) {
                            data[dstCount++] = (byte) ((tempData[srcCount] & 0xf0) >> 4);
                            data[dstCount++] = (byte) (tempData[srcCount++] & 0x0f);
                        }
                        if (padding == 1) {
                            data[dstCount++] = (byte) ((tempData[srcCount++] & 0xf0) >> 4);
                        }
                    }
                    int len = colormap.length / 3;
                    int len2 = len * 2;
                    int cmapValue, lookup;
                    int count = 0;
                    for (int i = 0; i < bytes; i++) {
                        lookup = data[i] & 0xff;
                        cmapValue = colormap[lookup + len2];
                        sdata[count++] = (short) (cmapValue & 0xffff);
                        cmapValue = colormap[lookup + len];
                        sdata[count++] = (short) (cmapValue & 0xffff);
                        cmapValue = colormap[lookup];
                        sdata[count++] = (short) (cmapValue & 0xffff);
                    }
                } else {
                    try {
                        if (compression == COMP_PACKBITS) {
                            stream.readFully(data, 0, byteCount);
                            decodePackbits(data, bytesPostDecoding, bdata);
                        } else if (compression == COMP_LZW) {
                            stream.readFully(data, 0, byteCount);
                            lzwDecoder.decode(data, bdata, newRect.height);
                        } else if (compression == COMP_DEFLATE) {
                            stream.readFully(data, 0, byteCount);
                            inflate(data, bdata);
                        } else if (compression == COMP_NONE) {
                            stream.readFully(bdata, 0, byteCount);
                        }
                        stream.seek(save_offset);
                    } catch (IOException ioe) {
                        throw new RuntimeException(""TIFFImage13"");
                    }
                }
            }
        } else if (imageType == TYPE_GRAY_4BIT) {
            try {
                if (compression == COMP_PACKBITS) {
                    stream.readFully(data, 0, byteCount);
                    int bytesInThisTile;
                    if ((newRect.width % 8) == 0) {
                        bytesInThisTile = (newRect.width / 2) * newRect.height;
                    } else {
                        bytesInThisTile = (newRect.width / 2 + 1) * newRect.height;
                    }
                    decodePackbits(data, bytesInThisTile, bdata);
                } else if (compression == COMP_LZW) {
                    stream.readFully(data, 0, byteCount);
                    lzwDecoder.decode(data, bdata, newRect.height);
                } else if (compression == COMP_DEFLATE) {
                    stream.readFully(data, 0, byteCount);
                    inflate(data, bdata);
                } else {
                    stream.readFully(bdata, 0, byteCount);
                }
                stream.seek(save_offset);
            } catch (IOException ioe) {
                throw new RuntimeException(""TIFFImage13"");
            }
        } else {
            try {
                if (sampleSize == 8) {
                    if (compression == COMP_NONE) {
                        stream.readFully(bdata, 0, byteCount);
                    } else if (compression == COMP_LZW) {
                        stream.readFully(data, 0, byteCount);
                        lzwDecoder.decode(data, bdata, newRect.height);
                    } else if (compression == COMP_PACKBITS) {
                        stream.readFully(data, 0, byteCount);
                        decodePackbits(data, unitsInThisTile, bdata);
                    } else if (compression == COMP_JPEG_TTN2) {
                        stream.readFully(data, 0, byteCount);
                        tile.setRect(decodeJPEG(data, decodeParam, colorConvertJPEG, tile.getMinX(), tile.getMinY()));
                    } else if (compression == COMP_DEFLATE) {
                        stream.readFully(data, 0, byteCount);
                        inflate(data, bdata);
                    }
                } else if (sampleSize == 16) {
                    if (compression == COMP_NONE) {
                        readShorts(byteCount / 2, sdata);
                    } else if (compression == COMP_LZW) {
                        stream.readFully(data, 0, byteCount);
                        byte byteArray[] = new byte[unitsInThisTile * 2];
                        lzwDecoder.decode(data, byteArray, newRect.height);
                        interpretBytesAsShorts(byteArray, sdata, unitsInThisTile);
                    } else if (compression == COMP_PACKBITS) {
                        stream.readFully(data, 0, byteCount);
                        int bytesInThisTile = unitsInThisTile * 2;
                        byte byteArray[] = new byte[bytesInThisTile];
                        decodePackbits(data, bytesInThisTile, byteArray);
                        interpretBytesAsShorts(byteArray, sdata, unitsInThisTile);
                    } else if (compression == COMP_DEFLATE) {
                        stream.readFully(data, 0, byteCount);
                        byte byteArray[] = new byte[unitsInThisTile * 2];
                        inflate(data, byteArray);
                        interpretBytesAsShorts(byteArray, sdata, unitsInThisTile);
                    }
                } else if (sampleSize == 32 && dataType == DataBuffer.TYPE_INT) {
                    if (compression == COMP_NONE) {
                        readInts(byteCount / 4, idata);
                    } else if (compression == COMP_LZW) {
                        stream.readFully(data, 0, byteCount);
                        byte byteArray[] = new byte[unitsInThisTile * 4];
                        lzwDecoder.decode(data, byteArray, newRect.height);
                        interpretBytesAsInts(byteArray, idata, unitsInThisTile);
                    } else if (compression == COMP_PACKBITS) {
                        stream.readFully(data, 0, byteCount);
                        int bytesInThisTile = unitsInThisTile * 4;
                        byte byteArray[] = new byte[bytesInThisTile];
                        decodePackbits(data, bytesInThisTile, byteArray);
                        interpretBytesAsInts(byteArray, idata, unitsInThisTile);
                    } else if (compression == COMP_DEFLATE) {
                        stream.readFully(data, 0, byteCount);
                        byte byteArray[] = new byte[unitsInThisTile * 4];
                        inflate(data, byteArray);
                        interpretBytesAsInts(byteArray, idata, unitsInThisTile);
                    }
                }
                stream.seek(save_offset);
            } catch (IOException ioe) {
                throw new RuntimeException(""TIFFImage13"");
            }
            switch(imageType) {
                case TYPE_GRAY:
                case TYPE_GRAY_ALPHA:
                    if (isWhiteZero) {
                        if (dataType == DataBuffer.TYPE_BYTE && !(getColorModel() instanceof IndexColorModel)) {
                            for (int l = 0; l < bdata.length; l += numBands) {
                                bdata[l] = (byte) (255 - bdata[l]);
                            }
                        } else if (dataType == DataBuffer.TYPE_USHORT) {
                            int ushortMax = Short.MAX_VALUE - Short.MIN_VALUE;
                            for (int l = 0; l < sdata.length; l += numBands) {
                                sdata[l] = (short) (ushortMax - sdata[l]);
                            }
                        } else if (dataType == DataBuffer.TYPE_SHORT) {
                            for (int l = 0; l < sdata.length; l += numBands) {
                                sdata[l] = (short) (~sdata[l]);
                            }
                        } else if (dataType == DataBuffer.TYPE_INT) {
                            long uintMax = ((long) Integer.MAX_VALUE - (long) Integer.MIN_VALUE);
                            for (int l = 0; l < idata.length; l += numBands) {
                                idata[l] = (int) (uintMax - idata[l]);
                            }
                        }
                    }
                    break;
                case TYPE_RGB:
                    if (sampleSize == 8 && compression != COMP_JPEG_TTN2) {
                        for (int i = 0; i < unitsInThisTile; i += 3) {
                            bswap = bdata[i];
                            bdata[i] = bdata[i + 2];
                            bdata[i + 2] = bswap;
                        }
                    } else if (sampleSize == 16) {
                        for (int i = 0; i < unitsInThisTile; i += 3) {
                            sswap = sdata[i];
                            sdata[i] = sdata[i + 2];
                            sdata[i + 2] = sswap;
                        }
                    } else if (sampleSize == 32) {
                        if (dataType == DataBuffer.TYPE_INT) {
                            for (int i = 0; i < unitsInThisTile; i += 3) {
                                iswap = idata[i];
                                idata[i] = idata[i + 2];
                                idata[i + 2] = iswap;
                            }
                        }
                    }
                    break;
                case TYPE_RGB_ALPHA:
                    if (sampleSize == 8) {
                        for (int i = 0; i < unitsInThisTile; i += 4) {
                            bswap = bdata[i];
                            bdata[i] = bdata[i + 3];
                            bdata[i + 3] = bswap;
                            bswap = bdata[i + 1];
                            bdata[i + 1] = bdata[i + 2];
                            bdata[i + 2] = bswap;
                        }
                    } else if (sampleSize == 16) {
                        for (int i = 0; i < unitsInThisTile; i += 4) {
                            sswap = sdata[i];
                            sdata[i] = sdata[i + 3];
                            sdata[i + 3] = sswap;
                            sswap = sdata[i + 1];
                            sdata[i + 1] = sdata[i + 2];
                            sdata[i + 2] = sswap;
                        }
                    } else if (sampleSize == 32) {
                        if (dataType == DataBuffer.TYPE_INT) {
                            for (int i = 0; i < unitsInThisTile; i += 4) {
                                iswap = idata[i];
                                idata[i] = idata[i + 3];
                                idata[i + 3] = iswap;
                                iswap = idata[i + 1];
                                idata[i + 1] = idata[i + 2];
                                idata[i + 2] = iswap;
                            }
                        }
                    }
                    break;
                case TYPE_YCBCR_SUB:
                    int pixelsPerDataUnit = chromaSubH * chromaSubV;
                    int numH = newRect.width / chromaSubH;
                    int numV = newRect.height / chromaSubV;
                    byte[] tempData = new byte[numH * numV * (pixelsPerDataUnit + 2)];
                    System.arraycopy(bdata, 0, tempData, 0, tempData.length);
                    int samplesPerDataUnit = pixelsPerDataUnit * 3;
                    int[] pixels = new int[samplesPerDataUnit];
                    int bOffset = 0;
                    int offsetCb = pixelsPerDataUnit;
                    int offsetCr = offsetCb + 1;
                    int y = newRect.y;
                    for (int j = 0; j < numV; j++) {
                        int x = newRect.x;
                        for (int i = 0; i < numH; i++) {
                            int Cb = tempData[bOffset + offsetCb];
                            int Cr = tempData[bOffset + offsetCr];
                            int k = 0;
                            while (k < samplesPerDataUnit) {
                                pixels[k++] = tempData[bOffset++];
                                pixels[k++] = Cb;
                                pixels[k++] = Cr;
                            }
                            bOffset += 2;
                            tile.setPixels(x, y, chromaSubH, chromaSubV, pixels);
                            x += chromaSubH;
                        }
                        y += chromaSubV;
                    }
                    break;
            }
        }
        return tile;
    }
",0
8626037,7,"    public ActionEvent(java.awt.event.ActionEvent evt) {
        super(evt.getSource(), java.awt.event.ActionEvent.ACTION_PERFORMED, evt.getActionCommand());
        String command = evt.getActionCommand();
        String[] strs = command.split("" "");
        this.command = strs[0];
        if (strs.length > 1) {
            this.arguments = new String[strs.length - 1];
            for (int i = 0; i < strs.length - 1; i++) {
                this.arguments[i] = strs[i + 1];
            }
        }
    }
",1
7750023,7,"    @Override
    public void mousePressed(MouseEvent e) {
        if (e.getButton() == MouseEvent.BUTTON2) return;
        mouseCurvePointIndex = findPointUnderMouse(e.getPoint());
        if (e.getButton() == MouseEvent.BUTTON1 && mouseCurvePointIndex == -1) {
            Point mp = e.getPoint();
            for (int p = 0; p < curve.length - 1; p++) {
                if (mp.x > curve[p].x && mp.x < curve[p + 1].x) {
                    Point[] newCurve = new Point[curve.length + 1];
                    int i = 0;
                    for (; i <= p; i++) newCurve[i] = curve[i];
                    newCurve[i++] = mp;
                    for (; i < newCurve.length; i++) newCurve[i] = curve[i - 1];
                    curve = newCurve;
                    repaint();
                    mouseCurvePointIndex = p + 1;
                    break;
                }
            }
        } else if (e.getButton() == MouseEvent.BUTTON3 && mouseCurvePointIndex > 0 && mouseCurvePointIndex < curve.length - 1) {
            Point[] newCurve = new Point[curve.length - 1];
            int i = 0;
            for (; i < mouseCurvePointIndex; i++) newCurve[i] = curve[i];
            for (; i < newCurve.length; i++) newCurve[i] = curve[i + 1];
            mouseCurvePointIndex = -1;
            curve = newCurve;
            repaint();
            notifyCurveChange();
        }
    }
",1
133091,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
",1
7894087,7,"    public void AppendHistoryLine(String line) {
        if (currentHistoryLine == nrHistoryLines) {
            int i;
            for (i = 0; i < currentHistoryLine - 1; i++) {
                history[i] = history[i + 1];
            }
            currentHistoryLine--;
        }
        history[currentHistoryLine] = line;
        currentHistoryLine++;
    }
",1
7245535,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
",1
22434651,7,"    public static void main(String args[]) throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        if (args.length < 1) {
            System.out.println(""usage: Launcher <Classname> [<args>]"");
            System.exit(1);
        }
        String className = args[0];
        int nargs = args.length - 1;
        String[] runArgs = new String[nargs];
        for (int i = 0; i < nargs; i++) {
            runArgs[i] = args[i + 1];
        }
        System.out.println(String.format(""running %s with %d arguments"", className, nargs));
        Class<?> program = ClassLoader.getSystemClassLoader().loadClass(className);
        Class<?>[] parameterTypes = new Class[] { args.getClass() };
        Method method = program.getMethod(""main"", parameterTypes);
        method.invoke(null, new Object[] { runArgs });
    }
",1
16951127,7,"    public void RemoveElement(ElementBase aE) {
        for (int i = 0; i < elements.length; i++) {
            if (elements[i] == aE) {
                if (i < elements.length - 1) {
                    elements[i] = elements[i + 1];
                    elements[i + 1] = null;
                } else {
                    elements[i] = null;
                }
            }
        }
        changed = true;
    }
",1
476609,7,"    public void run() {
        VM_Callbacks.notifyStartup();
        VM_Controller.boot();
        String[] mainArgs = null;
        INSTRUCTION[] mainCode = null;
        synchronized (VM_ClassLoader.lock) {
            VM_Class cls = null;
            try {
                cls = VM_Class.forName(args[0]);
            } catch (VM_ResolutionException e) {
                VM.sysWrite(e.getException() + ""\n"");
                return;
            }
            mainMethod = cls.findMainMethod();
            if (mainMethod == null) {
                VM.sysWrite(cls.getName() + "" doesn't have a \""public static void main(String[])\"" method to execute\n"");
                return;
            }
            mainArgs = new String[args.length - 1];
            for (int i = 0, n = mainArgs.length; i < n; ++i) mainArgs[i] = args[i + 1];
            mainCode = mainMethod.compile();
        }
        VM.debugBreakpoint();
        VM_Magic.invokeMain(mainArgs, mainCode);
    }
",1
5248248,7,"    @Override
    public DoublePlane xGradient() {
        DoublePlane plane = new DoublePlane(getSize());
        double[] src = doubleArray();
        double[] dst = plane.doubleArray();
        int w = getWidth();
        int h = getHeight();
        for (int y = 0; y < h; y++) {
            int row = y * w;
            int end = row + w - 1;
            for (int x = row; x < end; x++) {
                dst[x] = src[x + 1] - src[x];
            }
        }
        return plane;
    }
",1
16167613,7,"    @Override
    protected Document doWork(Document document) throws OperatorException {
        String text = document.getText();
        Matcher matcher = null;
        if (getParameterAsBoolean(PARAMETER_OVERRIDE_CONTENT_TYPE_INFORMATION)) {
            String previousEncoding = URLConnectionProvider.DEFAULT_ENCODING;
            if (document.getMetaDataKeys().contains(GetWebpageOperator.META_DATA_CONTENT_TYPE)) {
                previousEncoding = URLConnectionProvider.parseEncoding((String) document.getMetaDataValue(GetWebpageOperator.META_DATA_CONTENT_TYPE));
            }
            matcher = Pattern.compile(""<meta[\\s]*http-equiv=[\""]*([^>]*?)[\""]*[\\s]*content=[\""]*([^>]*?)[\""]*[\\s]*?[/]*?>"").matcher(text.toLowerCase());
            while (matcher.find()) {
                if (matcher.groupCount() >= 2) {
                    String key = matcher.group(1).trim();
                    String value = matcher.group(2).trim();
                    if (key.toLowerCase().equals(""content-type"")) {
                        String encoding = URLConnectionProvider.parseEncoding(value.replace(""\"""", """"));
                        try {
                            text = new String(text.getBytes(previousEncoding), Encoding.getEncoding(encoding));
                            encodingChanged = true;
                        } catch (UnsupportedEncodingException e) {
                            text = new String(text.getBytes(), Encoding.getEncoding(encoding));
                        } catch (IllegalCharsetNameException e) {
                        } catch (UnsupportedCharsetException e) {
                        }
                        document.addMetaData(GetWebpageOperator.META_DATA_CONTENT_TYPE, value, Ontology.NOMINAL);
                        break;
                    }
                }
            }
        }
        int titleStart = text.toLowerCase().indexOf(""<title>"") + ""<title>"".length();
        int titleEnd = text.toLowerCase().indexOf(""</title>"");
        if (titleStart >= 0 && titleEnd >= 0 && titleStart < titleEnd) {
            String title = text.substring(titleStart, titleEnd).trim();
            if (title != null && !title.isEmpty()) {
                document.addMetaData(META_DATA_HTML_TITLE, StringEscapeUtils.unescapeHtml(title), Ontology.NOMINAL);
            } else {
                document.addMetaData(META_DATA_HTML_TITLE, (String) null, Ontology.NOMINAL);
            }
        } else {
            document.addMetaData(META_DATA_HTML_TITLE, (String) null, Ontology.NOMINAL);
        }
        document.addMetaData(META_DATA_HTML_LANGUAGE, (String) null, Ontology.NOMINAL);
        document.addMetaData(META_DATA_HTML_DESCRIPTION, (String) null, Ontology.NOMINAL);
        document.addMetaData(META_DATA_HTML_KEYWORDS, (String) null, Ontology.NOMINAL);
        document.addMetaData(META_DATA_HTML_ROBOTS, (String) null, Ontology.NOMINAL);
        matcher = Pattern.compile(""<(meta|META)[\\s]*(HTTP-EQUIV|http-equiv|NAME|name)=[\""]*([^>]*?)[\""]*[\\s]*(content|CONTENT)=[\""]*([^>]*?)[\""]*[\\s]*?[/]*?>"").matcher(text);
        while (matcher.find()) {
            if (matcher.groupCount() >= 5) {
                String key = matcher.group(3).trim();
                String value = matcher.group(5).trim();
                if (key != null && !key.isEmpty()) {
                    if (key.toLowerCase().equals(""language"")) {
                        document.addMetaData(META_DATA_HTML_LANGUAGE, value, Ontology.NOMINAL);
                        continue;
                    }
                    if (key.toLowerCase().equals(""description"")) {
                        document.addMetaData(META_DATA_HTML_DESCRIPTION, StringEscapeUtils.unescapeHtml(value), Ontology.NOMINAL);
                        continue;
                    }
                    if (key.toLowerCase().equals(""keywords"")) {
                        document.addMetaData(META_DATA_HTML_KEYWORDS, StringEscapeUtils.unescapeHtml(value), Ontology.NOMINAL);
                        continue;
                    }
                    if (key.toLowerCase().equals(""robots"")) {
                        document.addMetaData(META_DATA_HTML_ROBOTS, value, Ontology.NOMINAL);
                        continue;
                    }
                }
            }
        }
        if (getParameterAsBoolean(PARAMETER_EXTRACT_CONTENT)) {
            text = text.replaceAll(""<!--[\\s\\S]?-->"", """");
            text = text.replaceAll(""<style.*?>[\\s\\S]*?</style>"", """");
            text = text.replaceAll(""<script.*?>[\\s\\S]*?</script>"", """");
            text = text.replaceAll(""<img[^>]*?>"", """");
            text = text.replaceAll(""<a[^>]*?>(.*?)<[\\s]*/a>"", "" $1 "");
            if (getParameterAsBoolean(PARAMETER_NEGLEGT_SPAN_TAGS)) {
                text = text.replaceAll(""<[/]*[span|SPAN][^>]*?>(.*?)<[\\s]*/span>"", "" $1 "");
            }
            if (getParameterAsBoolean(PARAMETER_NEGLECT_P_TAGS)) {
                text = text.replaceAll(""<[/]*[p|P][^a-zA-Z>]*?>"", "" "");
            }
            if (getParameterAsBoolean(PARAMETER_NEGLECT_B_TAGS)) {
                text = text.replaceAll(""<[/]*[b|B][^a-zA-Z>]*?>"", "" "");
            }
            if (getParameterAsBoolean(PARAMETER_NEGLECT_I_TAGS)) {
                text = text.replaceAll(""<[/]*[i|I][^a-zA-Z>]*?>"", "" "");
            }
            if (getParameterAsBoolean(PARAMETER_NEGLECT_BR_TAGS)) {
                text = text.replaceAll(""<(br|BR)[^>]*?>"", "" "");
            }
            if (getParameterAsBoolean(PARAMETER_IGNORE_NON_HTML_TAGS)) {
                matcher = Pattern.compile(""</?([A-Za-z]*)?([^>]*?)>"").matcher(text);
                while (matcher.find()) {
                    if (matcher.groupCount() > 0) {
                        if (!knownTags.contains(matcher.group(1).toLowerCase())) {
                            text = text.replace(matcher.group(0), """");
                        }
                    }
                }
            }
            text = text.replaceAll(""(<[^>]*?>)"", "" <tag> "");
            text = text.replaceAll(""[\r]*[\n]+"", "" "");
            text = text.replaceAll(""[\\s]+"", "" "");
            String[] words = text.split(""\\s"");
            int[] lengths = new int[words.length];
            for (int i = 0; i < words.length; i++) {
                if (words[i].equals(""<tag>"")) {
                    lengths[i] = 0;
                } else {
                    lengths[i] = (i > 0 ? lengths[i - 1] : 0) + 1;
                }
            }
            for (int i = words.length - 2; i >= 0; i--) {
                if (lengths[i] != 0 && lengths[i] < lengths[i + 1]) {
                    lengths[i] = lengths[i + 1];
                }
            }
            int minLength = getParameterAsInt(PARAMETER_MIN_LENGTH);
            List<Token> tokens = new LinkedList<Token>();
            for (int i = 0; i < words.length; i++) {
                if (lengths[i] >= minLength) {
                    StringBuffer buf = new StringBuffer();
                    for (int j = 0; j < lengths[i]; j++) {
                        buf.append(words[i++] + "" "");
                        if (i >= lengths.length) {
                            break;
                        }
                    }
                    tokens.add(new Token(StringEscapeUtils.unescapeHtml(buf.toString().trim()), 1));
                }
            }
            return new Document(tokens, new Document(Collections.singletonList(new Token(text, 1f)), document));
        } else {
            if (encodingChanged) {
                Document newDocument = new Document(Collections.singletonList(new Token(text, 1f)), new Document(Collections.singletonList(new Token(text, 1f)), document));
                newDocument.getText();
                return newDocument;
            } else {
                return document;
            }
        }
    }
",1
14082763,7,"    private void stringsMoveOneForward(String[] strings, int beginIndex) {
        for (int i = beginIndex; strings[i + 1] != null; i++) {
            strings[i] = strings[i + 1];
        }
    }
",1
16070030,7,"    private CommandLine parseCommandLine(TclObject argv[]) throws ParseException {
        String[] args = new String[argv.length - 1];
        for (int i = 0; i < argv.length - 1; i++) args[i] = argv[i + 1].toString();
        CommandLine cl = (new PosixParser()).parse(opts, args);
        return cl;
    }
",1
16045012,7,"        public void rendezvousFunction(Object[] objects) {
            int lastIdx = objects.length - 1;
            Object first = objects[0];
            for (int i = 0; i < lastIdx; ++i) objects[i] = objects[i + 1];
            objects[lastIdx] = first;
        }
",1
9696716,7,"    private void deleteBond(int i) {
        int newLength = bonds.length - 1;
        if (newLength == 0) {
            bonds = null;
            return;
        }
        Bond[] bondsNew = new Bond[newLength];
        int j = 0;
        for (; j < i; ++j) bondsNew[j] = bonds[j];
        for (; j < newLength; ++j) bondsNew[j] = bonds[j + 1];
        bonds = bondsNew;
    }
",1
9532243,7,"    public static <NodeType, EdgeType> GastonTree<NodeType, EdgeType> create(final GastonPath<NodeType, EdgeType> backbone, Leg<NodeType, EdgeType> ack, final Collection<Leg<NodeType, EdgeType>> siblings) {
        final HPGraph<NodeType, EdgeType> path = backbone.toHPFragment().toHPGraph();
        final LocalEnvironment<NodeType, EdgeType> env = LocalEnvironment.env(backbone);
        final int nodeA = ack.getNodeA();
        final int nodeLabel = ack.ref.getToLabel();
        final int edgeLabel = ack.ref.getEdgeLabel();
        int ln = backbone.frontNode;
        int rn = backbone.backNode;
        int le = path.getNodeEdge(ln, 0);
        int re = path.getNodeEdge(rn, 0);
        {
            final int iln = path.getOtherNode(le, ln), irn = path.getOtherNode(re, rn);
            final int lel = path.getEdgeLabelIndex(le, env), rel = path.getEdgeLabelIndex(re, env);
            final int lnl = path.getNodeLabelIndex(ln, env), rnl = path.getNodeLabelIndex(rn, env);
            if ((nodeA == iln && (lel < edgeLabel || (lel == edgeLabel && lnl < nodeLabel))) || (nodeA == irn && (rel < edgeLabel || (rel == edgeLabel && rnl < nodeLabel)))) {
                return null;
            }
        }
        final int length = path.getMaxNodeIndex();
        final DepthRefinement nodes[] = new DepthRefinement[length];
        final DepthRefinement right[] = new DepthRefinement[length];
        final DepthRefinement bb[] = new DepthRefinement[length];
        final DepthRefinement rmp[] = new DepthRefinement[length];
        final int leftArrayLength = path.getNodeCount() / 2;
        final int lastRigthDepth = (path.getNodeCount() - 1) / 2;
        final int rpmNodes[] = new int[length];
        final BitSet rmpEqualsbb = new BitSet(length);
        int sym = 0;
        int tmp;
        boolean rightExtension = false;
        DepthRefinement lend, rend, lack, rack, tmpr;
        nodes[ln] = lack = lend = new DepthRefinement(ln, path.getEdgeLabelIndex(le, env), path.getNodeLabelIndex(ln, env), rpmNodes);
        nodes[rn] = rack = rend = new DepthRefinement(rn, path.getEdgeLabelIndex(re, env), path.getNodeLabelIndex(rn, env), rpmNodes);
        tmp = lack.compareLabels(rack);
        if (tmp != 0) {
            sym = tmp;
        }
        while (re != le) {
            ln = path.getOtherNode(le, ln);
            rn = path.getOtherNode(re, rn);
            if (rn == ln) {
                break;
            }
            for (int i = 0, oldEdge = le; le == oldEdge; i++) {
                le = path.getNodeEdge(ln, i);
            }
            for (int i = 0, oldEdge = re; re == oldEdge; i++) {
                re = path.getNodeEdge(rn, i);
            }
            lack.prev = nodes[ln] = tmpr = new DepthRefinement(ln, path.getEdgeLabelIndex(le, env), path.getNodeLabelIndex(ln, env), rpmNodes);
            lack = tmpr;
            rack.prev = nodes[rn] = tmpr = new DepthRefinement(rn, path.getEdgeLabelIndex(re, env), path.getNodeLabelIndex(rn, env), rpmNodes);
            rack = tmpr;
            tmp = lack.compareLabels(rack);
            if (tmp != 0) {
                sym = tmp;
            }
            rightExtension |= rn == nodeA;
        }
        if (sym == 0 && rightExtension) {
            return null;
        }
        if (sym < 0) {
            tmpr = lack;
            lack = rack;
            rack = tmpr;
            tmpr = lend;
            lend = rend;
            rend = tmpr;
        }
        if (rn == ln) {
            rack.prev = nodes[rn] = tmpr = new DepthRefinement(rn, path.getEdgeLabelIndex(le, env), path.getNodeLabelIndex(rn, env), rpmNodes);
            rack = tmpr;
        }
        lack.prev = rend;
        tmpr = lend;
        int i = 0;
        for (i = length - 1; tmpr != null; i--) {
            rpmNodes[i] = tmpr.nodeA;
            tmpr.nodeA = i;
            rmp[i] = bb[i] = tmpr;
            tmpr = tmpr.prev;
        }
        final Collection<Leg<NodeType, EdgeType>> newSiblings = new ArrayList<Leg<NodeType, EdgeType>>();
        for (final Leg<NodeType, EdgeType> cur : siblings) {
            if (cur.ref.isCycleRefinement()) {
                newSiblings.add(cur);
            } else {
                final int cdepth = nodes[cur.getNodeA()].getDepth() + 1;
                final DepthRefinement ref = new DepthRefinement(cdepth, cur.ref.getEdgeLabel(), cur.ref.getToLabel(), rpmNodes);
                if (cdepth != length && cdepth != lastRigthDepth + 1 && (cdepth != length - 1 || bb[length - 1].compareTo(ref) >= 0) && (cdepth != lastRigthDepth || bb[lastRigthDepth].compareTo(ref) >= 0)) {
                    final Leg<NodeType, EdgeType> nl = new Leg<NodeType, EdgeType>(ref, cur.frag);
                    newSiblings.add(nl);
                    if (cur == ack) {
                        ack = nl;
                    }
                }
            }
        }
        final int ackDepth = ack.ref.getDepth();
        rpmNodes[ackDepth] = ack.frag.correspondingNode;
        DepthRefinement npn = null, pnpn = null, splittNode = null;
        final DepthRefinement ackr = (DepthRefinement) ack.ref;
        int maxDepth;
        if (ackDepth > lastRigthDepth) {
            if (sym == 0) {
                pnpn = ackr;
            }
            ackr.prev = lend;
            lend = ackr;
            maxDepth = lastRigthDepth + leftArrayLength;
        } else {
            ackr.prev = rend;
            rend = ackr;
            maxDepth = lastRigthDepth;
        }
        tmp = bb[ackDepth].compareTo(ackr);
        splittNode = ackr;
        if (tmp == 0) {
            npn = next(bb[ackDepth], ackr);
        } else if (tmp < 0) {
            maxDepth--;
        }
        for (i = 0; i < ackDepth - 1; i++) {
            if (i != lastRigthDepth) {
                right[i] = rmp[i + 1];
            }
        }
        rmp[ackDepth] = right[ackDepth - 1] = (DepthRefinement) ack.ref;
        rmpEqualsbb.set(0, ackDepth - 1);
        rmpEqualsbb.set(ackDepth, bb[ackDepth].compareTo(ackr) == 0);
        lack.prev = null;
        return new GastonTree<NodeType, EdgeType>(backbone.getLevel() + 1, ack, newSiblings, bb, rmp, npn, pnpn, splittNode, lend, rend, leftArrayLength, lastRigthDepth, maxDepth, rpmNodes, right, rmpEqualsbb, backbone.getThreadNumber());
    }
",1
14498798,7,"    private void updateMemory(Trail t) {
        for (int i = 0; i < memory.length; i++) {
            if (memory[i] == t) {
                for (int j = i; j < (memory.length - 1); j++) {
                    memory[j] = memory[j + 1];
                }
                memory[memory.length - 1] = null;
            }
        }
        if (t.getCost() != null) {
            for (int i = 0; i < memory.length; i++) {
                if (memory[i] == null) {
                    memory[i] = t;
                    break;
                } else if ((t.getCost().compareTo(memory[i].getCost()) == 1) || ((t.getCost().compareTo(memory[i].getCost()) == 0) && (t.getVertices().size() < memory[i].getVertices().size()))) {
                    for (int j = (memory.length - 1); j > i; j--) {
                        memory[j] = memory[j - 1];
                    }
                    memory[i] = t;
                    break;
                }
            }
        }
    }
",1
12638226,7,"    private static String[] getJobArgs(String[] args) {
        String[] sa = null;
        if (args.length > 1) {
            sa = new String[args.length - 1];
            for (int i = 0; i < sa.length; i++) {
                sa[i] = args[i + 1];
            }
        }
        return sa;
    }
",1
216311,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
19658655,7,"    private static void dualPivotQuicksort(double[] a, int left, int right) {
        int sixth = (right - left + 1) / 6;
        int e1 = left + sixth;
        int e5 = right - sixth;
        int e3 = (left + right) >>> 1;
        int e4 = e3 + sixth;
        int e2 = e3 - sixth;
        double ae1 = a[e1], ae2 = a[e2], ae3 = a[e3], ae4 = a[e4], ae5 = a[e5];
        if (ae1 > ae2) {
            double t = ae1;
            ae1 = ae2;
            ae2 = t;
        }
        if (ae4 > ae5) {
            double t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        if (ae1 > ae3) {
            double t = ae1;
            ae1 = ae3;
            ae3 = t;
        }
        if (ae2 > ae3) {
            double t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae1 > ae4) {
            double t = ae1;
            ae1 = ae4;
            ae4 = t;
        }
        if (ae3 > ae4) {
            double t = ae3;
            ae3 = ae4;
            ae4 = t;
        }
        if (ae2 > ae5) {
            double t = ae2;
            ae2 = ae5;
            ae5 = t;
        }
        if (ae2 > ae3) {
            double t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae4 > ae5) {
            double t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        a[e1] = ae1;
        a[e3] = ae3;
        a[e5] = ae5;
        double pivot1 = ae2;
        a[e2] = a[left];
        double pivot2 = ae4;
        a[e4] = a[right];
        int less = left + 1;
        int great = right - 1;
        boolean pivotsDiffer = (pivot1 != pivot2);
        if (pivotsDiffer) {
            outer: for (int k = less; k <= great; k++) {
                double ak = a[k];
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else if (ak > pivot2) {
                    while (a[great] > pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = a[great];
                        a[great--] = ak;
                    }
                }
            }
        } else {
            for (int k = less; k <= great; k++) {
                double ak = a[k];
                if (ak == pivot1) {
                    continue;
                }
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else {
                    while (a[great] > pivot1) {
                        great--;
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = pivot1;
                        a[great--] = ak;
                    }
                }
            }
        }
        a[left] = a[less - 1];
        a[less - 1] = pivot1;
        a[right] = a[great + 1];
        a[great + 1] = pivot2;
        doSort(a, left, less - 2);
        doSort(a, great + 2, right);
        if (!pivotsDiffer) {
            return;
        }
        if (less < e1 && great > e5) {
            while (a[less] == pivot1) {
                less++;
            }
            while (a[great] == pivot2) {
                great--;
            }
            outer: for (int k = less; k <= great; k++) {
                double ak = a[k];
                if (ak == pivot2) {
                    while (a[great] == pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] == pivot1) {
                        a[k] = a[less];
                        a[less++] = pivot1;
                    } else {
                        a[k] = a[great];
                    }
                    a[great--] = pivot2;
                } else if (ak == pivot1) {
                    a[k] = a[less];
                    a[less++] = pivot1;
                }
            }
        }
        doSort(a, less, great);
    }
",1
3873638,7,"    public static void main(String[] args) {
        if (args.length == 1 && ""writer"".equals(args[0])) {
            LicenseMakerFrame.main(new String[0]);
        } else if (args.length > 1 && ""batch"".equals(args[0])) {
            String[] newArgs = new String[args.length - 1];
            for (int i = 0; i < newArgs.length; i++) {
                newArgs[i] = args[i + 1];
            }
            LicenseBatchWriter.main(newArgs);
        } else {
            DrivingLicenseApp.main(new String[0]);
        }
    }
",1
5953187,7,"    public Object[] invoke(DPWSContextImpl context, OperationInfo context_aoi, Object body) throws DPWSException {
        String actionURI = (context_aoi.isEvent()) ? context_aoi.getOutAction() : context_aoi.getInAction();
        OperationInfo aoi = invokationMap.get(actionURI);
        if (aoi == null) throw new DPWSException(""Could not invoke action : "" + actionURI + "" ."");
        Method method = aoi.getMethod();
        if (method == null) throw new DPWSException(""No method define for action : "" + actionURI + "" ."");
        Class<?>[] classes = method.getParameterTypes();
        if (classes == null) throw new DPWSException(""Method with incorrect parameters for action : "" + actionURI + "" ."");
        int len = classes.length;
        Object[] params = new Object[classes.length];
        params[0] = context;
        Object localImplementor = actionToImplementor.get(actionURI);
        if (body == null) {
        } else if (body instanceof List) {
            List<?> bodyList = (List<?>) body;
            if (!(localImplementor instanceof InvocationHandler) && len != 1 + bodyList.size()) throw new DPWSException(""Incorrect parameter number for action : "" + actionURI + "" ."");
            for (int i = 0; i < bodyList.size(); i++) params[i + 1] = bodyList.get(i);
        } else {
            params[1] = new Object[] { body };
        }
        try {
            Class<?> retClass = method.getReturnType();
            if (localImplementor instanceof InvocationHandler) {
                InvocationHandler handler = (InvocationHandler) localImplementor;
                Object obj = handler.invoke(null, method, params);
                return new Object[] { obj };
            }
            if (retClass.isArray()) {
                return (Object[]) method.invoke(localImplementor, params);
            }
            Object obj = null;
            if ((getIfmappingpe() != null) && (getIfmappingpe().serviceMap.containsKey(actionURI))) {
                Mappedservice ms = getIfmappingpe().serviceMap.get(actionURI);
                if (ms.invparams.length == 0) obj = ms.invmethode.invoke(getIfmappingpe().invokerinstanz); else {
                    Object[] invokingparameters = new Object[params.length - 1];
                    for (int i = 0; i < params.length - 1; i++) invokingparameters[0] = params[i + 1];
                    obj = ms.invmethode.invoke(getIfmappingpe().invokerinstanz, invokingparameters);
                }
            } else {
                obj = method.invoke(localImplementor, params);
            }
            return new Object[] { obj };
        } catch (IllegalArgumentException e) {
            throw new DPWSException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new DPWSException(e.getMessage());
        } catch (InvocationTargetException e) {
            if (e.getTargetException() instanceof DPWSException) throw (DPWSException) e.getTargetException();
            throw new DPWSException(e.getTargetException());
        } catch (Throwable e) {
            log.error(""While invoking InvocationHandler"", e);
            throw new DPWSException(e.getMessage());
        }
    }
",1
16929312,7,"    public Tile useTile(int i) {
        if ((tray[i] == null) || (i >= TRAY_SIZE) || (i < 0)) return null;
        Tile t = tray[i];
        for (int j = i; j < getNumUnusedTiles() - 1; j++) tray[j] = tray[j + 1];
        tray[getNumUnusedTiles() - 1] = null;
        setNumUnusedTiles(getNumUnusedTiles() - 1);
        return t;
    }
",1
664908,7,"    public static String operacion(String entrada) {
        final int operadores_totales = 100;
        final int numeros_totales = 100;
        int i, j, k;
        int n_op = 0;
        int n_num = 0;
        float numero[] = new float[numeros_totales];
        char op[] = new char[operadores_totales];
        char entradaC[];
        String[] numeroS = new String[numeros_totales];
        String resultado;
        entradaC = new char[entrada.length()];
        for (i = 0; i < entrada.length(); i++) entradaC[i] = entrada.charAt(i);
        for (i = 0; i < entrada.length(); i++) {
            if (entradaC[i] == '/' || entradaC[i] == '-' || entradaC[i] == '+') {
                op[n_op] = entradaC[i];
                n_op++;
            } else if (entradaC[i] == '*') {
                if (entradaC[i + 1] == '*') {
                    op[n_op] = '^';
                    n_op++;
                    i++;
                } else {
                    op[n_op] = '*';
                    n_op++;
                }
            }
        }
        for (i = 0; i <= 9; i++) numeroS[i] = """";
        for (i = 0; i < entrada.length(); i++) {
            if (entradaC[i] == '/' || entradaC[i] == '-' || entradaC[i] == '+') {
                n_num++;
            } else if (entradaC[i] == '*') {
                if (entradaC[i + 1] == '*' || entradaC[i] == '/' || entradaC[i] == '-' || entradaC[i] == '+') {
                    i++;
                    n_num++;
                } else n_num++;
            } else numeroS[n_num] += String.valueOf(entradaC[i]);
        }
        for (i = 0; i <= n_num; i++) {
            if (numeroS[i] != """") numero[i] = Float.parseFloat(numeroS[i]);
        }
        for (i = 0, j = 0; i <= n_op; ) {
            if (op[i] == '^') {
                numero[i] = potencia(numero[i], numero[i + 1]);
                op[i] = '0';
                numero[i + 1] = 0;
            } else i++;
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (numero[j] == 0) {
                    numero[j] = numero[j + 1];
                    numero[j + 1] = 0;
                }
            }
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (op[j] == '0') {
                    op[j] = op[j + 1];
                    op[j + 1] = '0';
                }
            }
        }
        for (i = 0; i <= n_op; ) {
            if (op[i] == '*') {
                numero[i] = numero[i] * numero[i + 1];
                op[i] = '0';
                numero[i + 1] = 0;
            } else if (op[i] == '/') {
                numero[i] = numero[i] / numero[i + 1];
                op[i] = '0';
                numero[i + 1] = 0;
            } else i++;
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (numero[j] == 0) {
                    numero[j] = numero[j + 1];
                    numero[j + 1] = 0;
                }
            }
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (op[j] == '0') {
                    op[j] = op[j + 1];
                    op[j + 1] = '0';
                }
            }
        }
        for (i = 0; i <= n_op; i++) {
            if (op[0] == '+') {
                numero[0] = numero[0] + numero[1];
                op[0] = '0';
                numero[i + 1] = 0;
            }
            if (op[0] == '-') {
                numero[0] = numero[0] - numero[1];
                op[0] = '0';
                numero[1] = 0;
            }
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (numero[j] == 0) {
                    numero[j] = numero[j + 1];
                    numero[j + 1] = 0;
                }
            }
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (op[j] == '0') {
                    op[j] = op[j + 1];
                    op[j + 1] = '0';
                }
            }
        }
        resultado = """" + (int) numero[0];
        return resultado;
    }
",1
14039746,7,"    protected static Long[] removeFromIDArray(Long[] array, Long el) {
        int index = -1;
        for (int n = 0; n < array.length; n++) {
            if (array[n] == el) {
                index = n;
                break;
            }
        }
        assert index != -1;
        Long[] retArray = new Long[array.length - 1];
        for (int n = 0; n < retArray.length; n++) {
            if (n < index) {
                retArray[n] = array[n];
            } else {
                retArray[n] = array[n + 1];
            }
        }
        return retArray;
    }
",1
10581327,7,"    protected TreeMap addSubMenu(TreeMap in, String[] path, String id, String label) {
        if (path.length == 0) {
            XMLLine line = new XMLLine(Context.XML_TAG);
            line.setId(id);
            line.setLabel(label);
            in.put(line.getItemName(), line);
        } else {
            String currentPathComponent = path[0];
            String[] nextPath = new String[path.length - 1];
            for (int i = 0; i < path.length - 1; i++) {
                nextPath[i] = path[i + 1];
            }
            TreeMap nextTreeMap = (TreeMap) in.get(currentPathComponent);
            nextTreeMap = addSubMenu(nextTreeMap, nextPath, id, label);
            in.put(currentPathComponent, nextTreeMap);
        }
        return in;
    }
",1
8176618,7,"    protected static void zRoots(float[] coeffBuf, int coeffNum, float[] roots, boolean polish) {
        int i, j, jj;
        float bRe, bIm, cRe, cIm;
        int coeffNum2 = coeffNum << 1;
        float[] ad = new float[coeffNum2 + 2];
        float[] x = new float[2];
        System.arraycopy(coeffBuf, 0, ad, 0, coeffNum2 + 2);
        for (j = coeffNum2; j >= 2; j -= 2) {
            jj = j - 2;
            x[0] = 0.0f;
            x[1] = 0.0f;
            i = laguerre(ad, j >> 1, x);
            if (Math.abs(x[1]) <= EXPECTEDERROR2 * Math.abs(x[0])) {
                x[1] = 0.0f;
            }
            roots[jj] = x[0];
            roots[jj + 1] = x[1];
            bRe = ad[j];
            bIm = ad[j + 1];
            for (; jj >= 0; jj -= 2) {
                cRe = ad[jj];
                cIm = ad[jj + 1];
                ad[jj] = bRe;
                ad[jj + 1] = bIm;
                bRe = x[0] * bRe - x[1] * bIm + cRe;
                bIm = x[1] * bRe + x[0] * bIm + cIm;
            }
        }
        if (polish) {
            for (j = 0; j < coeffNum2; ) {
                x[0] = roots[j];
                x[1] = roots[j + 1];
                laguerre(coeffBuf, coeffNum, x);
                roots[j++] = x[0];
                roots[j++] = x[1];
            }
        }
        for (j = 2; j < coeffNum2; j += 2) {
            x[0] = roots[j];
            x[1] = roots[j + 1];
            for (i = j - 2; i >= 2; i -= 2) {
                if (roots[i] <= x[0]) break;
                roots[i + 2] = roots[i];
                roots[i + 3] = roots[i + 1];
            }
            roots[i + 2] = x[0];
            roots[i + 3] = x[1];
        }
    }
",1
196992,7,"    protected void analyzePixels() {
        System.out.println(""AnimatedGifEncoder.analyzePixels("" + "")"");
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
",1
6070324,7,"    private void removeChild(int i) throws SQLException {
        readAllRows();
        entryCount--;
        written = false;
        if (entryCount < 0) {
            Message.throwInternalError();
        }
        SearchRow[] newRows = PageStore.newSearchRows(entryCount);
        int[] newOffsets = MemoryUtils.newIntArray(entryCount);
        int[] newChildPageIds = new int[entryCount + 1];
        System.arraycopy(offsets, 0, newOffsets, 0, Math.min(entryCount, i));
        System.arraycopy(rows, 0, newRows, 0, Math.min(entryCount, i));
        System.arraycopy(childPageIds, 0, newChildPageIds, 0, i);
        if (entryCount > i) {
            System.arraycopy(rows, i + 1, newRows, i, entryCount - i);
            int startNext = i > 0 ? offsets[i - 1] : index.getPageStore().getPageSize();
            int rowLength = startNext - offsets[i];
            for (int j = i; j < entryCount; j++) {
                newOffsets[j] = offsets[j + 1] + rowLength;
            }
        }
        System.arraycopy(childPageIds, i + 1, newChildPageIds, i, entryCount - i + 1);
        offsets = newOffsets;
        rows = newRows;
        childPageIds = newChildPageIds;
        start -= CHILD_OFFSET_PAIR_LENGTH;
    }
",1
10874524,7,"    public static void exchange(int[] a, int i) {
        int temp;
        temp = a[i];
        a[i] = a[i + 1];
        a[i + 1] = temp;
    }
",0
12934519,7,"    public static Object3D extrudeMesh(TriangleMesh profile, Curve path, CoordinateSystem profCoords, CoordinateSystem pathCoords, double angle, boolean orient) {
        Vertex profVert[] = (Vertex[]) profile.getVertices();
        MeshVertex pathVert[] = path.getVertices();
        Edge profEdge[] = profile.getEdges();
        Face profFace[] = profile.getFaces();
        Vec3 profv[] = new Vec3[profVert.length], pathv[] = new Vec3[pathVert.length];
        Vec3 subdiv[], center, zdir[], updir[], t[], v[];
        float pathSmooth[] = path.getSmoothness();
        CoordinateSystem localCoords = new CoordinateSystem(new Vec3(), Vec3.vz(), Vec3.vy());
        Mat4 rotate;
        int numBoundaryEdges = 0, numBoundaryPoints = 0, i, j, k;
        int boundaryEdge[], boundaryPoint[];
        for (i = 0; i < profVert.length; i++) profv[i] = profCoords.fromLocal().timesDirection(profVert[i].r);
        for (i = 0; i < pathVert.length; i++) pathv[i] = pathCoords.fromLocal().timesDirection(pathVert[i].r);
        if (path.getSmoothingMethod() == Mesh.NO_SMOOTHING) for (i = 0; i < pathSmooth.length; i++) pathSmooth[i] = 0.0f;
        boolean onBound[] = new boolean[profv.length];
        for (i = 0; i < profEdge.length; i++) if (profEdge[i].f2 == -1) {
            numBoundaryEdges++;
            onBound[profEdge[i].v1] = onBound[profEdge[i].v2] = true;
        }
        for (i = 0; i < onBound.length; i++) if (onBound[i]) numBoundaryPoints++;
        boundaryEdge = new int[numBoundaryEdges];
        boundaryPoint = new int[numBoundaryPoints];
        for (i = 0, j = 0; i < profEdge.length; i++) if (profEdge[i].f2 == -1) boundaryEdge[j++] = i;
        for (i = 0, j = 0; i < onBound.length; i++) if (onBound[i]) boundaryPoint[j++] = i;
        boolean forward[] = new boolean[boundaryEdge.length];
        int edgeVertIndex[][] = new int[boundaryEdge.length][2];
        for (i = 0; i < boundaryEdge.length; i++) {
            Edge ed = profEdge[boundaryEdge[i]];
            Face fc = profFace[ed.f1];
            forward[i] = ((fc.v1 == ed.v1 && fc.v2 == ed.v2) || (fc.v2 == ed.v1 && fc.v3 == ed.v2) || (fc.v3 == ed.v1 && fc.v1 == ed.v2));
            for (j = 0; j < boundaryPoint.length; j++) {
                if (boundaryPoint[j] == ed.v1) edgeVertIndex[i][0] = j; else if (boundaryPoint[j] == ed.v2) edgeVertIndex[i][1] = j;
            }
        }
        int index[][];
        if (path.isClosed()) {
            index = new int[pathv.length + 1][boundaryPoint.length];
            for (i = 0; i < boundaryPoint.length; i++) {
                for (j = 0; j < pathv.length; j++) index[j][i] = j * boundaryPoint.length + i;
                index[j][i] = i;
            }
        } else {
            index = new int[pathv.length][boundaryPoint.length];
            for (i = 0; i < boundaryPoint.length; i++) {
                index[0][i] = boundaryPoint[i];
                index[pathv.length - 1][i] = boundaryPoint[i] + profv.length;
                for (j = 1; j < pathv.length - 1; j++) index[j][i] = (j - 1) * boundaryPoint.length + i + 2 * profv.length;
            }
        }
        subdiv = new Curve(pathv, pathSmooth, path.getSmoothingMethod(), path.isClosed()).subdivideCurve().getVertexPositions();
        t = new Vec3[subdiv.length];
        zdir = new Vec3[subdiv.length];
        updir = new Vec3[subdiv.length];
        t[0] = subdiv[1].minus(subdiv[0]);
        t[0].normalize();
        zdir[0] = Vec3.vz();
        updir[0] = Vec3.vy();
        Vec3 dir1, dir2;
        double zfrac1, zfrac2, upfrac1, upfrac2;
        zfrac1 = t[0].dot(zdir[0]);
        zfrac2 = Math.sqrt(1.0 - zfrac1 * zfrac1);
        dir1 = zdir[0].minus(t[0].times(zfrac1));
        dir1.normalize();
        upfrac1 = t[0].dot(updir[0]);
        upfrac2 = Math.sqrt(1.0 - upfrac1 * upfrac1);
        dir2 = updir[0].minus(t[0].times(upfrac1));
        dir2.normalize();
        for (i = 1; i < subdiv.length; i++) {
            if (i == subdiv.length - 1) {
                if (path.isClosed()) t[i] = subdiv[0].minus(subdiv[subdiv.length - 2]); else t[i] = subdiv[subdiv.length - 1].minus(subdiv[subdiv.length - 2]);
            } else t[i] = subdiv[i + 1].minus(subdiv[i - 1]);
            t[i].normalize();
            if (orient) {
                dir1 = dir1.minus(t[i].times(t[i].dot(dir1)));
                dir1.normalize();
                dir2 = dir2.minus(t[i].times(t[i].dot(dir2)));
                dir2.normalize();
                zdir[i] = t[i].times(zfrac1).plus(dir1.times(zfrac2));
                updir[i] = t[i].times(upfrac1).plus(dir2.times(upfrac2));
            } else {
                zdir[i] = zdir[i - 1];
                updir[i] = updir[i - 1];
            }
        }
        if (path.isClosed()) v = new Vec3[numBoundaryPoints * pathv.length]; else v = new Vec3[2 * profv.length + numBoundaryPoints * (pathv.length - 2)];
        Vector newEdge = new Vector(), newFace = new Vector();
        boolean angled = (profile.getSmoothingMethod() == Mesh.NO_SMOOTHING && path.getSmoothingMethod() != Mesh.NO_SMOOTHING);
        if (!path.isClosed()) {
            localCoords.setOrigin(pathv[0]);
            localCoords.setOrientation(zdir[0], updir[0]);
            for (i = 0; i < profv.length; i++) v[i] = localCoords.fromLocal().times(profv[i]);
            k = (pathv.length == subdiv.length ? pathv.length - 1 : 2 * (pathv.length - 1));
            localCoords.setOrigin(pathv[pathv.length - 1]);
            localCoords.setOrientation(zdir[k], updir[k]);
            if (angle != 0.0) {
                rotate = Mat4.axisRotation(t[k], angle);
                localCoords.transformAxes(rotate);
            }
            for (i = 0; i < profv.length; i++) v[i + profv.length] = localCoords.fromLocal().times(profv[i]);
            for (i = 0; i < profEdge.length; i++) {
                float smoothness = profEdge[i].smoothness;
                if (angled || profEdge[i].f2 == -1) smoothness = 0.0f;
                newEdge.addElement(new EdgeInfo(profEdge[i].v1, profEdge[i].v2, smoothness));
                newEdge.addElement(new EdgeInfo(profEdge[i].v1 + profv.length, profEdge[i].v2 + profv.length, smoothness));
            }
            for (i = 0; i < profFace.length; i++) {
                Face f = profFace[i];
                newFace.addElement(new int[] { f.v1, f.v2, f.v3 });
                newFace.addElement(new int[] { f.v1 + profv.length, f.v3 + profv.length, f.v2 + profv.length });
            }
        }
        for (i = 0; i < pathv.length; i++) {
            if (!path.isClosed() && i == pathv.length - 1) break;
            for (j = 0; j < boundaryEdge.length; j++) {
                int v1, v2;
                if (forward[j]) {
                    v1 = edgeVertIndex[j][0];
                    v2 = edgeVertIndex[j][1];
                } else {
                    v1 = edgeVertIndex[j][1];
                    v2 = edgeVertIndex[j][0];
                }
                newFace.addElement(new int[] { index[i][v1], index[i + 1][v1], index[i + 1][v2] });
                newFace.addElement(new int[] { index[i][v2], index[i][v1], index[i + 1][v2] });
                EdgeInfo ed1 = new EdgeInfo(index[i][v1], index[i + 1][v1], angled ? 0.0f : profVert[boundaryPoint[v1]].smoothness);
                newEdge.addElement(ed1);
                ed1 = new EdgeInfo(index[i][v2], index[i + 1][v2], angled ? 0.0f : profVert[boundaryPoint[v2]].smoothness);
                newEdge.addElement(ed1);
                ed1 = new EdgeInfo(index[i][v1], index[i + 1][v2], 1.0f);
                newEdge.addElement(ed1);
                if (path.isClosed() || i > 0) {
                    ed1 = new EdgeInfo(index[i][v1], index[i][v2], pathSmooth[i]);
                    newEdge.addElement(ed1);
                }
            }
            localCoords.setOrigin(pathv[i]);
            k = (pathv.length == subdiv.length ? i : 2 * i);
            localCoords.setOrientation(zdir[k], updir[k]);
            if (angle != 0.0) {
                rotate = Mat4.axisRotation(t[k], i * angle / (pathv.length - 1));
                localCoords.transformAxes(rotate);
            }
            for (j = 0; j < boundaryPoint.length; j++) v[index[i][j]] = localCoords.fromLocal().times(profv[boundaryPoint[j]]);
        }
        center = new Vec3();
        for (i = 0; i < v.length; i++) center.add(v[i]);
        center.scale(1.0 / v.length);
        for (i = 0; i < v.length; i++) v[i].subtract(center);
        int faces[][] = new int[newFace.size()][];
        for (i = 0; i < faces.length; i++) faces[i] = (int[]) newFace.elementAt(i);
        TriangleMesh mesh = new TriangleMesh(v, faces);
        Edge meshEdge[] = mesh.getEdges();
        for (i = 0; i < newEdge.size(); i++) {
            EdgeInfo info = (EdgeInfo) newEdge.elementAt(i);
            if (info.smoothness == 1.0f) continue;
            for (j = 0; j < meshEdge.length; j++) if ((meshEdge[j].v1 == info.v1 && meshEdge[j].v2 == info.v2) || (meshEdge[j].v1 == info.v2 && meshEdge[j].v2 == info.v1)) meshEdge[j].smoothness = info.smoothness;
        }
        mesh.setSmoothingMethod(Math.max(profile.getSmoothingMethod(), path.getSmoothingMethod()));
        mesh.makeRightSideOut();
        return mesh;
    }
",1
762668,7,"    private void compileBootImage(String args[]) {
        String bi_args[] = new String[args.length - 1];
        String bi_name = args[args.length - 1];
        Class pub_cl;
        Object pub_obj;
        java.lang.reflect.Method pub_methods[];
        jdp_console.writeOutput(""Compiling Boot Image for "" + bi_name + "" . . . "");
        for (int i = 0; i < bi_args.length; i++) {
            bi_args[i] = args[i + 1];
        }
        try {
            pub_cl = Class.forName(args[0]);
            pub_obj = pub_cl.newInstance();
            pub_methods = pub_cl.getMethods();
            for (int n = 0; n < pub_methods.length; n++) {
                if (pub_methods[n].getName().equals(""main"")) {
                    Object invoke_args[] = { bi_args };
                    pub_methods[n].invoke(pub_obj, invoke_args);
                    return;
                }
            }
        } catch (ClassNotFoundException e) {
            jdp_console.writeOutput(""cannot compile, publicizing class loader not found: "" + args[0]);
            System.exit(1);
        } catch (InstantiationException e1) {
            jdp_console.writeOutput(""cannot compile, problem instantiating class"");
            System.exit(1);
        } catch (IllegalAccessException e2) {
            jdp_console.writeOutput(""cannot compile, illegal access to class"");
            System.exit(1);
        } catch (InvocationTargetException e3) {
            jdp_console.writeOutput(""cannot compile, Invocation Target Exception:"");
            jdp_console.writeOutput(e3.getMessage());
            System.exit(1);
        }
    }
",1
9675728,7,"    public final synchronized boolean remove(ElementGroup group) {
        for (int i = 0; i < layerSize; i++) {
            if (params[i] == group) {
                for (int j = i; j < topLayer; j++) {
                    params[j] = params[j + 1];
                }
                layerSize--;
                topLayer = layerSize - 1;
                return true;
            }
        }
        return false;
    }
",1
17455223,7,"    private static RandomPolygon newInstance(int x, int y, double minDistance, int minSides, int maxSides, double minArea, double maxArea) {
        if (rand == null) rand = new Random();
        LinkedList<RandomPolygon> stack = new LinkedList<RandomPolygon>();
        HashSet<RandomPolygon> alreadySearched = new HashSet<RandomPolygon>();
        stack.add(new RandomPolygon(new int[] { x + 0, x + 5, x + 10 }, new int[] { y + 0, y + 10, y + 0 }, 3));
        while (!stack.isEmpty()) {
            RandomPolygon node = stack.removeFirst();
            double area = node.calculateArea();
            if (node.npoints >= minSides && node.npoints <= maxSides && area >= minArea && area <= maxArea) {
                boolean pointsAreValid = true;
                for (int edge = 0; edge < node.npoints && pointsAreValid; edge++) {
                    int x1 = node.xpoints[edge];
                    int y1 = node.ypoints[edge];
                    int x2 = (edge == node.npoints - 1 ? node.xpoints[0] : node.xpoints[edge + 1]);
                    int y2 = (edge == node.npoints - 1 ? node.ypoints[0] : node.ypoints[edge + 1]);
                    for (int point = 0; point < node.npoints && pointsAreValid; point++) {
                        if (point == edge || (edge == node.npoints - 1 && point == 0) || (edge < node.npoints - 1 && point == edge + 1)) continue;
                        int px = node.xpoints[point];
                        int py = node.ypoints[point];
                        double distance = Line2D.ptSegDist((double) x1, (double) y1, (double) x2, (double) y2, (double) px, (double) py);
                        if (distance < minDistance) {
                            System.err.println(""("" + px + "", "" + py + "") is too close to ("" + x1 + "", "" + y1 + "")-("" + x2 + "", "" + y2 + "")"");
                            pointsAreValid = false;
                        }
                    }
                }
                if (pointsAreValid) return node;
            }
            ArrayList<RandomPolygon> successors = new ArrayList<RandomPolygon>();
            ArrayList<RandomPolygon> topSuccessors = new ArrayList<RandomPolygon>();
            double centroid[] = node.calculateCentroid();
            System.err.println(""Centroid: ("" + centroid[0] + "", "" + centroid[1] + "")"");
            for (int i = 1; i < node.npoints; i++) {
                double xdiff = (double) node.xpoints[i] - centroid[0];
                double ydiff = (double) node.ypoints[i] - centroid[1];
                double angle;
                if (xdiff == 0) angle = Math.PI / 2.0; else angle = Math.atan(ydiff / xdiff);
                int newX = node.xpoints[i] + (int) (2.0 * Math.cos(angle));
                int newY = node.ypoints[i] + (int) (2.0 * Math.sin(angle));
                boolean alreadyExists = false;
                for (int j = 0; j < node.npoints && !alreadyExists; j++) if (newX == node.xpoints[j] && newY == node.ypoints[j]) alreadyExists = true;
                if (alreadyExists) continue;
                System.err.println(""Moving ("" + node.xpoints[i] + "", "" + node.ypoints[i] + "") --> ("" + newX + "", "" + newY + "")"");
                int xpoints[] = new int[node.npoints];
                int ypoints[] = new int[node.npoints];
                for (int j = 0; j < node.npoints; j++) {
                    if (j == i) {
                        xpoints[j] = newX;
                        ypoints[j] = newY;
                    } else {
                        xpoints[j] = node.xpoints[j];
                        ypoints[j] = node.ypoints[j];
                    }
                }
                RandomPolygon newSuccessor = new RandomPolygon(xpoints, ypoints, node.npoints);
                if (calculateArea(newSuccessor) <= maxArea) {
                    boolean pointIsValid = true;
                    for (int edge = 0; edge < node.npoints && pointIsValid; edge++) {
                        int x1 = node.xpoints[edge];
                        int y1 = node.ypoints[edge];
                        int x2 = (edge == node.npoints - 1 ? node.xpoints[0] : node.xpoints[edge + 1]);
                        int y2 = (edge == node.npoints - 1 ? node.ypoints[0] : node.ypoints[edge + 1]);
                        if (i == edge || (edge == node.npoints - 1 && i == 0) || (edge < node.npoints - 1 && i == edge + 1)) continue;
                        int px = node.xpoints[i];
                        int py = node.ypoints[i];
                        double distance = Line2D.ptSegDist((double) x1, (double) y1, (double) x2, (double) y2, (double) px, (double) py);
                        if (distance < minDistance) {
                            System.err.println(""("" + px + "", "" + py + "") is too close to ("" + x1 + "", "" + y1 + "")-("" + x2 + "", "" + y2 + "")"");
                            pointIsValid = false;
                        }
                    }
                    if (!pointIsValid) topSuccessors.add(newSuccessor); else successors.add(newSuccessor);
                }
            }
            if (node.npoints < maxSides) {
                int numSuccessors = node.npoints / 2;
                double boundaryLength = node.calculateBoundaryLength();
                for (int i = 0; i < numSuccessors; i++) {
                    double distance = boundaryLength * rand.nextDouble();
                    int point[] = node.getPointOnPerimeter(distance);
                    int idx = point[2] + 1;
                    System.err.println(""Adding a new point (index "" + idx + "") at ("" + point[0] + "", "" + point[1] + "")"");
                    int xpoints[] = new int[node.npoints + 1];
                    int ypoints[] = new int[node.npoints + 1];
                    for (int j = 0; j <= node.npoints; j++) {
                        if (j < idx) {
                            xpoints[j] = node.xpoints[j];
                            ypoints[j] = node.ypoints[j];
                        } else if (j == idx) {
                            xpoints[j] = point[0];
                            ypoints[j] = point[1];
                        } else {
                            xpoints[j] = node.xpoints[j - 1];
                            ypoints[j] = node.ypoints[j - 1];
                        }
                    }
                    successors.add(new RandomPolygon(xpoints, ypoints, node.npoints + 1));
                }
            }
            for (int successorList = 0; successorList < 2; successorList++) {
                ArrayList<RandomPolygon> succ;
                switch(successorList) {
                    case 0:
                        succ = successors;
                        break;
                    case 1:
                    default:
                        succ = topSuccessors;
                        break;
                }
                int remaining[] = new int[succ.size()];
                for (int i = 0; i < remaining.length; i++) remaining[i] = i;
                for (int i = 0; i < remaining.length; i++) {
                    int chosen = rand.nextInt(remaining.length - i);
                    RandomPolygon successor = succ.get(remaining[chosen]);
                    if (!alreadySearched.contains(successor)) {
                        alreadySearched.add(successor);
                        stack.addFirst(successor);
                    }
                    for (int j = chosen; j < remaining.length - i - 1; j++) remaining[j] = remaining[j + 1];
                }
            }
        }
        return null;
    }
",1
18581041,7,"    private static void swapBytes(byte[] b, int off, int len) {
        byte tempByte;
        for (int i = off; i < (off + len); i += 2) {
            tempByte = b[i];
            b[i] = b[i + 1];
            b[i + 1] = tempByte;
        }
    }
",1
20281038,7,"    public static FileStorageModel create(FileSystem root, String template) {
        if (template.startsWith(""/"")) template = template.substring(1);
        String[] s = template.split(""%"");
        char[] valid_formatCodes = new char[] { 'Y', 'y', 'j', 'm', 'd', 'H', 'M', 'S', 'v', 'V', 'x', 'b' };
        String[] formatName = new String[] { ""Year"", ""2-digit-year"", ""day-of-year"", ""month"", ""day"", ""Hour"", ""Minute"", ""Second"", ""version"", ""Version"", ""date"", ""month-name"" };
        int[] formatCode_lengths = new int[] { 4, 2, 3, 2, 2, 2, 2, 2, -1, -1, -1, -1 };
        int[] formatDigit = new int[] { StartYear4, StartYear2, StartDoy, StartMonth, StartDay, StartHour, StartMinute, StartSecond, Ignore, Ignore, Ignore, StartMonthName };
        int n = s.length;
        StringBuffer regex = new StringBuffer(100);
        regex.append(s[0]);
        int[] positions = new int[20];
        positions[0] = 0;
        int[] dateFormat = new int[n - 1];
        int[] p = new int[20];
        p[0] = 0;
        p[1] = s[0].length();
        boolean versioning = false;
        for (int i = 1; i < n; i++) {
            char firstChar = s[i].charAt(0);
            int len = -1;
            char fc = s[i].charAt(0);
            int index = -1;
            for (int j = 0; j < valid_formatCodes.length; j++) if (valid_formatCodes[j] == fc) index = j;
            String cc = s[i].substring(1);
            if (index == -1) {
                throw new IllegalArgumentException(""invalid format code: "" + fc);
            } else {
                String fieldName = formatName[index];
            }
            if (len == -1) len = formatCode_lengths[index];
            if (len == -1 && cc.equals("""") && i < n - 1) {
                throw new IllegalArgumentException(""invalid variable specification, need non-null constant string to delineate"");
            }
            if (fc == 'v' || fc == 'V') versioning = true;
            String dots = ""........."";
            regex.append(""("" + dots.substring(0, len) + "")"");
            regex.append(cc);
            dateFormat[i - 1] = formatDigit[index];
            p[i + 1] = p[i] + s[i].length() + 1;
            positions[i] = p[i + 1] - cc.length();
        }
        return FileStorageModel.create(root, regex.toString(), dateFormat);
    }
",1
17588086,7,"    private static double[][][] createStandardEllipsoid(int nr, int nu, int nv, double angleu1, double angleu2, double anglev1, double anglev2, boolean top, boolean bottom, boolean left, boolean right) {
        int totalN = nu * nv;
        if (Math.abs(anglev2 - anglev1) < 180) {
            if (bottom) {
                totalN += nr * nu;
            }
            if (top) {
                totalN += nr * nu;
            }
        }
        if (Math.abs(angleu2 - angleu1) < 360) {
            if (left) {
                totalN += nr * nv;
            }
            if (right) {
                totalN += nr * nv;
            }
        }
        double[][][] data = new double[totalN][4][3];
        double[] cosu = new double[nu + 1], sinu = new double[nu + 1];
        double[] cosv = new double[nv + 1], sinv = new double[nv + 1];
        for (int u = 0; u <= nu; u++) {
            double angle = ((nu - u) * angleu1 + u * angleu2) * TO_RADIANS / nu;
            cosu[u] = Math.cos(angle);
            sinu[u] = Math.sin(angle);
        }
        for (int v = 0; v <= nv; v++) {
            double angle = ((nv - v) * anglev1 + v * anglev2) * TO_RADIANS / nv;
            cosv[v] = Math.cos(angle) / 2;
            sinv[v] = Math.sin(angle) / 2;
        }
        int tile = 0;
        double[] center = new double[] { 0, 0, 0 };
        {
            for (int v = 0; v < nv; v++) {
                for (int u = 0; u < nu; u++, tile++) {
                    for (int k = 0; k < 3; k++) {
                        data[tile][0][k] = (cosu[u] * vectorx[k] + sinu[u] * vectory[k]) * cosv[v] + sinv[v] * vectorz[k];
                        data[tile][1][k] = (cosu[u + 1] * vectorx[k] + sinu[u + 1] * vectory[k]) * cosv[v] + sinv[v] * vectorz[k];
                        data[tile][2][k] = (cosu[u + 1] * vectorx[k] + sinu[u + 1] * vectory[k]) * cosv[v + 1] + sinv[v + 1] * vectorz[k];
                        data[tile][3][k] = (cosu[u] * vectorx[k] + sinu[u] * vectory[k]) * cosv[v + 1] + sinv[v + 1] * vectorz[k];
                    }
                }
            }
        }
        if (Math.abs(anglev2 - anglev1) < 180) {
            if (bottom) {
                center[2] = sinv[0];
                for (int u = 0; u < nu; u++) {
                    for (int i = 0; i < nr; i++, tile++) {
                        for (int k = 0; k < 3; k++) {
                            data[tile][0][k] = ((nr - i) * center[k] + i * data[u][0][k]) / nr;
                            data[tile][1][k] = ((nr - i - 1) * center[k] + (i + 1) * data[u][0][k]) / nr;
                            data[tile][2][k] = ((nr - i - 1) * center[k] + (i + 1) * data[u][1][k]) / nr;
                            data[tile][3][k] = ((nr - i) * center[k] + i * data[u][1][k]) / nr;
                        }
                    }
                }
            }
            if (top) {
                center[2] = sinv[nv];
                int ref = nu * (nv - 1);
                for (int u = 0; u < nu; u++) {
                    for (int i = 0; i < nr; i++, tile++) {
                        for (int k = 0; k < 3; k++) {
                            data[tile][0][k] = ((nr - i) * center[k] + i * data[ref + u][3][k]) / nr;
                            data[tile][1][k] = ((nr - i - 1) * center[k] + (i + 1) * data[ref + u][3][k]) / nr;
                            data[tile][2][k] = ((nr - i - 1) * center[k] + (i + 1) * data[ref + u][2][k]) / nr;
                            data[tile][3][k] = ((nr - i) * center[k] + i * data[ref + u][2][k]) / nr;
                        }
                    }
                }
            }
        }
        if (Math.abs(angleu2 - angleu1) < 360) {
            double[] nextCenter = new double[] { 0, 0, 0 };
            if (right) {
                int ref = 0;
                for (int j = 0; j < nv; j++, ref += nu) {
                    center[2] = sinv[j];
                    nextCenter[2] = sinv[j + 1];
                    for (int i = 0; i < nr; i++, tile++) {
                        for (int k = 0; k < 3; k++) {
                            data[tile][0][k] = ((nr - i) * center[k] + i * data[ref][0][k]) / nr;
                            data[tile][1][k] = ((nr - i - 1) * center[k] + (i + 1) * data[ref][0][k]) / nr;
                            data[tile][2][k] = ((nr - i - 1) * nextCenter[k] + (i + 1) * data[ref][3][k]) / nr;
                            data[tile][3][k] = ((nr - i) * nextCenter[k] + i * data[ref][3][k]) / nr;
                        }
                    }
                }
            }
            if (left) {
                int ref = nu - 1;
                for (int j = 0; j < nv; j++, ref += nu) {
                    center[2] = sinv[j];
                    nextCenter[2] = sinv[j + 1];
                    for (int i = 0; i < nr; i++, tile++) {
                        for (int k = 0; k < 3; k++) {
                            data[tile][0][k] = ((nr - i) * center[k] + i * data[ref][1][k]) / nr;
                            data[tile][1][k] = ((nr - i - 1) * center[k] + (i + 1) * data[ref][1][k]) / nr;
                            data[tile][2][k] = ((nr - i - 1) * nextCenter[k] + (i + 1) * data[ref][2][k]) / nr;
                            data[tile][3][k] = ((nr - i) * nextCenter[k] + i * data[ref][2][k]) / nr;
                        }
                    }
                }
            }
        }
        return data;
    }
",0
10407212,7,"    public final void removeElementAt(int id) {
        if (id >= 0) {
            for (int i = id; i < current_item - 1; i++) items[i] = items[i + 1];
            items[current_item - 1] = null;
        } else items[0] = null;
        current_item--;
    }
",0
55097,7,"    private void popCommand() {
        numberCommands--;
        int i = 0;
        for (i = 0; i < numberCommands; i++) {
            commands[i] = commands[i + 1];
        }
        commands[++i] = null;
    }
",1
16820487,7,"    public static double[] arrayShiftLeft(double[] x) {
        double[] temp = new double[x.length - 1];
        for (int i = 0; i < x.length; i++) {
            temp[i] = x[i + 1];
        }
        x = temp;
        return x;
    }
",1
23433758,7,"    public static byte[] shiftLeft(final byte[] data, final int bits) {
        if (bits <= 0) {
            return data;
        }
        int d = 0;
        if (data.length == 1) {
            if (bits <= 8) {
                d = data[0] & 0xFF;
                d <<= bits;
                data[0] = (byte) d;
            } else {
                data[0] = 0;
            }
        } else if (data.length > 1) {
            int carry = 0;
            if (bits < 8) {
                for (int i = 0; i < data.length - 1; ++i) {
                    carry = data[i + 1] & (1 >>> (8 - bits));
                    d = data[i] & 0xFF;
                    d <<= bits;
                    d |= carry;
                    data[i] = (byte) d;
                }
                d = data[data.length - 1] & 0xFF;
                d <<= bits;
                data[data.length - 1] = (byte) d;
            } else {
                for (int i = 0; i < data.length - 1; ++i) {
                    data[i] = data[i + 1];
                }
                data[data.length - 1] = 0;
                shiftLeft(data, bits - 8);
            }
        }
        return data;
    }
",1
17323499,7,"    public static PredictionData deserialize(File dbFile) throws IOException, DataFileException {
        if ((dbFile == null) || (!dbFile.exists())) {
            return null;
        }
        FileInputStream fis = new FileInputStream(dbFile);
        CsvReader reader = new CsvReader(fis);
        String[] values = reader.getNextValidLine();
        int peptideCount = Integer.parseInt(values[0]);
        int initialCapacity = 5 * peptideCount / 4;
        int alleleCount = values.length - 1;
        String[] alleles = new String[alleleCount];
        for (int i = 0; i < alleleCount; i++) {
            alleles[i] = values[i + 1];
        }
        PredictionData result = new PredictionData(alleles, initialCapacity);
        while ((values = reader.getNextValidLine()) != null) {
            if (values.length != alleleCount + 1) {
                throw new DataFileException(""Error at line "" + reader.getLineNumber() + "" of file "" + dbFile.getCanonicalPath() + "": incorrect number of values, expected "" + (alleleCount + 1) + "", found "" + values.length);
            }
            String peptide = values[0];
            float[] predValues = new float[alleles.length];
            for (int i = 0; i < alleleCount; i++) {
                predValues[i] = PredictionData.NO_PREDICTION;
                String valueString = values[i + 1];
                if ((valueString != null) && (valueString.length() > 0)) {
                    try {
                        predValues[i] = Float.parseFloat(valueString);
                    } catch (Exception e) {
                        throw new DataFileException(""Error at line "" + reader.getLineNumber() + "" of file "" + dbFile.getCanonicalPath() + "": value for "" + alleles[i] + "" is not a valid number. Value found: "" + valueString);
                    }
                }
            }
            result.setPredictions(peptide, predValues);
        }
        fis.close();
        return result;
    }
",1
17624949,7,"        public double teachLayer(InputLayer iLayer) {
            double squareError, error;
            Neuron swap;
            int lastIndex;
            boolean anyChange;
            int vTest = (int) (group * (c.getVectorsInTestingSet() / 100.0));
            int rVector;
            job = ENTERING_PASSIVE_MODE;
            mode = PASSIVE;
            myRandom.resetRandom();
            for (int i = 0; i < group - vTest; i++) {
                rVector = myRandom.getRandomLearningVector();
                iLayer.setActualVector(rVector);
                layerProgress = (int) (100.0 * i / (double) (group - vTest - 1));
                if (layerProgress % 100 == 1) {
                    myGraph.redraw();
                }
                prevLayer.computeOutputs();
                for (int act = 0; act < inumber; act++) {
                    n[act].storeInputValue(rVector);
                }
            }
            myGraph.redraw();
            mode = ACTIVE;
            job = NEW_NEURON;
            for (int act = 0; act < inumber; act++) {
                actualNeuron = act;
                n[act].learnYourself((Unit) n[act]);
            }
            job = ERROR_COMPUTING;
            myRandom.resetRandom();
            for (int i = 0; i < group; i++) {
                rVector = 0;
                if (i < group - vTest) {
                    rVector = myRandom.getRandomLearningVector();
                }
                if (i == group - vTest) {
                    myRandom.resetRandom();
                }
                if (i >= group - vTest) {
                    rVector = myRandom.getRandomTestingVector();
                }
                iLayer.setActualVector(rVector);
                mode = PASSIVE;
                prevLayer.computeOutputs();
                for (int act = 0; act < inumber; act++) {
                    error = n[act].getError(rVector);
                    n[act].setSquareError(n[act].getSquareError() + error * error);
                    layerProgress = (int) (100.0 * (i + (double) act / (double) (inumber - 1)) / (double) (group));
                }
                if (layerProgress % 100 == 1) {
                    myGraph.redraw();
                }
                mode = ACTIVE;
            }
            myGraph.redraw();
            job = NEURONS_SORTING;
            lastIndex = inumber - 1;
            do {
                anyChange = false;
                for (int i = 0; i < lastIndex; i++) {
                    if (n[i].getSquareError() > n[i + 1].getSquareError()) {
                        anyChange = true;
                        swap = n[i];
                        n[i] = n[i + 1];
                        n[i + 1] = swap;
                    }
                }
                lastIndex--;
                layerProgress = 100 * (inumber - lastIndex - 1) / (inumber - 1);
                if (layerProgress % 100 == 1) {
                    myGraph.redraw();
                }
            } while (anyChange);
            layerProgress = 100;
            myGraph.redraw();
            job = NONE;
            for (int i = number; i < inumber; i++) {
                n[i] = null;
            }
            if (c.isCommonResponse()) {
                double ret = 0, div = 0;
                for (int i = 0; i < number; i++) {
                    ret += (number - i) * (number - i) * n[i].getSquareError();
                    div += (number - i) * (number - i);
                }
                return ret / div;
            }
            return n[0].getSquareError();
        }
",1
12269404,7,"    private void newCluster() {
        for (int k = 0; k < numClusters; k++) {
            if (k != besti && k != bestj) {
                int ak = alias[k];
                distance[ak][abi] = distance[abi][ak] = updatedDistance(besti, bestj, k);
            }
        }
        distance[abi][abi] = 0.0;
        NodeUtils.joinChilds(getRoot(), besti, bestj);
        for (int i = bestj; i < numClusters - 1; i++) {
            alias[i] = alias[i + 1];
        }
        numClusters--;
    }
",1
52177,7,"    void removeBall(int index) {
        int npoints = all_x.length;
        int[] temp_all_x = new int[npoints - 1];
        int[] temp_all_y = new int[npoints - 1];
        double[] temp_all_radii = new double[npoints - 1];
        for (int i = 0; i < index; i++) {
            temp_all_x[i] = all_x[i];
            temp_all_y[i] = all_y[i];
            temp_all_radii[i] = all_radii[i];
        }
        for (int j = index; j < npoints - 1; j++) {
            temp_all_x[j] = all_x[j + 1];
            temp_all_y[j] = all_y[j + 1];
            temp_all_radii[j] = all_radii[j + 1];
        }
        all_x = temp_all_x;
        all_y = temp_all_y;
        all_radii = temp_all_radii;
    }
",1
17356254,7,"    protected void computeCoefficients() throws ArithmeticException {
        int i, j, n;
        double c[], tc[], d, t;
        n = degree() + 1;
        coefficients = new double[n];
        for (i = 0; i < n; i++) {
            coefficients[i] = 0.0;
        }
        c = new double[n + 1];
        c[0] = 1.0;
        for (i = 0; i < n; i++) {
            for (j = i; j > 0; j--) {
                c[j] = c[j - 1] - c[j] * x[i];
            }
            c[0] *= (-x[i]);
            c[i + 1] = 1;
        }
        tc = new double[n];
        for (i = 0; i < n; i++) {
            d = 1;
            for (j = 0; j < n; j++) {
                if (i != j) {
                    d *= (x[i] - x[j]);
                }
            }
            if (d == 0.0) {
                throw new ArithmeticException(""Identical abscissas cause division by zero."");
            }
            t = y[i] / d;
            tc[n - 1] = c[n];
            coefficients[n - 1] += t * tc[n - 1];
            for (j = n - 2; j >= 0; j--) {
                tc[j] = c[j + 1] + tc[j + 1] * x[i];
                coefficients[j] += t * tc[j];
            }
        }
        coefficientsComputed = true;
    }
",0
318065,7,"    private void compileBootImage(String args[]) {
        String bi_args[] = new String[args.length - 1];
        String bi_name = args[args.length - 1];
        Class pub_cl;
        Object pub_obj;
        java.lang.reflect.Method pub_methods[];
        jdp_console.writeOutput(""Compiling Boot Image for "" + bi_name + "" . . . "");
        for (int i = 0; i < bi_args.length; i++) {
            bi_args[i] = args[i + 1];
        }
        try {
            pub_cl = Class.forName(args[0]);
            pub_obj = pub_cl.newInstance();
            pub_methods = pub_cl.getMethods();
            for (int n = 0; n < pub_methods.length; n++) {
                if (pub_methods[n].getName().equals(""main"")) {
                    Object invoke_args[] = { bi_args };
                    pub_methods[n].invoke(pub_obj, invoke_args);
                    return;
                }
            }
        } catch (ClassNotFoundException e) {
            jdp_console.writeOutput(""cannot compile, publicizing class loader not found: "" + args[0]);
            System.exit(1);
        } catch (InstantiationException e1) {
            jdp_console.writeOutput(""cannot compile, problem instantiating class"");
            System.exit(1);
        } catch (IllegalAccessException e2) {
            jdp_console.writeOutput(""cannot compile, illegal access to class"");
            System.exit(1);
        } catch (InvocationTargetException e3) {
            jdp_console.writeOutput(""cannot compile, Invocation Target Exception:"");
            jdp_console.writeOutput(e3.getMessage());
            System.exit(1);
        }
    }
",1
20738393,7,"    public void dTestDataStructures() {
        int i;
        printf(""testDynamicsStuff()\n"");
        DxBody[] body = new DxBody[NUM];
        int nb = 0;
        DxJoint[] joint = new DxJoint[NUM];
        int nj = 0;
        for (i = 0; i < NUM; i++) body[i] = null;
        for (i = 0; i < NUM; i++) joint[i] = null;
        printf(""creating world\n"");
        DxWorld w = DxWorld.dWorldCreate();
        checkWorld(w);
        for (; ; ) {
            if (nb < NUM && dRandReal() > 0.5) {
                printf(""creating body\n"");
                body[nb] = DxBody.dBodyCreate(w);
                printf(""\t--> %p\n"", body[nb].toString());
                nb++;
                checkWorld(w);
                printf(""%d BODIES, %d JOINTS\n"", nb, nj);
            }
            if (nj < NUM && nb > 2 && dRandReal() > 0.5) {
                DxBody b1 = (DxBody) body[(int) (dRand() % nb)];
                DxBody b2 = (DxBody) body[(int) (dRand() % nb)];
                if (b1 != b2) {
                    printf(""creating joint, attaching to %p,%p\n"", b1, b2);
                    joint[nj] = dJointCreateBall(w, null);
                    printf(""\t-->%p\n"", joint[nj]);
                    checkWorld(w);
                    joint[nj].dJointAttach(b1, b2);
                    nj++;
                    checkWorld(w);
                    printf(""%d BODIES, %d JOINTS\n"", nb, nj);
                }
            }
            if (nj > 0 && nb > 2 && dRandReal() > 0.5) {
                DxBody b1 = body[(int) (dRand() % nb)];
                DxBody b2 = body[(int) (dRand() % nb)];
                if (b1 != b2) {
                    int k = (int) (dRand() % nj);
                    printf(""reattaching joint %p\n"", joint[k]);
                    joint[k].dJointAttach(b1, b2);
                    checkWorld(w);
                    printf(""%d BODIES, %d JOINTS\n"", nb, nj);
                }
            }
            if (nb > 0 && dRandReal() > 0.5) {
                int k = (int) (dRand() % nb);
                printf(""destroying body %p\n"", body[k]);
                body[k].dBodyDestroy();
                checkWorld(w);
                for (; k < (NUM - 1); k++) body[k] = body[k + 1];
                nb--;
                printf(""%d BODIES, %d JOINTS\n"", nb, nj);
            }
            if (nj > 0 && dRandReal() > 0.5) {
                int k = (int) (dRand() % nj);
                printf(""destroying joint %p\n"", joint[k]);
                dJointDestroy(joint[k]);
                checkWorld(w);
                for (; k < (NUM - 1); k++) joint[k] = joint[k + 1];
                nj--;
                printf(""%d BODIES, %d JOINTS\n"", nb, nj);
            }
        }
    }
",1
5939463,7,"    static void getByteSwapped(byte[] b, int off, int len) {
        byte tempByte;
        for (int i = off; i < (off + len); i += 2) {
            tempByte = b[i];
            b[i] = b[i + 1];
            b[i + 1] = tempByte;
        }
    }
",1
16035291,7,"    private void condenseArray(int start) {
        for (int i = start; i < size; i++) {
            values[i] = values[i + 1];
        }
    }
",0
468621,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
5362350,7,"    private CommandLine parseCommandLine(TclObject argv[]) throws ParseException {
        String[] args = new String[argv.length - 1];
        for (int i = 0; i < argv.length - 1; i++) args[i] = argv[i + 1].toString();
        CommandLine cl = (new PosixParser()).parse(this.opts, args);
        return cl;
    }
",1
16723070,7,"    public MultipleGradientPaintContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform t, RenderingHints hints, float[] fractions, Color[] colors, MultipleGradientPaint.CycleMethodEnum cycleMethod, MultipleGradientPaint.ColorSpaceEnum colorSpace) throws NoninvertibleTransformException {
        boolean fixFirst = false;
        boolean fixLast = false;
        int len = fractions.length;
        if (fractions[0] != 0f) {
            fixFirst = true;
            len++;
        }
        if (fractions[fractions.length - 1] != 1f) {
            fixLast = true;
            len++;
        }
        for (int i = 0; i < fractions.length - 1; i++) if (fractions[i] == fractions[i + 1]) len--;
        this.fractions = new float[len];
        Color[] loColors = new Color[len - 1];
        Color[] hiColors = new Color[len - 1];
        normalizedIntervals = new float[len - 1];
        gradientUnderflow = colors[0].getRGB();
        gradientOverflow = colors[colors.length - 1].getRGB();
        int idx = 0;
        if (fixFirst) {
            this.fractions[0] = 0;
            loColors[0] = colors[0];
            hiColors[0] = colors[0];
            normalizedIntervals[0] = fractions[0];
            idx++;
        }
        for (int i = 0; i < fractions.length - 1; i++) {
            if (fractions[i] == fractions[i + 1]) {
                if (!colors[i].equals(colors[i + 1])) {
                    hasDiscontinuity = true;
                }
                continue;
            }
            this.fractions[idx] = fractions[i];
            loColors[idx] = colors[i];
            hiColors[idx] = colors[i + 1];
            normalizedIntervals[idx] = fractions[i + 1] - fractions[i];
            idx++;
        }
        this.fractions[idx] = fractions[fractions.length - 1];
        if (fixLast) {
            loColors[idx] = hiColors[idx] = colors[colors.length - 1];
            normalizedIntervals[idx] = 1 - fractions[fractions.length - 1];
            idx++;
            this.fractions[idx] = 1;
        }
        AffineTransform tInv = t.createInverse();
        double m[] = new double[6];
        tInv.getMatrix(m);
        a00 = (float) m[0];
        a10 = (float) m[1];
        a01 = (float) m[2];
        a11 = (float) m[3];
        a02 = (float) m[4];
        a12 = (float) m[5];
        this.cycleMethod = cycleMethod;
        this.colorSpace = colorSpace;
        if (cm.getColorSpace() == lrgbmodel_A.getColorSpace()) dataModel = lrgbmodel_A; else if (cm.getColorSpace() == srgbmodel_A.getColorSpace()) dataModel = srgbmodel_A; else throw new IllegalArgumentException(""Unsupported ColorSpace for interpolation"");
        calculateGradientFractions(loColors, hiColors);
        model = GraphicsUtil.coerceColorModel(dataModel, cm.isAlphaPremultiplied());
    }
",1
17212124,7,"    public void moveEvent(ScrEvent event, int newTime) {
        int index = indexOf(event);
        int newIndex = getIndexAfter(newTime);
        if (newIndex == NO_SUCH_EVENT) newIndex = events_fill_p - 1; else if (event.getTime() <= newTime) newIndex -= 1;
        if (index == NO_SUCH_EVENT) {
            System.err.println(""no such event error"");
            for (int i = 0; i < length(); i++) {
                System.err.println(""#"" + i + "" t "" + getEventAt(i).getTime() + "" p "" + getEventAt(i).getPitch());
            }
            return;
        }
        if (index == EMPTY_COLLECTION) index = 0;
        event.setTime(newTime);
        remoteCall(REMOTE_CHANGE, index, event.getTime(), event.getPitch(), event.getVelocity(), event.getDuration(), event.getChannel());
        if (index < newIndex) {
            for (int i = index; i < newIndex; i++) {
                events[i] = events[i + 1];
            }
        } else {
            for (int i = index; i > newIndex; i--) {
                events[i] = events[i - 1];
            }
            events[newIndex] = event;
        }
        events[newIndex] = event;
        notifyObjectMoved(event, index, newIndex);
    }
",0
534601,7,"    public void readCommand(OsProcess proc) {
        String str;
        user = proc;
        if (rawTTY) str = readFromRawTTY(); else str = readFromCookedTTY();
        String[] words = toArgs(str);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
",1
195722,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
18941000,7,"    protected int[] getNumericInputAttributeIndices() {
        int[] indices = store.getInputAttributesIndices();
        for (int i = 0; i < indices.length; i++) {
            if (store.getAttributeType(i) != PreprocessingStorage.DataType.NUMERIC) {
                logger.warn(""Implemented outlier detection methods can not work on non-numeric game.data :(. Skipping attribute "" + store.getAttributeName(i));
                int[] newIndices = new int[indices.length - 1];
                for (int j = 0; j < newIndices.length; j++) {
                    if (j < i) newIndices[j] = indices[j]; else newIndices[j] = indices[j + 1];
                }
                indices = newIndices;
                i--;
            }
        }
        return indices;
    }
",1
1981171,7,"    private VisADLineArray makeTrack(float[][] values) {
        float d, xd, yd;
        float x, y, z, x0, y0, x3, y3, x4, y4, x5, y5;
        float sscale = 0.75f * 0.15f;
        x = 0.0f;
        y = 0.0f;
        z = values[2][0];
        x5 = values[0][1] - values[0][0];
        y5 = values[1][1] - values[1][0];
        float xdir = x5 - x;
        float ydir = y5 - y;
        float dist = (float) Math.sqrt(xdir * xdir + ydir * ydir);
        x0 = xdir / dist;
        y0 = ydir / dist;
        int nv = 0;
        float[] vx = new float[NUM];
        float[] vy = new float[NUM];
        float[] vz = new float[NUM];
        int lenv = vx.length;
        vx[nv] = x;
        vy[nv] = y;
        vz[nv] = z;
        nv++;
        vx[nv] = x5;
        vy[nv] = y5;
        vz[nv] = z;
        nv++;
        xd = sscale * x0;
        yd = sscale * y0;
        x3 = x5 - 0.3f * (xd - yd);
        y3 = y5 - 0.3f * (yd + xd);
        x4 = x5 - 0.3f * (xd + yd);
        y4 = y5 - 0.3f * (yd - xd);
        vx[nv] = x5;
        vy[nv] = y5;
        vz[nv] = z;
        nv++;
        vx[nv] = x3;
        vy[nv] = y3;
        vz[nv] = z;
        nv++;
        vx[nv] = x5;
        vy[nv] = y5;
        vz[nv] = z;
        nv++;
        vx[nv] = x4;
        vy[nv] = y4;
        vz[nv] = z;
        nv++;
        float step = getStep(xdir, ydir);
        int nsteps = (int) (dist / step);
        if (nsteps < 1) nsteps = 1;
        int lim = (vx.length - nv) / (2 * NE);
        if (nsteps < 1) nsteps = 1;
        if (nsteps > lim) nsteps = lim;
        float xstep = xdir / nsteps;
        float ystep = ydir / nsteps;
        boolean[] outside = new boolean[NE + 1];
        for (int i = 0; i < NE + 1; i++) {
            float xs = x_ellipse[i] + xstep;
            float ys = y_ellipse[i] + ystep;
            float radius = getStep(xs, ys);
            float len = (float) Math.sqrt(xs * xs + ys * ys);
            outside[i] = (len > radius);
        }
        float[] xe = new float[2 * NE];
        float[] ye = new float[2 * NE];
        int ne = 0;
        for (int i = 0; i < NE; i++) {
            if (outside[i] && outside[i + 1]) {
                xe[ne] = x_ellipse[i];
                ye[ne] = y_ellipse[i];
                ne++;
                xe[ne] = x_ellipse[i + 1];
                ye[ne] = y_ellipse[i + 1];
                ne++;
            }
        }
        float xcenter = x;
        float ycenter = y;
        for (int i = 0; i < NE; i++) {
            vx[nv] = x_ellipse[i];
            vy[nv] = y_ellipse[i];
            vz[nv] = z;
            nv++;
            vx[nv] = x_ellipse[i + 1];
            vy[nv] = y_ellipse[i + 1];
            vz[nv] = z;
            nv++;
        }
        for (int i = 0; i < nsteps; i++) {
            xcenter += xstep;
            ycenter += ystep;
            for (int j = 0; j < ne; j++) {
                vx[nv] = xcenter + xe[j];
                vy[nv] = ycenter + ye[j];
                vz[nv] = z;
                nv++;
            }
        }
        VisADLineArray array = new VisADLineArray();
        array.vertexCount = nv;
        float[] coordinates = new float[3 * nv];
        int m = 0;
        for (int i = 0; i < nv; i++) {
            coordinates[m++] = vx[i];
            coordinates[m++] = vy[i];
            coordinates[m++] = vz[i];
        }
        array.coordinates = coordinates;
        return array;
    }
",1
20639773,7,"    public String[] sortAlpha(Collection collection) {
        String[] retur = new String[collection.size()];
        Iterator it = collection.iterator();
        int k = 0;
        for (int i = 0; i < collection.size(); i++) {
            retur[i] = (String) it.next();
        }
        for (int i = 0; i < retur.length - 1; i++) {
            if (retur[i].compareTo(retur[i + 1]) > 0) {
                String temp = retur[i];
                retur[i] = retur[i + 1];
                retur[i + 1] = temp;
                int j = i;
                boolean done = false;
                while (j != 0 && !done) {
                    if (retur[j].compareTo(retur[j - 1]) < 0) {
                        temp = retur[j];
                        retur[j] = retur[j - 1];
                        retur[j - 1] = temp;
                    } else done = true;
                    j--;
                }
            }
        }
        return retur;
    }
",1
17554574,7,"    @Override
    protected boolean disconnectInput(Node inputNode, int inputNodeOutputIndex) {
        int deleteIndex = -1;
        boolean removed = false;
        int numberOfInputs = inputNodes.length;
        do {
            deleteIndex = -1;
            for (int i = 0; i < inputNodes.length; i++) {
                if (inputNode == inputNodes[i] && (inputNodeOutputIndex == -1 || inputNodeOutputIndex == inputNodeOutputIndices[i])) {
                    deleteIndex = i;
                    break;
                }
            }
            if (deleteIndex >= 0) {
                for (int i = deleteIndex + 1; i < inputNodes.length; i++) {
                    inputNodes[i - 1] = inputNodes[i];
                    inputNodeOutputIndices[i - 1] = inputNodeOutputIndices[i];
                    weights[i] = weights[i + 1];
                    weightChanges[i] = weightChanges[i + 1];
                    inputNodes[i - 1].outputNodeInputIndices[inputNodeOutputIndices[i - 1]] = i - 1;
                }
                numberOfInputs--;
                removed = true;
            }
        } while (inputNodeOutputIndex == -1 && deleteIndex != -1);
        Node[] newInputNodes = new Node[numberOfInputs];
        System.arraycopy(inputNodes, 0, newInputNodes, 0, numberOfInputs);
        inputNodes = newInputNodes;
        int[] newInputNodeOutputIndices = new int[numberOfInputs];
        System.arraycopy(inputNodeOutputIndices, 0, newInputNodeOutputIndices, 0, numberOfInputs);
        inputNodeOutputIndices = newInputNodeOutputIndices;
        double[] newWeights = new double[numberOfInputs + 1];
        System.arraycopy(weights, 0, newWeights, 0, numberOfInputs + 1);
        weights = newWeights;
        double[] newWeightChanges = new double[numberOfInputs + 1];
        System.arraycopy(weightChanges, 0, newWeightChanges, 0, numberOfInputs + 1);
        weightChanges = newWeightChanges;
        return removed;
    }
",1
5296777,7,"    public static void updateFileHistory(File latestFilename) {
        read();
        boolean alreadyExists = false;
        for (int h = historySize - 1; h >= 0; h--) {
            if (latestFilename.getPath().equals(filename[h].getPath())) {
                alreadyExists = true;
                File file = filename[h];
                for (int y = h; y < historySize - 1; y++) filename[y] = filename[y + 1];
                filename[historySize - 1] = file;
                write();
            }
        }
        if (!alreadyExists) {
            if (historySize < maxHistorySize) {
                filename[historySize] = latestFilename;
                historySize++;
            } else {
                for (int i = 0; i < historySize - 1; i++) filename[i] = filename[i + 1];
                filename[historySize - 1] = latestFilename;
            }
            write();
        }
    }
",1
14615632,7,"    public static void main(String[] args) throws Exception {
        File dir = new File(""."");
        TestCompiler tc = new TestCompiler(dir, null, dir);
        tc.addErrorListener(new ConsoleErrorReporter(System.out));
        tc.setForceCompile(true);
        String[] names = tc.compile(args[0]);
        System.out.println(""Compiled "" + names.length + "" sources"");
        for (int i = 0; i < names.length; i++) {
            System.out.println(names[i]);
        }
        int errorCount = tc.getErrorCount();
        if (errorCount > 0) {
            String msg = String.valueOf(errorCount) + "" error"";
            if (errorCount != 1) {
                msg += 's';
            }
            System.out.println(msg);
            return;
        }
        TemplateLoader loader = new TemplateLoader();
        TemplateLoader.Template template = loader.getTemplate(args[0]);
        int length = args.length - 1;
        Object[] params = new Object[length];
        for (int i = 0; i < length; i++) {
            params[i] = args[i + 1];
        }
        System.out.println(""Executing "" + template);
        template.execute(new Context(System.out), params);
    }
",1
307852,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",0
6045968,7,"    private byte[] convertUTF16StringToLittleEndian(byte[] bytesString) {
        if (bytesString == null) {
            return new byte[0];
        }
        for (int i = 0; i < bytesString.length; i += 2) {
            byte tmp = bytesString[i];
            bytesString[i] = bytesString[i + 1];
            bytesString[i + 1] = tmp;
        }
        return bytesString;
    }
",1
12503910,7,"    protected void initSettings() {
        dim = grid.length;
        distance = new double[dim - 1];
        for (int i = 0; i < dim - 1; i++) distance[i] = grid[i + 1] - grid[i];
        bezier = new double[3 * dim - 2];
        a = new double[dim - 2];
        b = new double[dim - 2];
        rightSide = new double[dim - 2];
        mu = new double[dim];
        for (int j = 0; j < a.length; j++) {
            a[j] = distance[j] / (distance[j] + distance[j + 1]);
            b[j] = distance[j + 1] / (distance[j] + distance[j + 1]);
            rightSide[j] = (fvalues[j + 2] - fvalues[j + 1]) / distance[j + 1];
            rightSide[j] -= (fvalues[j + 1] - fvalues[j]) / distance[j];
            rightSide[j] /= (distance[j] + distance[j + 1]);
        }
    }
",1
863795,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
6668158,7,"        synchronized void rollFw(String aLine, int aNewPosition) {
            for (int i = 0; i < content.length - 1; i++) {
                content[i] = content[i + 1];
                positions[i] = positions[i + 1];
            }
            positions[content.length - 1] = positions[content.length];
            content[content.length - 1] = aLine;
            positions[positions.length - 1] = aNewPosition;
        }
",0
19658639,7,"    private static void dualPivotQuicksort(char[] a, int left, int right) {
        int sixth = (right - left + 1) / 6;
        int e1 = left + sixth;
        int e5 = right - sixth;
        int e3 = (left + right) >>> 1;
        int e4 = e3 + sixth;
        int e2 = e3 - sixth;
        char ae1 = a[e1], ae2 = a[e2], ae3 = a[e3], ae4 = a[e4], ae5 = a[e5];
        if (ae1 > ae2) {
            char t = ae1;
            ae1 = ae2;
            ae2 = t;
        }
        if (ae4 > ae5) {
            char t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        if (ae1 > ae3) {
            char t = ae1;
            ae1 = ae3;
            ae3 = t;
        }
        if (ae2 > ae3) {
            char t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae1 > ae4) {
            char t = ae1;
            ae1 = ae4;
            ae4 = t;
        }
        if (ae3 > ae4) {
            char t = ae3;
            ae3 = ae4;
            ae4 = t;
        }
        if (ae2 > ae5) {
            char t = ae2;
            ae2 = ae5;
            ae5 = t;
        }
        if (ae2 > ae3) {
            char t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae4 > ae5) {
            char t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        a[e1] = ae1;
        a[e3] = ae3;
        a[e5] = ae5;
        char pivot1 = ae2;
        a[e2] = a[left];
        char pivot2 = ae4;
        a[e4] = a[right];
        int less = left + 1;
        int great = right - 1;
        boolean pivotsDiffer = (pivot1 != pivot2);
        if (pivotsDiffer) {
            outer: for (int k = less; k <= great; k++) {
                char ak = a[k];
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else if (ak > pivot2) {
                    while (a[great] > pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = a[great];
                        a[great--] = ak;
                    }
                }
            }
        } else {
            for (int k = less; k <= great; k++) {
                char ak = a[k];
                if (ak == pivot1) {
                    continue;
                }
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else {
                    while (a[great] > pivot1) {
                        great--;
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = pivot1;
                        a[great--] = ak;
                    }
                }
            }
        }
        a[left] = a[less - 1];
        a[less - 1] = pivot1;
        a[right] = a[great + 1];
        a[great + 1] = pivot2;
        doSort(a, left, less - 2);
        doSort(a, great + 2, right);
        if (!pivotsDiffer) {
            return;
        }
        if (less < e1 && great > e5) {
            while (a[less] == pivot1) {
                less++;
            }
            while (a[great] == pivot2) {
                great--;
            }
            outer: for (int k = less; k <= great; k++) {
                char ak = a[k];
                if (ak == pivot2) {
                    while (a[great] == pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] == pivot1) {
                        a[k] = a[less];
                        a[less++] = pivot1;
                    } else {
                        a[k] = a[great];
                    }
                    a[great--] = pivot2;
                } else if (ak == pivot1) {
                    a[k] = a[less];
                    a[less++] = pivot1;
                }
            }
        }
        doSort(a, less, great);
    }
",1
10518649,7,"    public void getQuestions() {
        BufferedReader input;
        String line;
        ArrayList<String> lineList;
        lineList = new ArrayList<String>();
        int count = 1;
        try {
            input = new BufferedReader(new FileReader(""easyplay//history//questions//easy.txt""));
            if (difficulty == 1) {
                input.close();
                input = new BufferedReader(new FileReader(""easyplay//history//questions//standard.txt""));
            } else if (difficulty == 2) {
                input.close();
                input = new BufferedReader(new FileReader(""easyplay//history//questions//hard.txt""));
            }
            line = input.readLine();
            count--;
            while (line != null) {
                count++;
                lineList.add(line);
                line = input.readLine();
            }
            input.close();
        } catch (IOException err) {
        }
        String[] lines = new String[lineList.size()];
        lineList.toArray(lines);
        int i = 0;
        int j = 0;
        int numberofqs = count / 5;
        questions = new String[numberofqs];
        answers = new String[numberofqs];
        wrong1 = new String[numberofqs];
        wrong2 = new String[numberofqs];
        wrong3 = new String[numberofqs];
        while (j < count) {
            questions[i] = lines[j];
            answers[i] = lines[j + 1];
            wrong1[i] = lines[j + 2];
            wrong2[i] = lines[j + 3];
            wrong3[i] = lines[j + 4];
            i++;
            j = j + 5;
        }
    }
",0
5788005,7,"    public String[] getItemAt(Component c, Element e, String[] index) {
        int indice = Integer.parseInt(index[0]);
        String[] out = new String[4];
        for (int i = 0; i < 4; i++) {
            out[i] = null;
        }
        Element parent = e;
        String childName = null;
        String childRole = null;
        String[] children = null;
        AccessibleContext menu = this.getList(c.getAccessibleContext());
        Accessible child = null;
        int count = menu.getAccessibleChildrenCount();
        if (count != 0) {
            children = new String[(2 * count)];
            for (int i = 0; i < (2 * count); i++) {
                children[i] = null;
            }
        }
        if (children != null) {
            int j = 0;
            for (int i = 0; i < count; i++) {
                child = menu.getAccessibleChild(i);
                childName = child.getAccessibleContext().getAccessibleName();
                childRole = child.getAccessibleContext().getAccessibleRole().toDisplayString(Locale.UK);
                if (stringToRole(childRole) != null) {
                    children[j] = childName;
                    children[j + 1] = childRole;
                    j = j + 2;
                }
            }
            out[0] = children[indice];
            out[1] = children[indice + 1];
            out[2] = parent.getAttributeValue(""accessibleName"");
            out[3] = parent.getAttributeValue(""accessibleRole"");
        } else {
            out = null;
        }
        return out;
    }
",1
16063643,7,"    public static final void fir_mem2(final float[] x, final int xs, final float[] num, final float[] y, final int ys, final int N, final int ord, final float[] mem) {
        int i, j;
        float xi;
        for (i = 0; i < N; i++) {
            xi = x[xs + i];
            y[ys + i] = num[0] * xi + mem[0];
            for (j = 0; j < ord - 1; j++) {
                mem[j] = mem[j + 1] + num[j + 1] * xi;
            }
            mem[ord - 1] = num[ord] * xi;
        }
    }
",1
88342,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",0
23060688,7,"    public static void novo_dia(double p, double dias[]) {
        int tam = dias.length;
        for (int i = 0; i < tam - 1; i++) dias[i] = dias[i + 1];
        dias[tam - 1] = p;
    }
",0
8940133,7,"    @SuppressWarnings(""unchecked"")
    public Comparable<?> getResult(Comparable<?>... comparables) throws ParseException {
        String returnColumnName = null;
        returnColumnName = comparables[0].toString().toLowerCase();
        Map<String, Object> result = null;
        Comparable<?>[] parameters = new Comparable<?>[comparables.length - 1];
        if (isThreadLocalCache()) {
            int threadLocalKey = this.hashCode();
            if (parameterSize > 1) {
                int hash = this.hashCode();
                for (int i = 0; i < parameters.length; i++) {
                    parameters[i] = comparables[i + 1];
                    hash ^= parameters[i].hashCode() << (i + 1);
                }
                threadLocalKey = threadLocalKey ^ hash;
            }
            result = (Map<String, Object>) ThreadLocalMap.get(threadLocalKey);
            if (result == null) {
                if (!ThreadLocalMap.containsKey(threadLocalKey)) {
                    result = query(parameters);
                    ThreadLocalMap.put(threadLocalKey, result);
                }
            }
        } else {
            result = query(parameters);
        }
        if (result == null) {
            return (null);
        } else {
            return ((Comparable<?>) result.get(returnColumnName));
        }
    }
",1
3455666,7,"    private void subdivideSurface(double tol, Vector vert, Vector norm, Vector face, Vector param) {
        Tube t = subdivideTube(tol);
        Vec3 pathv[] = new Vec3[t.vertex.length];
        for (int i = 0; i < pathv.length; i++) pathv[i] = t.vertex[i].r;
        int numParam = (texParam == null ? 0 : texParam.length);
        double tubeParamVal[][] = new double[t.vertex.length][numParam];
        for (int i = 0; i < numParam; i++) {
            if (t.paramValue[i] instanceof VertexParameterValue) {
                double val[] = ((VertexParameterValue) t.paramValue[i]).getValue();
                for (int j = 0; j < tubeParamVal.length; j++) tubeParamVal[j][i] = val[j];
            } else {
                double val = t.paramValue[i].getAverageValue();
                for (int j = 0; j < tubeParamVal.length; j++) tubeParamVal[j][i] = val;
            }
        }
        double max = 0.0;
        for (int i = 0; i < t.thickness.length; i++) if (t.thickness[i] > max) max = t.thickness[i];
        double r = 0.7 * max;
        int n = 0;
        if (r > tol) n = (int) Math.ceil(Math.PI / (Math.acos(1.0 - tol / r)));
        if (n < 3) n = 3;
        Vec3 subdiv[], zdir[], updir[], xdir[];
        subdiv = new Curve(pathv, t.smoothness, t.getSmoothingMethod(), t.closed).subdivideCurve().getVertexPositions();
        xdir = new Vec3[subdiv.length];
        zdir = new Vec3[subdiv.length];
        updir = new Vec3[subdiv.length];
        xdir[0] = subdiv[1].minus(subdiv[0]);
        xdir[0].normalize();
        if (Math.abs(xdir[0].y) > Math.abs(xdir[0].z)) zdir[0] = xdir[0].cross(Vec3.vz()); else zdir[0] = xdir[0].cross(Vec3.vy());
        zdir[0].normalize();
        updir[0] = xdir[0].cross(zdir[0]);
        Vec3 dir1, dir2;
        double zfrac1, zfrac2, upfrac1, upfrac2;
        zfrac1 = xdir[0].dot(zdir[0]);
        zfrac2 = Math.sqrt(1.0 - zfrac1 * zfrac1);
        dir1 = zdir[0].minus(xdir[0].times(zfrac1));
        dir1.normalize();
        upfrac1 = xdir[0].dot(updir[0]);
        upfrac2 = Math.sqrt(1.0 - upfrac1 * upfrac1);
        dir2 = updir[0].minus(xdir[0].times(upfrac1));
        dir2.normalize();
        for (int i = 1; i < subdiv.length; i++) {
            if (i == subdiv.length - 1) {
                if (t.closed) xdir[i] = subdiv[0].minus(subdiv[subdiv.length - 2]); else xdir[i] = subdiv[subdiv.length - 1].minus(subdiv[subdiv.length - 2]);
            } else xdir[i] = subdiv[i + 1].minus(subdiv[i - 1]);
            xdir[i].normalize();
            dir1 = dir1.minus(xdir[i].times(xdir[i].dot(dir1)));
            dir1.normalize();
            dir2 = dir2.minus(xdir[i].times(xdir[i].dot(dir2)));
            dir2.normalize();
            zdir[i] = xdir[i].times(zfrac1).plus(dir1.times(zfrac2));
            updir[i] = xdir[i].times(upfrac1).plus(dir2.times(upfrac2));
        }
        double dtheta = 2.0 * Math.PI / n, theta = 0.0;
        for (int i = 0; i < pathv.length; i++) {
            int k = (pathv.length == subdiv.length ? i : 2 * i);
            Vec3 orig = pathv[i], z = zdir[k], up = updir[k];
            r = 0.5 * t.thickness[i];
            for (int j = 0; j < n; j++) {
                double sin = Math.sin(theta), cos = Math.cos(theta);
                Vec3 normal = new Vec3(cos * z.x + sin * up.x, cos * z.y + sin * up.y, cos * z.z + sin * up.z);
                norm.addElement(normal);
                MeshVertex mv = new MeshVertex(new Vec3(orig.x + r * normal.x, orig.y + r * normal.y, orig.z + r * normal.z));
                vert.addElement(mv);
                param.addElement(tubeParamVal[i]);
                theta += dtheta;
            }
        }
        for (int i = 0; i < pathv.length - 1; i++) {
            int k = i * n;
            for (int j = 0; j < n - 1; j++) {
                face.addElement(new int[] { k + j, k + j + 1, k + j + n });
                face.addElement(new int[] { k + j + 1, k + j + n + 1, k + j + n });
            }
            face.addElement(new int[] { k + n - 1, k, k + n + n - 1 });
            face.addElement(new int[] { k, k + n, k + n + n - 1 });
        }
        if (endsStyle == CLOSED_ENDS) {
            int k = (pathv.length - 1) * n;
            for (int j = 0; j < n - 1; j++) {
                face.addElement(new int[] { k + j, k + j + 1, j });
                face.addElement(new int[] { k + j + 1, j + 1, j });
            }
            face.addElement(new int[] { k + n - 1, k, n - 1 });
            face.addElement(new int[] { k, 0, n - 1 });
        } else if (endsStyle == FLAT_ENDS) {
            int k = vert.size();
            vert.addElement(new MeshVertex(t.vertex[0]));
            vert.addElement(new MeshVertex(t.vertex[t.vertex.length - 1]));
            param.addElement(tubeParamVal[0]);
            param.addElement(tubeParamVal[t.vertex.length - 1]);
            for (int i = 0; i < n - 1; i++) face.addElement(new int[] { i + 1, i, k });
            face.addElement(new int[] { 0, n - 1, k });
            k++;
            int j = n * (pathv.length - 1);
            for (int i = 0; i < n - 1; i++) face.addElement(new int[] { j + i, j + i + 1, k });
            face.addElement(new int[] { j + n - 1, j, k });
        }
    }
",1
13335716,7,"        public Iterator<E> iterator() {
            return new Iterator<E>() {

                private int currentIndex = -1;

                public boolean hasNext() {
                    return size > 0 && currentIndex < size;
                }

                public E next() {
                    if (!hasNext()) {
                        throw new NoSuchElementException();
                    }
                    currentIndex++;
                    return (E) elements[currentIndex];
                }

                public void remove() {
                    if (-1 == currentIndex) {
                        throw new IllegalStateException();
                    }
                    for (int i = currentIndex; i < size - 1; i++) {
                        elements[i] = elements[i + 1];
                    }
                    size--;
                }
            };
        }
",0
4442345,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
",1
21248118,7,"    private void backspace() {
        if (textIndex == 0) {
            return;
        }
        int nul = textIndex;
        while (text[nul] != 0 && nul < text.length) {
            ++nul;
        }
        for (int i = textIndex - 1; i < nul; ++i) {
            text[i] = text[i + 1];
        }
        text[nul] = 0;
        --textIndex;
    }
",0
9237494,7,"    byte[] getRGB(byte[] data, int size) throws IOException {
        byte[] rgb = data;
        byte temp;
        int i;
        for (i = 0; i < size * 3; i += 3) {
            temp = rgb[i];
            rgb[i] = rgb[i + 2];
            rgb[i + 2] = temp;
        }
        return rgb;
    }
",1
22719758,7,"    public V remove(final int key) throws IllegalArgumentException, IllegalStateException {
        final int eIndex = findEntryIndex(key);
        if (eIndex < 0) return null;
        final int[] k = getKeys();
        final int numKeys = (null == k) ? 0 : k.length;
        final V[] o = getObjects();
        final int numObjects = (null == o) ? 0 : o.length;
        if (numKeys != numObjects) throw new IllegalStateException(getRemoveExceptionLocation(key) + "" keys("" + numKeys + "")/objects("" + numObjects + "") arrays lengths mismatch"");
        final V prev = o[eIndex];
        if ((null == prev) || (Integer.MAX_VALUE == k[eIndex])) throw new IllegalStateException(getRemoveExceptionLocation(key) + "" empty previous object at index="" + eIndex);
        for (int i = eIndex; i < (numKeys - 1); i++) {
            k[i] = k[i + 1];
            o[i] = o[i + 1];
        }
        k[numKeys - 1] = Integer.MAX_VALUE;
        o[numObjects - 1] = null;
        updateSize(-1);
        return prev;
    }
",1
556208,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
782480,7,"    public static void main(String[] args) throws EprogException {
        int[][] a = new int[3][4];
        int temp = 0;
        float[][] matrix = new float[3][4];
        float[][] matrix1 = new float[3][4];
        float ausgabex1 = 0;
        float ausgabex2 = 0;
        float ausgabex3 = 0;
        float umrechnungsFaktor = 0;
        boolean fehler = false;
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a.length + 1; j++) {
                try {
                    temp = readInt();
                } catch (EprogException e) {
                    fehler = true;
                }
                if ((temp < 21) && (temp > -21)) {
                    a[i][j] = temp;
                } else {
                    print(""FALSCHE EINGABE"");
                    System.exit(0);
                }
            }
        }
        for (int j = 0; j < 2; j++) {
            if (a[0][0] == 0) {
                int puffer[] = new int[4];
                for (int i = 0; i < 4; i++) {
                    puffer[i] = a[j + 1][i];
                    a[j + 1][i] = a[0][i];
                    a[0][i] = puffer[i];
                }
            }
        }
        if (a[0][0] == 0) {
            println(""FALSCHE EINGABE"");
            System.exit(0);
        }
        for (int index = 0; index < a.length; index++) {
            if (a[index][index] == 0) {
                println(""FALSCHE EINGABE"");
                System.exit(0);
            }
        }
        if (fehler == false) {
            for (int index = 0; index < a[1].length; index++) {
                matrix[0][index] = a[0][index];
                matrix[1][index] = a[1][index] - (a[1][0] / (float) a[0][0]) * a[0][index];
                matrix[2][index] = a[2][index] - (a[2][0] / (float) a[0][0]) * a[0][index];
            }
            for (int index = 0; index < matrix.length; index++) {
                if (matrix[index][index] == 0) {
                    println(""FALSCHE EINGABE"");
                    System.exit(0);
                }
            }
            umrechnungsFaktor = (matrix[2][1] - (matrix[2][0] / matrix[0][0]) * matrix[0][1]) / (matrix[1][1] - (matrix[1][0] / matrix[0][0]) * matrix[0][1]);
            for (int index = 0; index < matrix[1].length; index++) {
                matrix1[0][index] = matrix[0][index];
                matrix1[1][index] = matrix[1][index];
                matrix1[2][index] = (matrix[2][index]) - umrechnungsFaktor * matrix[1][index];
            }
            ausgabex3 = matrix1[2][3] / matrix1[2][2];
            ausgabex2 = (matrix1[1][3] - (ausgabex3 * matrix1[1][2])) / matrix1[1][1];
            ausgabex1 = (matrix1[0][3] - (ausgabex2 * matrix1[0][1]) - (ausgabex3 * matrix[0][2])) / matrix1[0][0];
            for (int index = 0; index < matrix1.length; index++) {
                if (matrix1[index][index] == 0) {
                    println(""FALSCHE EINGABE"");
                    System.exit(0);
                }
            }
            printFixed(ausgabex1);
            print("" "");
            printFixed(ausgabex2);
            print("" "");
            printFixed(ausgabex3);
        } else {
            println(""?"");
        }
    }
",0
13581926,7,"    void removeInactiveEdges(int y) {
        int i = 0;
        while (i < activeEdges) {
            int index = aedge[i];
            if (y < ey1[index] || y >= ey2[index]) {
                for (int j = i; j < activeEdges - 1; j++) aedge[j] = aedge[j + 1];
                activeEdges--;
            } else i++;
        }
    }
",1
19068322,7,"    void image(int subsample, GRect rect, int index, final byte[] img8, int rowsize, int pixsep, boolean fast) {
        int nlevel = 0;
        while ((nlevel < 5) && ((32 >> nlevel) > subsample)) {
            nlevel++;
        }
        final int boxsize = 1 << nlevel;
        if (subsample != (32 >> nlevel)) {
            throw new IllegalArgumentException(""(IWMap::image) Unsupported subsampling factor"");
        }
        if (rect.isEmpty()) {
            throw new IllegalArgumentException(""(IWMap::image) GRect is empty"");
        }
        GRect irect = new GRect(0, 0, ((iw + subsample) - 1) / subsample, ((ih + subsample) - 1) / subsample);
        if ((rect.xmin < 0) || (rect.ymin < 0) || (rect.xmax > irect.xmax) || (rect.ymax > irect.ymax)) {
            throw new IllegalArgumentException(""(IWMap::image) GRect is out of bounds: "" + rect.xmin + "","" + rect.ymin + "","" + rect.xmax + "","" + rect.ymax + "","" + irect.xmax + "","" + irect.ymax);
        }
        GRect[] needed = new GRect[8];
        GRect[] recomp = new GRect[8];
        for (int i = 0; i < 8; ) {
            needed[i] = new GRect();
            recomp[i++] = new GRect();
        }
        int r = 1;
        needed[nlevel] = (GRect) rect.clone();
        recomp[nlevel] = (GRect) rect.clone();
        for (int i = nlevel - 1; i >= 0; i--) {
            needed[i] = recomp[i + 1];
            needed[i].inflate(3 * r, 3 * r);
            needed[i].intersect(needed[i], irect);
            r += r;
            recomp[i].xmin = ((needed[i].xmin + r) - 1) & ~(r - 1);
            recomp[i].xmax = needed[i].xmax & ~(r - 1);
            recomp[i].ymin = ((needed[i].ymin + r) - 1) & ~(r - 1);
            recomp[i].ymax = needed[i].ymax & ~(r - 1);
        }
        GRect work = new GRect();
        work.xmin = needed[0].xmin & ~(boxsize - 1);
        work.ymin = needed[0].ymin & ~(boxsize - 1);
        work.xmax = ((needed[0].xmax - 1) & ~(boxsize - 1)) + boxsize;
        work.ymax = ((needed[0].ymax - 1) & ~(boxsize - 1)) + boxsize;
        final int dataw = work.width();
        final short[] data = new short[dataw * work.height()];
        int blkw = bw >> 5;
        int lblock = ((work.ymin >> nlevel) * blkw) + (work.xmin >> nlevel);
        final short[] liftblock = new short[1024];
        for (int by = work.ymin, ldata = 0; by < work.ymax; by += boxsize, ldata += (dataw << nlevel), lblock += blkw) {
            for (int bx = work.xmin, bidx = lblock, rdata = ldata; bx < work.xmax; bx += boxsize, bidx++, rdata += boxsize) {
                IWBlock block = blocks[bidx];
                int mlevel = nlevel;
                if ((nlevel > 2) && (((bx + 31) < needed[2].xmin) || (bx > needed[2].xmax) || ((by + 31) < needed[2].ymin) || (by > needed[2].ymax))) {
                    mlevel = 2;
                }
                final int bmax = ((1 << (mlevel + mlevel)) + 15) >> 4;
                final int ppinc = 1 << (nlevel - mlevel);
                final int ppmod1 = dataw << (nlevel - mlevel);
                final int ttmod0 = 32 >> mlevel;
                final int ttmod1 = ttmod0 << 5;
                block.write_liftblock(liftblock, 0, bmax);
                for (int ii = 0, tt = 0, pp = rdata; ii < boxsize; ii += ppinc, pp += ppmod1, tt += (ttmod1 - 32)) {
                    for (int jj = 0; jj < boxsize; jj += ppinc, tt += ttmod0) {
                        data[pp + jj] = liftblock[tt];
                    }
                }
            }
        }
        r = boxsize;
        for (int i = 0; i < nlevel; i++) {
            GRect comp = needed[i];
            comp.xmin = comp.xmin & ~(r - 1);
            comp.ymin = comp.ymin & ~(r - 1);
            comp.translate(-work.xmin, -work.ymin);
            if (fast && (i >= 4)) {
                for (int ii = comp.ymin, pp = (comp.ymin * dataw); ii < comp.ymax; ii += 2, pp += (dataw + dataw)) {
                    for (int jj = comp.xmin; jj < comp.xmax; jj += 2) {
                        data[pp + jj + dataw] = data[pp + jj + dataw + 1] = data[pp + jj + 1] = data[pp + jj];
                    }
                }
                break;
            }
            backward(data, (comp.ymin * dataw) + comp.xmin, comp.width(), comp.height(), dataw, r, r >> 1);
            r >>= 1;
        }
        GRect nrect = (GRect) rect.clone();
        nrect.translate(-work.xmin, -work.ymin);
        for (int i = nrect.ymin, pidx = (nrect.ymin * dataw), ridx = index; i++ < nrect.ymax; ridx += rowsize, pidx += dataw) {
            for (int j = nrect.xmin, pixidx = ridx; j < nrect.xmax; j++, pixidx += pixsep) {
                int x = (data[pidx + j] + 32) >> 6;
                if (x < -128) {
                    x = -128;
                } else if (x > 127) {
                    x = 127;
                }
                img8[pixidx] = (byte) x;
            }
        }
    }
",1
13780282,7,"    public void sortOnColumn(boolean sort_ascending, int col_idx) {
        boolean made_change = true;
        while (made_change) {
            made_change = false;
            for (int i = 0; i < data_grid.length - 1; i++) {
                boolean flip = false;
                if (data_grid[i][col_idx].equals("""") || data_grid[i + 1][col_idx].equals("""")) {
                    if (data_grid[i][col_idx].equals("""") && data_grid[i + 1][col_idx].equals("""")) {
                    } else {
                        if ((sort_ascending && !data_grid[i][col_idx].equals("""") && data_grid[i + 1][col_idx].equals("""")) || (!sort_ascending && data_grid[i][col_idx].equals("""") && !data_grid[i + 1][col_idx].equals(""""))) {
                            flip = true;
                        }
                    }
                } else {
                    if ((sort_ascending && (Float.parseFloat(data_grid[i][col_idx]) > Float.parseFloat(data_grid[i + 1][col_idx]))) || (!sort_ascending && (Float.parseFloat(data_grid[i][col_idx]) < Float.parseFloat(data_grid[i + 1][col_idx])))) {
                        flip = true;
                    } else {
                    }
                }
                if (flip) {
                    String[] temp = data_grid[i];
                    data_grid[i] = data_grid[i + 1];
                    data_grid[i + 1] = temp;
                    String[] stemp = vert[i];
                    vert[i] = vert[i + 1];
                    vert[i + 1] = stemp;
                    made_change = true;
                }
            }
        }
    }
",1
21920836,7,"    protected short z_call() {
        int nlocals;
        int i;
        if (operands[0] == 0) {
            if (isstore()) zm.set_variable(storevar, ZFALSE);
        } else {
            zm.zstack.push(new ZFrameBound(isstore()));
            if (isstore()) zm.zstack.push(new Integer(storevar));
            zm.zstack.push(new Integer(opnum));
            zm.zstack.push(new Integer(zm.pc));
            zm.zstack.push(new Integer(((ZMachine5) zm).argcount));
            zm.zstack.push(zm.locals);
            zm.pc = zm.routine_address(operands[0]);
            nlocals = zm.get_code_byte();
            ((ZMachine5) zm).argcount = (short) (count - 1);
            zm.locals = new short[nlocals];
            for (i = 0; i < nlocals; i++) {
                if (i < (count - 1)) {
                    zm.locals[i] = operands[i + 1];
                } else {
                    zm.locals[i] = 0;
                }
            }
        }
        return ZFALSE;
    }
",1
20191733,7,"    public static void main(String[] args) {
        System.out.println(""This file is currently unsupported - Log Buffer has not been integrated."");
        System.exit(0);
        output_path = args[0];
        if (output_path.charAt(output_path.length() - 1) != '/') {
            output_path += '/';
        }
        String[] files = new String[args.length - 1];
        for (int i = 0; i < files.length; i++) {
            files[i] = args[i + 1];
        }
        float tmp_percent = 0;
        for (String file : files) {
            SnpIterator SI = new SnpIterator(LB, file);
            System.out.println(""Processing file: "" + file);
            try {
                for (SNPLine snp : new IterableIterator<SNPLine>(SI)) {
                    tmp_percent = ((float) snp.get_observed() / (float) snp.get_coverage()) * 100;
                    if (snp.get_type().equalsIgnoreCase(""known"")) {
                        KnownSNPsP.bin_value(tmp_percent);
                        KnownSNPsC.bin_value(snp.get_observed());
                    } else {
                        UnknownSNPsP.bin_value(tmp_percent);
                        UnknownSNPsC.bin_value(snp.get_observed());
                    }
                    AllSNPsP.bin_value(tmp_percent);
                    AllSNPsC.bin_value(snp.get_observed());
                }
            } catch (NoSuchElementException nsee) {
                continue;
            }
        }
        write_SNP_report();
    }
",1
17047449,7,"    protected void initFile(String id) throws FormatException, IOException {
        if (debug) debug(""OpenlabReader.initFile("" + id + "")"");
        super.initFile(id);
        in = new RandomAccessStream(id);
        status(""Verifying Openlab LIFF format"");
        in.order(false);
        in.skipBytes(4);
        if (!in.readString(4).equals(""impr"")) {
            throw new FormatException(""Invalid LIFF file."");
        }
        version = in.readInt();
        if (version != 2 && version != 5) {
            throw new FormatException(""Invalid version : "" + version);
        }
        in.skipBytes(4);
        int offset = in.readInt();
        in.seek(offset);
        status(""Finding image offsets"");
        layerInfoList = new Vector[2];
        for (int i = 0; i < layerInfoList.length; i++) layerInfoList[i] = new Vector();
        xCal = yCal = zCal = (float) 0.0;
        while (in.getFilePointer() < in.length()) {
            long nextTag, startPos;
            subTag = tag = 0;
            try {
                startPos = in.getFilePointer();
                nextTag = readTagHeader();
            } catch (IOException exc) {
                if (debug) trace(exc);
                if (in.getFilePointer() >= in.length()) break; else throw new FormatException(exc.getMessage());
            }
            try {
                if (tag == 67 || tag == 68 || fmt.equals(""PICT"") || fmt.equals(""RAWi"")) {
                    LayerInfo info = new LayerInfo();
                    info.layerStart = (int) startPos;
                    info.zPosition = -1;
                    info.wavelength = -1;
                    in.skipBytes(24);
                    int volumeType = in.readShort();
                    if (volumeType == MAC_1_BIT || volumeType == MAC_256_GREYS || volumeType == MAC_256_COLORS || (volumeType >= MAC_24_BIT && volumeType <= GREY_16_BIT)) {
                        in.skipBytes(16);
                        info.layerName = in.readString(128);
                        if (!info.layerName.trim().equals(""Original Image"")) {
                            info.timestamp = in.readLong();
                            layerInfoList[0].add(info);
                        }
                    }
                } else if (tag == 69) {
                    in.skipBytes(18);
                    xCal = in.readFloat();
                    yCal = in.readFloat();
                } else if (tag == 72 || fmt.equals(""USER"")) {
                    char aChar = (char) in.read();
                    StringBuffer sb = new StringBuffer();
                    while (aChar != 0) {
                        sb = sb.append(aChar);
                        aChar = (char) in.read();
                    }
                    String className = sb.toString();
                    if (className.equals(""CVariableList"")) {
                        aChar = (char) in.read();
                        if (aChar == 1) {
                            int numVars = in.readShort();
                            while (numVars > 0) {
                                aChar = (char) in.read();
                                sb = new StringBuffer();
                                while (aChar != 0) {
                                    sb = sb.append(aChar);
                                    aChar = (char) in.read();
                                }
                                String varName = """";
                                String varStringValue = """";
                                double varNumValue = 0.0;
                                className = sb.toString();
                                int derivedClassVersion = in.read();
                                if (derivedClassVersion != 1) {
                                    throw new FormatException(""Invalid revision."");
                                }
                                if (className.equals(""CStringVariable"")) {
                                    int strSize = in.readInt();
                                    varStringValue = in.readString(strSize);
                                    varNumValue = Float.parseFloat(varStringValue);
                                    in.skipBytes(1);
                                } else if (className.equals(""CFloatVariable"")) {
                                    varNumValue = in.readDouble();
                                    varStringValue = """" + varNumValue;
                                }
                                int baseClassVersion = in.read();
                                if (baseClassVersion == 1 || baseClassVersion == 2) {
                                    int strSize = in.readInt();
                                    varName = in.readString(strSize);
                                    in.skipBytes(baseClassVersion == 1 ? 3 : 2);
                                } else {
                                    throw new FormatException(""Invalid revision."");
                                }
                                addMeta(varName, varStringValue);
                                numVars--;
                            }
                        }
                    }
                }
                in.seek(nextTag);
            } catch (Exception exc) {
                if (debug) trace(exc);
                in.seek(nextTag);
            }
        }
        Vector tmp = new Vector();
        for (int i = 0; i < layerInfoList[0].size(); i++) {
            tmp.add(layerInfoList[0].get(i));
        }
        core = new CoreMetadata(2);
        core.imageCount[0] = tmp.size();
        status(""Determining series count"");
        int oldChannels = openBytes(0).length / (core.sizeX[0] * core.sizeY[0] * 3);
        int oldWidth = core.sizeX[0];
        for (int i = 0; i < tmp.size(); i++) {
            LayerInfo layer = (LayerInfo) tmp.get(i);
            in.seek(layer.layerStart);
            long nextTag = readTagHeader();
            if (fmt.equals(""PICT"")) {
                in.skipBytes(298);
                int top, left, bottom, right;
                if (version == 2) {
                    in.skipBytes(2);
                    top = in.readShort();
                    left = in.readShort();
                    bottom = in.readShort();
                    right = in.readShort();
                    if (core.sizeX[series] == 0) core.sizeX[series] = right - left;
                    if (core.sizeY[series] == 0) core.sizeY[series] = bottom - top;
                } else {
                    core.sizeX[series] = in.readInt();
                    core.sizeY[series] = in.readInt();
                }
                in.seek(layer.layerStart);
                if (version == 2) {
                    nextTag = readTagHeader();
                    if ((tag != 67 && tag != 68) || !fmt.equals(""PICT"")) {
                        throw new FormatException(""Corrupt LIFF file."");
                    }
                    in.skipBytes(298);
                    try {
                        byte[] b = new byte[(int) (nextTag - in.getFilePointer())];
                        in.read(b);
                        BufferedImage img = pict.open(b);
                        if (img.getRaster().getNumBands() != oldChannels || img.getWidth() != oldWidth) {
                            layerInfoList[1].add(tmp.get(i));
                            layerInfoList[0].remove(tmp.get(i));
                        }
                    } catch (FormatException e) {
                    }
                }
            } else {
                in.skipBytes(24);
                int type = DataTools.read2SignedBytes(in, false);
                if (type == MAC_24_BIT) {
                    layerInfoList[1].add(tmp.get(i));
                    layerInfoList[0].remove(tmp.get(i));
                }
            }
        }
        if (layerInfoList[1].size() == 0 || layerInfoList[0].size() == 0) {
            core.sizeC = new int[1];
            core.sizeC[0] = layerInfoList[1].size() == 0 ? 1 : 3;
            if (core.sizeC[0] == 1 && oldChannels == 1) core.sizeC[0] = 3;
            int oldImages = core.imageCount[0];
            core.imageCount = new int[1];
            core.imageCount[0] = oldImages;
            if (layerInfoList[0].size() == 0) layerInfoList[0] = layerInfoList[1];
            int x = core.sizeX[0];
            core.sizeX = new int[1];
            core.sizeX[0] = x;
        } else {
            core.imageCount[0] = layerInfoList[0].size();
            core.imageCount[1] = layerInfoList[1].size();
            core.sizeC[0] = 1;
            core.sizeC[1] = 3;
            int oldW = core.sizeX[0];
            int oldH = core.sizeY[0];
            core.sizeX = new int[2];
            core.sizeY = new int[2];
            core.sizeX[0] = oldW;
            core.sizeX[1] = oldW;
            core.sizeY[0] = oldH;
            core.sizeY[1] = oldH;
        }
        Arrays.fill(core.metadataComplete, true);
        status(""Populating metadata"");
        numSeries = core.imageCount.length;
        int[] bpp = new int[numSeries];
        Arrays.fill(core.orderCertain, true);
        int oldSeries = getSeries();
        for (int i = 0; i < bpp.length; i++) {
            setSeries(i);
            if (core.sizeC[i] == 0) core.sizeC[i] = 1;
            bpp[i] = openBytes(0).length / (core.sizeX[i] * core.sizeY[i]);
        }
        setSeries(oldSeries);
        if (bytesPerPixel == 3) bytesPerPixel = 1;
        if (bytesPerPixel == 0) bytesPerPixel++;
        addMeta(""Version"", new Integer(version));
        addMeta(""Number of Series"", new Integer(numSeries));
        for (int i = 0; i < numSeries; i++) {
            addMeta(""Width (Series "" + i + "")"", new Integer(core.sizeX[i]));
            addMeta(""Height (Series "" + i + "")"", new Integer(core.sizeY[i]));
            addMeta(""Bit depth (Series "" + i + "")"", new Integer(bpp[i] * 8));
            addMeta(""Number of channels (Series "" + i + "")"", new Integer(core.sizeC[i]));
            addMeta(""Number of images (Series "" + i + "")"", new Integer(core.imageCount[i]));
        }
        MetadataStore store = getMetadataStore();
        for (int i = 0; i < numSeries; i++) {
            core.sizeT[i] += 1;
            core.sizeZ[i] = core.imageCount[i] / core.sizeT[i];
            core.currentOrder[i] = isRGB() ? ""XYCZT"" : ""XYZCT"";
            core.rgb[i] = core.sizeC[i] > 1;
            core.interleaved[i] = true;
            core.littleEndian[i] = false;
            try {
                if (i != 0) {
                    if (bpp[i] == bpp[0]) bpp[i] = bpp[i + 1];
                }
            } catch (ArrayIndexOutOfBoundsException a) {
            }
            switch(bpp[i]) {
                case 1:
                case 3:
                    core.pixelType[i] = FormatTools.UINT8;
                    break;
                case 2:
                case 6:
                    core.pixelType[i] = FormatTools.UINT16;
                    break;
                case 4:
                    core.pixelType[i] = FormatTools.UINT32;
                    break;
            }
            store.setImage(""Series "" + i, null, null, new Integer(i));
            store.setDimensions(new Float(xCal), new Float(yCal), new Float(zCal), null, null, new Integer(i));
        }
        FormatTools.populatePixels(store, this);
        for (int i = 0; i < numSeries; i++) {
            for (int j = 0; j < core.sizeC[i]; j++) {
                store.setLogicalChannel(j, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, new Integer(i));
            }
        }
    }
",1
20084386,7,"    public float[] swapMembers(float[] array) {
        float tmp;
        for (int i = 0; i < array.length; i += 2) {
            tmp = array[i];
            array[i] = array[i + 1];
            array[i + 1] = tmp;
        }
        return array;
    }
",1
1706198,7,"    @SuppressWarnings(""unchecked"")
    public V remove(char key) {
        char k = key;
        int index = Arrays.binarySearch(keyIndices, k);
        if (index >= 0) {
            V old = (V) (values[index]);
            Object[] newValues = Arrays.copyOf(values, values.length - 1);
            char[] newIndices = Arrays.copyOf(keyIndices, keyIndices.length - 1);
            for (int i = index; i < values.length - 1; ++i) {
                newValues[i] = values[i + 1];
                newIndices[i] = keyIndices[i + 1];
            }
            values = newValues;
            keyIndices = newIndices;
            return old;
        }
        return null;
    }
",1
52273,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
3377948,7,"    public void rearrangeCars(int from_index, int to_index) {
        int[] car_array = model.getCarArray(displayCode);
        int i;
        int moving_car = car_array[from_index];
        if (from_index > to_index) {
            for (i = from_index; i > to_index; i--) {
                car_array[i] = car_array[i - 1];
            }
        } else {
            for (i = from_index; i < to_index; i++) {
                car_array[i] = car_array[i + 1];
            }
        }
        car_array[to_index] = moving_car;
    }
",0
19658631,7,"    private static void dualPivotQuicksort(long[] a, int left, int right) {
        int sixth = (right - left + 1) / 6;
        int e1 = left + sixth;
        int e5 = right - sixth;
        int e3 = (left + right) >>> 1;
        int e4 = e3 + sixth;
        int e2 = e3 - sixth;
        long ae1 = a[e1], ae2 = a[e2], ae3 = a[e3], ae4 = a[e4], ae5 = a[e5];
        if (ae1 > ae2) {
            long t = ae1;
            ae1 = ae2;
            ae2 = t;
        }
        if (ae4 > ae5) {
            long t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        if (ae1 > ae3) {
            long t = ae1;
            ae1 = ae3;
            ae3 = t;
        }
        if (ae2 > ae3) {
            long t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae1 > ae4) {
            long t = ae1;
            ae1 = ae4;
            ae4 = t;
        }
        if (ae3 > ae4) {
            long t = ae3;
            ae3 = ae4;
            ae4 = t;
        }
        if (ae2 > ae5) {
            long t = ae2;
            ae2 = ae5;
            ae5 = t;
        }
        if (ae2 > ae3) {
            long t = ae2;
            ae2 = ae3;
            ae3 = t;
        }
        if (ae4 > ae5) {
            long t = ae4;
            ae4 = ae5;
            ae5 = t;
        }
        a[e1] = ae1;
        a[e3] = ae3;
        a[e5] = ae5;
        long pivot1 = ae2;
        a[e2] = a[left];
        long pivot2 = ae4;
        a[e4] = a[right];
        int less = left + 1;
        int great = right - 1;
        boolean pivotsDiffer = (pivot1 != pivot2);
        if (pivotsDiffer) {
            outer: for (int k = less; k <= great; k++) {
                long ak = a[k];
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else if (ak > pivot2) {
                    while (a[great] > pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = a[great];
                        a[great--] = ak;
                    }
                }
            }
        } else {
            for (int k = less; k <= great; k++) {
                long ak = a[k];
                if (ak == pivot1) {
                    continue;
                }
                if (ak < pivot1) {
                    if (k != less) {
                        a[k] = a[less];
                        a[less] = ak;
                    }
                    less++;
                } else {
                    while (a[great] > pivot1) {
                        great--;
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less++] = a[great];
                        a[great--] = ak;
                    } else {
                        a[k] = pivot1;
                        a[great--] = ak;
                    }
                }
            }
        }
        a[left] = a[less - 1];
        a[less - 1] = pivot1;
        a[right] = a[great + 1];
        a[great + 1] = pivot2;
        doSort(a, left, less - 2);
        doSort(a, great + 2, right);
        if (!pivotsDiffer) {
            return;
        }
        if (less < e1 && great > e5) {
            while (a[less] == pivot1) {
                less++;
            }
            while (a[great] == pivot2) {
                great--;
            }
            outer: for (int k = less; k <= great; k++) {
                long ak = a[k];
                if (ak == pivot2) {
                    while (a[great] == pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] == pivot1) {
                        a[k] = a[less];
                        a[less++] = pivot1;
                    } else {
                        a[k] = a[great];
                    }
                    a[great--] = pivot2;
                } else if (ak == pivot1) {
                    a[k] = a[less];
                    a[less++] = pivot1;
                }
            }
        }
        doSort(a, less, great);
    }
",1
13169829,7,"    public void remove() {
        if (position <= 0) {
            throw new IllegalStateException(""You can't remove an item until you've done at least one next()"");
        }
        if (list[position - 1] != null) {
            for (int i = position - 1; i < (list.length - 1); i++) {
                list[i] = list[i + 1];
            }
            list[list.length - 1] = null;
        }
    }
",1
22310637,7,"    public static Area getAreaForThreshold(double[][] data, double threshold) {
        Vector vec = new Vector(500000);
        System.out.println(""getAreaForThreshold("" + threshold + "")"");
        Area retarea = null;
        Area tmparea = null;
        Triangle[] triangles = null;
        Point2D.Float[] vert_xys = new Point2D.Float[4];
        double[] vert_values = new double[4];
        for (int a = 0; a < 4; a++) {
            vert_xys[a] = new Point2D.Float();
        }
        GeneralPath tmppath = new GeneralPath();
        for (int y = 0; y < data[0].length - 1; y++) {
            for (int x = 0; x < data.length - 1; x++) {
                vert_values[0] = data[x][y];
                vert_values[0] = data[x + 1][y];
                vert_values[0] = data[x + 1][y + 1];
                vert_values[0] = data[x][y + 1];
                vert_xys[0].x = (float) x;
                vert_xys[0].y = (float) y;
                vert_xys[1].x = (float) (x + 1);
                vert_xys[1].y = (float) y;
                vert_xys[2].x = (float) (x + 1);
                vert_xys[2].y = (float) (y + 1);
                vert_xys[3].x = (float) x;
                vert_xys[3].y = (float) (y + 1);
                triangles = SquareMarcher.marchSquare(vert_xys, vert_values, threshold);
                if (triangles != null) {
                    for (int a = 0; a < triangles.length; a++) vec.add(triangles[a]);
                }
            }
        }
        Triangle[] tris = new Triangle[vec.size()];
        vec.copyInto(tris);
        return getAreaForTriangles(tris);
    }
",1
21047708,7,"    public static H2dRefluxBcManager init(final H2dRefluxSourceInterface _s, final CtuluAnalyze _analyze) {
        final EfFrontierInterface frontieres = _s.getGrid().getFrontiers();
        int ptIdxGlobal;
        final H2dRefluxBcManager r = new H2dRefluxBcManager(_s.getGrid());
        final int n = frontieres.getNbFrontier();
        final RefluxMiddleFrontier[] bordByFrontier = new RefluxMiddleFrontier[n];
        final H2dRefluxBordIndexGeneral[] bordSpecifies = _s.getBords();
        final H2dRefluxBoundaryCondition[] cl3Temp = new H2dRefluxBoundaryCondition[3];
        for (int i = 0; i < n; i++) {
            final int nbPt = frontieres.getNbPt(i);
            final H2dRefluxBoundaryCondition[] cls = new H2dRefluxBoundaryCondition[nbPt];
            for (int j = 1; j < nbPt; j += 2) {
                ptIdxGlobal = frontieres.getIdxGlobal(i, j - 1);
                H2dRefluxBoundaryCondition cl = _s.getConditionLimite(ptIdxGlobal);
                if (cl == null) {
                    if (_analyze != null) {
                        _analyze.addError(H2dResource.getS(""Pas de cl pour le point de bord {0}"", CtuluLibString.getString(ptIdxGlobal)));
                    }
                    final H2dRefluxBoundaryCondition clN = new H2dRefluxBoundaryCondition();
                    clN.setIndexPt(ptIdxGlobal);
                    cls[j - 1] = clN;
                } else {
                    cl.initUsedEvol();
                    cls[j - 1] = cl;
                }
                cl3Temp[0] = cls[j - 1];
                if (j < (nbPt - 1)) {
                    ptIdxGlobal = frontieres.getIdxGlobal(i, j + 1);
                    cl = _s.getConditionLimite(ptIdxGlobal);
                    if (cl == null) {
                        if (_analyze != null) {
                            _analyze.addError(H2dResource.getS(""Pas de cl pour le point de bord {0}"", CtuluLibString.getString(ptIdxGlobal)));
                        }
                        final H2dRefluxBoundaryConditionMutable clN = new H2dRefluxBoundaryConditionMutable();
                        clN.setIndexPt(ptIdxGlobal);
                        cls[j + 1] = clN;
                    } else {
                        cl.initUsedEvol();
                        cls[j + 1] = cl;
                    }
                    cl3Temp[2] = cls[j + 1];
                }
                ptIdxGlobal = frontieres.getIdxGlobal(i, j);
                final H2dRefluxBordIndexGeneral bord = bordSpecifies == null ? null : H2dRefluxBordIndexGeneral.findBordWithIndex(ptIdxGlobal, bordSpecifies);
                H2dBoundaryType bordType = H2dRefluxBoundaryType.SOLIDE;
                cl = _s.getConditionLimite(ptIdxGlobal);
                if (cl == null) {
                    if (_analyze != null) {
                        _analyze.addFatalError(H2dResource.getS(""Pas de cl pour le point de bord {0}"", CtuluLibString.getString(ptIdxGlobal)));
                    }
                    return null;
                }
                if (bord == null) {
                    cl3Temp[1] = cl;
                    if (isOuvert(cl3Temp)) {
                        bordType = H2dRefluxBoundaryType.LIQUIDE;
                    }
                } else {
                    bordType = bord.getBordType();
                }
                if (bord != null && bordType == H2dRefluxBoundaryType.SOLIDE_FROTTEMENT) {
                    cl = new H2dRefluxBoundaryConditionMiddleFriction(cl);
                    cl.setValue(H2dVariableType.RUGOSITE, bord.getRugositeType(), bord.getRugosite(), bord.getRugositeTransitoireCourbe());
                } else {
                    cl = new H2dRefluxBoundaryConditionMiddle(cl, bordType);
                    if (bordType == H2dRefluxBoundaryType.LIQUIDE && cl.getHType() == H2dBcType.LIBRE && cl3Temp[0].getHType() != H2dBcType.LIBRE && cl3Temp[2].getHType() != H2dBcType.LIBRE) {
                        if (cl3Temp[0].getHType() == H2dBcType.PERMANENT && cl3Temp[2].getHType() == H2dBcType.PERMANENT) {
                            cl.setHTypePermanent((cl3Temp[0].getH() + cl3Temp[2].getH()) / 2);
                        } else {
                            if (cl3Temp[0].getHType() == H2dBcType.PERMANENT) {
                                cl.setH(cl3Temp[0].getH());
                            } else {
                                cl.setHTransitoire(cl3Temp[0].getHTransitoireCourbe());
                            }
                        }
                    }
                }
                cl.initUsedEvol();
                cl.setIndexPt(ptIdxGlobal);
                cls[j] = cl;
            }
            bordByFrontier[i] = r.createRefluxMiddleFrontier(i, cls);
        }
        r.bcFrontier_ = bordByFrontier;
        return r;
    }
",1
534543,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
3953792,7,"    public BranchOfSimulativeTest() {
        worldAABB = new AABB();
        worldAABB.lowerBound.set(-100, -100);
        worldAABB.upperBound.set(1500, 1000);
        debugDraw = new AngryPigDebugDraw(WIDTH, HEIGHT, 1.0f);
        mWorld = new World(worldAABB, new Vec2(0f, 40f), true);
        pig1 = new Pig();
        pig1.getSprite().setCenterX(ORIBALLPOSTION.x);
        pig1.getSprite().setCenterY(ORIBALLPOSTION.y);
        birds = new Bird[5];
        birds[0] = new Bird();
        birds[0].createBird(mWorld, 770, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[1] = new Bird();
        birds[1].createBird(mWorld, 800, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[2] = new Bird();
        birds[2].createBird(mWorld, 830, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[3] = new Bird();
        birds[3].createBird(mWorld, 860, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        birds[4] = new Bird();
        birds[4].createBird(mWorld, 890, GROUND_HEIGHT - birds[0].getSprite().getHeight() / 2, 2f, 0.8f, 0.2f);
        RectWood1 = new RectBaseElement(ResourceManager.getLargeWoodRectangleImages());
        RectWood1.create(mWorld, 700, 580);
        CircleWood2 = new CircleBaseElement(ResourceManager.getMiddleWoodBallImages());
        CircleWood2.create(mWorld, 711, 570, 2f, 0.8f, 0.2f, 10f);
        BattenWood3 = new RectBaseElement(ResourceManager.getShortWoodBattenImages());
        BattenWood3.create(mWorld, 900, 575, MathUtils.PI / 2);
        BattenWood4 = new RectBaseElement(ResourceManager.getBombImage());
        BattenWood4.getSprite().setUpdateTime(80);
        BattenWood4.getSprite().setActive(true);
        BattenWood4.create(mWorld, 930, 575, MathUtils.PI / 2);
        BattenWood5 = new RectBaseElement(ResourceManager.getShortWoodBattenImages());
        BattenWood5.create(mWorld, 915, 550);
        RectWood6 = new RectBaseElement(ResourceManager.getMiddleWoodRectangleImages());
        RectWood6.create(mWorld, 925, 540);
        BattenWood7 = new RectBaseElement(ResourceManager.getSmallWoodSquareImages());
        BattenWood7.create(mWorld, 930, 530);
        CircleWood8 = new CircleBaseElement(ResourceManager.getLargeWoodBallImages());
        CircleWood8.create(mWorld, 932, 510, 2.0f, 0.8f, 0.2f, 18f);
        new Ground(mWorld, 0, GROUND_HEIGHT, WIDTH, HEIGHT);
        nanos = new long[fpsAverageCount];
        long nanosPerFrameGuess = (long) (1000000000.0 / targetFPS);
        nanos[fpsAverageCount - 1] = System.nanoTime();
        for (int i = fpsAverageCount - 2; i >= 0; --i) {
            nanos[i] = nanos[i + 1] - nanosPerFrameGuess;
        }
        nanoStart = System.nanoTime();
        frameRatePeriod = (long) (1000000000.0 / targetFPS);
        add(panel);
    }
",1
17331711,7,"    protected short op_call() {
        int nlocals;
        int i;
        short thislocal;
        if (operands[0] == 0) {
            zm.set_variable(storevar, ZFALSE);
        } else {
            zm.zstack.push(new ZFrameBound(isstore()));
            zm.zstack.push(new Integer(storevar));
            zm.zstack.push(new Integer(zm.pc));
            zm.zstack.push(zm.locals);
            zm.pc = zm.routine_address(operands[0]);
            nlocals = zm.get_code_byte();
            zm.locals = new short[nlocals];
            for (i = 0; i < nlocals; i++) {
                thislocal = (short) (((zm.get_code_byte() << 8) & 0xFF00) | (zm.get_code_byte() & 0xFF));
                if (i < (count - 1)) {
                    zm.locals[i] = operands[i + 1];
                } else {
                    zm.locals[i] = thislocal;
                }
            }
        }
        return ZFALSE;
    }
",1
13190887,7,"    public void remove(int index) {
        for (int i = index; i < _size - 1; i++) {
            _array[i] = _array[i + 1];
        }
        _array[_size - 1] = null;
    }
",1
20490854,7,"    private char[] encodeToArray(byte[] ba) {
        boolean padDouble = false;
        boolean padSingle = false;
        int[] source = new int[3];
        int[] result = new int[4];
        int index = 0;
        char[] output = new char[((ba.length - 1) / 3 + 1) << 2];
        for (int i = 0; i < ba.length; i += 3) {
            source[0] = ba[i] & 0xff;
            if (i + 1 < ba.length) {
                source[1] = ba[i + 1] & 0xff;
            } else {
                padDouble = true;
                source[1] = 0;
            }
            if (i + 2 < ba.length) {
                source[2] = ba[i + 2] & 0xff;
            } else {
                padSingle = true;
                source[2] = 0;
            }
            split3to4(source, result);
            output[index++] = encodeSet[result[0]];
            output[index++] = encodeSet[result[1]];
            output[index++] = padDouble ? PADCHAR : encodeSet[result[2]];
            output[index++] = padSingle ? PADCHAR : encodeSet[result[3]];
        }
        return output;
    }
",1
1197769,7,"    public void put(Rectangle2D.Double ext) {
        if ((ext != null) && ((num < 1) || (ext != extents[num - 1]))) {
            if (num < (NUMREC)) {
                extents[num] = ext;
                num = num + 1;
            } else {
                for (int i = 0; i < (NUMREC - 1); i++) {
                    extents[i] = extents[i + 1];
                }
                extents[num - 1] = ext;
            }
        }
    }
",1
7883040,7,"    void loop_mul(int mwidth, TBSymbol v[], TBSymbol z[], TBSymbol b_in, BigInteger poly) {
        TBSymbol tmp;
        TBSymbol newv[];
        newv = new TBSymbol[mwidth];
        for (int i = 0; i < mwidth; i = i + 1) {
            tmp = new TBSymOperator(z[i], new TBSymOperator(v[i], b_in, '&'), '^');
            z[i] = tmp;
        }
        for (int i = 0; i < (mwidth - 1); i++) {
            if (poly.testBit(i)) newv[i] = new TBSymOperator(v[0], v[i + 1], '^'); else newv[i] = v[i + 1];
        }
        newv[mwidth - 1] = v[0];
        for (int i = 0; i < mwidth; i++) v[i] = newv[i];
    }
",0
9966590,7,"    public void removeRoot(ActuatorContainer root) {
        for (int i = 0; i < acCount; i++) {
            if (acs[i] == root) {
                acs[i] = acs[i + 1];
                root = acs[i];
            }
        }
        acCount--;
    }
",1
18547061,7,"    private static void CloseSocket() {
        int sockNum, i;
        ECBClass tmpECB = ECBList;
        ECBClass tmp2ECB = ECBList;
        sockNum = swapByte(CPU_Regs.reg_edx.word());
        if (!sockInUse(sockNum)) return;
        for (i = 0; i < socketCount - 1; i++) {
            if (opensockets[i] == sockNum) {
                for (int j = i; j < SOCKETTABLESIZE - 1; j++) opensockets[j] = opensockets[j + 1];
                break;
            }
        }
        --socketCount;
        while (tmpECB != null) {
            tmp2ECB = tmpECB.nextECB;
            if (tmpECB.getSocket() == sockNum) {
                tmpECB.setCompletionFlag(COMP_CANCELLED);
                tmpECB.setInUseFlag(USEFLAG_AVAILABLE);
                tmpECB.close();
            }
            tmpECB = tmp2ECB;
        }
    }
",1
22737498,7,"        public URIInfo(String uri) {
            m_id = null;
            m_params = null;
            String[] ids = extractID(uri);
            if (ids != null && ids.length >= 1) {
                m_id = ids[0];
                if (ids.length > 1) {
                    m_params = new String[ids.length - 1];
                    for (int i = 0; i < m_params.length; i++) {
                        m_params[i] = ids[i + 1];
                    }
                }
            }
        }
",1
6989890,7,"    protected void computeCoefficients() {
        final int n = degree() + 1;
        coefficients = new double[n];
        for (int i = 0; i < n; i++) {
            coefficients[i] = 0.0;
        }
        final double[] c = new double[n + 1];
        c[0] = 1.0;
        for (int i = 0; i < n; i++) {
            for (int j = i; j > 0; j--) {
                c[j] = c[j - 1] - c[j] * x[i];
            }
            c[0] *= -x[i];
            c[i + 1] = 1;
        }
        final double[] tc = new double[n];
        for (int i = 0; i < n; i++) {
            double d = 1;
            for (int j = 0; j < n; j++) {
                if (i != j) {
                    d *= x[i] - x[j];
                }
            }
            final double t = y[i] / d;
            tc[n - 1] = c[n];
            coefficients[n - 1] += t * tc[n - 1];
            for (int j = n - 2; j >= 0; j--) {
                tc[j] = c[j + 1] + tc[j + 1] * x[i];
                coefficients[j] += t * tc[j];
            }
        }
        coefficientsComputed = true;
    }
",1
5475040,7,"    public void reverseRGB(final byte[] image) {
        byte swap;
        for (int i = 0; i < image.length; i += RGB_CHANNELS) {
            swap = image[i];
            image[i] = image[i + 2];
            image[i + 2] = swap;
        }
    }
",1
3178134,7,"    private static void dualPivotQuicksort(final int[] a, final int low, final int high) {
        if (high - low < 31) {
            insertionsort0(a, low, high + 1);
            return;
        }
        final int seventh = (high - low + 1 >>> 3) + (high - low + 1 >>> 6) + 1;
        final int e3 = low + high >>> 1;
        final int e2 = e3 - seventh;
        final int e1 = e2 - seventh;
        final int e4 = e3 + seventh;
        final int e5 = e4 + seventh;
        if (a[e2] < a[e1]) {
            final int t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }
        if (a[e3] < a[e2]) {
            final int t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (t < a[e1]) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (a[e4] < a[e3]) {
            final int t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (t < a[e2]) {
                a[e3] = a[e2];
                a[e2] = t;
                if (t < a[e1]) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (a[e5] < a[e4]) {
            final int t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (t < a[e3]) {
                a[e4] = a[e3];
                a[e3] = t;
                if (t < a[e2]) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (t < a[e1]) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }
        final int pivot1, pivot2;
        int left = low;
        int right = high;
        if ((pivot1 = a[e2]) != (pivot2 = a[e4])) {
            a[e2] = a[low];
            a[e4] = a[high];
            while (a[++left] < pivot1) {
            }
            while (a[--right] > pivot2) {
            }
            outer: for (int k = left; k <= right; k++) {
                final int ak = a[k];
                if (ak < pivot1) {
                    a[k] = a[left];
                    a[left] = ak;
                    left++;
                } else if (ak > pivot2) {
                    while (a[right] > pivot2) {
                        if (right-- == k) break outer;
                    }
                    if (a[right] < pivot1) {
                        a[k] = a[left];
                        a[left] = a[right];
                        left++;
                    } else {
                        a[k] = a[right];
                    }
                    a[right] = ak;
                    right--;
                }
            }
            a[low] = a[left - 1];
            a[left - 1] = pivot1;
            a[high] = a[right + 1];
            a[right + 1] = pivot2;
            dualPivotQuicksort(a, low, left - 2);
            dualPivotQuicksort(a, right + 2, high);
            if (left < e1 && e5 < right) {
                while (a[left] == pivot1) left++;
                while (a[right] == pivot2) right--;
                outer: for (int k = left; k <= right; k++) {
                    final int ak = a[k];
                    if (ak == pivot1) {
                        a[k] = a[left];
                        a[left] = ak;
                        left++;
                    } else if (ak == pivot2) {
                        while (a[right] == pivot2) {
                            if (right-- == k) break outer;
                        }
                        if (a[right] == pivot1) {
                            a[k] = a[left];
                            a[left] = pivot1;
                            left++;
                        } else {
                            a[k] = a[right];
                        }
                        a[right] = ak;
                        right--;
                    }
                }
            }
            dualPivotQuicksort(a, left, right);
        } else {
            for (int k = low; k <= right; k++) {
                if (a[k] == pivot1) continue;
                final int ak = a[k];
                if (ak < pivot1) {
                    a[k] = a[left];
                    a[left] = ak;
                    left++;
                } else {
                    while (a[right] > pivot1) {
                        right--;
                    }
                    if (a[right] < pivot1) {
                        a[k] = a[left];
                        a[left] = a[right];
                        left++;
                    } else {
                        a[k] = pivot1;
                    }
                    a[right] = ak;
                    right--;
                }
            }
            dualPivotQuicksort(a, low, left - 1);
            dualPivotQuicksort(a, right + 1, high);
        }
    }
",0
21128746,7,"    public void remove(int idx) {
        count--;
        for (int i = idx; i < count; i++) {
            values[i] = values[i + 1];
            indexes[i] = indexes[i + 1];
            priorities[i] = priorities[i + 1];
        }
    }
",0
18034259,7,"    public static void novo_dia(double p, int volume, double dias[]) {
        p = pvt(p, volume);
        for (int i = 0; i < PERIODO - 1; i++) dias[i] = dias[i + 1];
        dias[PERIODO - 1] = p;
    }
",1
10089157,7,"    public static double compute(final Evaluator F, final double a, final double b, final int nstart, final double eps, final int maxiter) throws ConstructionException {
        final double t[] = new double[maxiter];
        int n = nstart;
        double h = (b - a) / n;
        double tlast = t[0] = (F.evaluateF(a) + F.evaluateF(b) + 2 * sumUp(F, a + h, h, n - 2)) * h / 2;
        double old = t[0];
        for (int i = 1; i < maxiter; i++) {
            h = h / 2;
            n = n * 2;
            t[i] = tlast / 2 + sumUp(F, a + h, 2 * h, n / 2 - 1) * h;
            tlast = t[i];
            double q = 4;
            for (int j = i - 1; j >= 0; j--) {
                t[j] = t[j + 1] + (t[j + 1] - t[j]) / (q - 1);
                q = q * 4;
            }
            final double res = t[0];
            if (Math.abs((res - old) / res) < eps) return res;
            old = res;
        }
        return tlast;
    }
",1
14305024,7,"    public String[] getItemIndex(Component c, Element e, String[] index) {
        int indice = 2 * Integer.parseInt(index[0]);
        String[] out = new String[4];
        for (int i = 0; i < 4; i++) {
            out[i] = null;
        }
        Element parent = e;
        String childName = null;
        String childRole = null;
        String[] children = null;
        AccessibleContext menu = c.getAccessibleContext();
        Accessible child = null;
        int count = menu.getAccessibleChildrenCount();
        if (count != 0) {
            children = new String[(2 * count)];
            for (int i = 0; i < (2 * count); i++) {
                children[i] = null;
            }
        }
        if (children != null) {
            int j = 0;
            for (int i = 0; i < count; i++) {
                child = menu.getAccessibleChild(i);
                childName = child.getAccessibleContext().getAccessibleName();
                childRole = child.getAccessibleContext().getAccessibleRole().toDisplayString(Locale.UK);
                if (stringToRole(childRole) != null) {
                    children[j] = childName;
                    children[j + 1] = childRole;
                    j = j + 2;
                }
            }
            out[0] = children[indice];
            out[1] = children[indice + 1];
            out[2] = parent.getAttributeValue(""accessibleName"");
            out[3] = parent.getAttributeValue(""accessibleRole"");
        } else {
            out = null;
        }
        return out;
    }
",0
268630,7,"    public RatPoly differentiate() {
        if (deg == 0) return ZERO;
        RatPoly deriv = new RatPoly(BigRational.ZERO, deg - 1);
        for (int i = 0; i < deg; i++) deriv.coef[i] = coef[i + 1].times(new BigRational(i + 1));
        deriv.deg = deriv.degree();
        return deriv;
    }
",1
12372437,7,"        public void run() {
            logger.debug(""Starting thread."");
            while (isConnected()) {
                len = 0;
                try {
                    len = eibReader.read(cbuf);
                    if (len > 32) {
                        logger.debug(""unallowed data block length ("" + len + "")"");
                    } else if (len > 0) {
                        logger.debug(""BCU1 receiving data."");
                        if (cbuf[0] == 0x49 || cbuf[0] == 0x4e || cbuf[0] == 0x4b) {
                            int eibdata[] = new int[len + 1];
                            int apci;
                            if (cbuf[0] == 0x4e || cbuf[0] == 0x4b) {
                                for (int i = len - 1; i >= 0; i--) {
                                    con[i] = (byte) cbuf[i];
                                }
                            }
                            if (cbuf[0] == 0x49 || cbuf[0] == 0x4e) {
                                for (int i = 0; i < len - 1; i++) {
                                    eibdata[i] = cbuf[i + 1];
                                }
                                frames.addElement(eibdata);
                                String s = """";
                                for (int i = 0; i < len; i++) {
                                    s += Integer.toHexString(cbuf[i]) + "" "";
                                }
                                logger.debug(""unexpected data block received ("" + s + "")"");
                            }
                        } else {
                            String s = """";
                            for (int i = 0; i < len; i++) {
                                s += Integer.toHexString(cbuf[i]) + "" "";
                            }
                            logger.debug(""unexpected data block received ("" + s + "")"");
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println(""cdd"");
                }
            }
        }
",1
11794829,7,"    public void actionPerformed(ActionEvent e) {
        Object src = e.getSource();
        errorText.setText("""");
        if (src == exit) {
            System.exit(0);
        } else if (src == start) {
            start.setEnabled(false);
            stop.setEnabled(true);
            reset.setEnabled(true);
            restart.setEnabled(true);
            GTM.start();
        } else if (src == stop) {
            stop.setEnabled(false);
            start.setEnabled(true);
            reset.setEnabled(true);
            restart.setEnabled(true);
            GTM.stop();
        } else if (src == reset) {
            reset.setEnabled(false);
            start.setEnabled(true);
            stop.setEnabled(false);
            restart.setEnabled(false);
            GTM.resetHard();
        } else if (src == restart) {
            GTM.restartHard();
        } else if (src == autoReset) {
            if (autoReset.isSelected()) GTM.setAutoReset(true); else GTM.setAutoReset(false);
        } else if (src == speedField) {
            int speed;
            try {
                speed = Integer.parseInt(speedField.getText());
                if (speed < GTM.MIN_PPTICK || speed > GTM.MAX_PPTICK) errorText.setText(""Error: speed value out of range.""); else GTM.setPixelsPerTick(speed);
            } catch (NumberFormatException x) {
                errorText.setText(""Error: illegal numeric format for speed."");
            }
        } else if (src == addThread) {
            int count, delay, times, numThreads;
            try {
                count = Integer.parseInt(nullthrCount.getText());
                delay = Integer.parseInt(nullthrDelay.getText());
                times = Integer.parseInt(nullthrTimes.getText());
                numThreads = GTM.getNumOfThreads();
                nullthr[numThreads] = new NullThread(count, delay, times, new Integer(++nullCount).toString());
                nullthr[numThreads].setInitSleep(nullthrSleep.isSelected());
                nullthr[numThreads].setMessages(true);
                nullthr[numThreads].setPriority(Thread.MIN_PRIORITY);
                GTM.addThread(nullthr[numThreads]);
                nullthr[numThreads].start();
                if (++numThreads == GTM.MAX_THREADS) addThread.setEnabled(false);
                removeThread.setEnabled(true);
                removeAllThreads.setEnabled(true);
            } catch (NumberFormatException x) {
                errorText.setText(""Error: illegal numeric format in thread values."");
            }
        } else if (src == removeThread) {
            int index, numThreads;
            try {
                index = Integer.parseInt(removeThrIndex.getText());
                numThreads = GTM.getNumOfThreads();
                if (index < 0 || index > numThreads - 1) errorText.setText(""Error: thread index out of bounds.""); else {
                    GTM.removeThread(index);
                    if (--numThreads == 0) {
                        removeThread.setEnabled(false);
                        removeAllThreads.setEnabled(false);
                    }
                    addThread.setEnabled(true);
                    nullthr[index].kill();
                    int i;
                    for (i = index; i < numThreads; ++i) nullthr[i] = nullthr[i + 1];
                    nullthr[i] = null;
                }
            } catch (NumberFormatException x) {
                errorText.setText(""Error: illegal numeric format in thread index."");
            }
        } else if (src == removeAllThreads) {
            int numThreads = GTM.getNumOfThreads();
            GTM.removeAllThreads();
            addThread.setEnabled(true);
            removeThread.setEnabled(false);
            removeAllThreads.setEnabled(false);
            for (int i = 0; i < numThreads; ++i) {
                nullthr[i].kill();
                nullthr[i] = null;
            }
        } else if (src == addObject) {
            int key = 0;
            int numThreads = GTM.getNumOfObjects();
            if (randInt.isSelected()) key += RandThread.R_I;
            if (randLong.isSelected()) key += RandThread.R_L;
            if (randFloat.isSelected()) key += RandThread.R_F;
            if (randDouble.isSelected()) key += RandThread.R_D;
            randthr[numThreads] = new RandThread(key, new Integer(++randCount).toString());
            randthr[numThreads].setPriority(Thread.MIN_PRIORITY);
            randthr[numThreads].start();
            GTM.addObject(randthr[numThreads]);
            if (++numThreads == GTM.MAX_OBJECTS) addObject.setEnabled(false);
            removeObject.setEnabled(true);
            removeAllObjects.setEnabled(true);
        } else if (src == removeObject) {
            int index, numThreads;
            try {
                index = Integer.parseInt(removeObjIndex.getText());
                numThreads = GTM.getNumOfObjects();
                if (index < 0 || index > GTM.getNumOfObjects() - 1) errorText.setText(""Error: object index out of bounds.""); else {
                    GTM.removeObject(index);
                    if (--numThreads == 0) {
                        removeObject.setEnabled(false);
                        removeAllObjects.setEnabled(false);
                    }
                    addObject.setEnabled(true);
                    randthr[index].kill();
                    int i;
                    for (i = index; i < numThreads; ++i) randthr[i] = randthr[i + 1];
                    randthr[i] = null;
                }
            } catch (NumberFormatException x) {
                errorText.setText(""Error: illegal numeric format in object index."");
            }
        } else if (src == removeAllObjects) {
            int numThreads = GTM.getNumOfObjects();
            GTM.removeAllObjects();
            addObject.setEnabled(true);
            removeObject.setEnabled(false);
            removeAllObjects.setEnabled(false);
            for (int i = 0; i < numThreads; ++i) {
                randthr[i].kill();
                randthr[i] = null;
            }
        }
    }
",1
13658711,7,"    private void getNextChangingElement(int a0, boolean isWhite, int[] ret) {
        int[] pce = this.prevChangingElems;
        int ces = this.changingElemSize;
        int start = (lastChangingElement > 0) ? (lastChangingElement - 1) : 0;
        if (isWhite) {
            start &= ~0x1;
        } else {
            start |= 0x1;
        }
        int i = start;
        for (; i < ces; i += 2) {
            int temp = pce[i];
            if (temp > a0) {
                lastChangingElement = i;
                ret[0] = temp;
                break;
            }
        }
        if ((i + 1) < ces) {
            ret[1] = pce[i + 1];
        }
    }
",1
18334911,7,"    private void extendRuns(EnumStructure[] tags) {
        for (int i = 1; i < monomerCount - 4; ++i) if (tags[i] == EnumStructure.NONE && tags[i + 1] != EnumStructure.NONE) tags[i] = tags[i + 1];
        tags[0] = tags[1];
        tags[monomerCount - 1] = tags[monomerCount - 2];
    }
",1
7366450,7,"    public Spline(double[] x, double[] y) {
        int n = x.length;
        this.x = x;
        this.y = y;
        z = new double[n];
        double[] h = new double[n], d = new double[n];
        z[0] = z[n - 1] = 0;
        for (int i = 0; i < n - 1; i++) {
            h[i] = x[i + 1] - x[i];
            d[i + 1] = (y[i + 1] - y[i]) / h[i];
        }
        z[1] = d[2] - d[1] - h[0] * z[0];
        d[1] = 2 * (x[2] - x[0]);
        for (int i = 1; i < n - 2; i++) {
            double t = h[i] / d[i];
            z[i + 1] = d[i + 2] - d[i + 1] - z[i] * t;
            d[i + 1] = 2 * (x[i + 2] - x[i]) - h[i] * t;
        }
        z[n - 2] -= h[n - 2] * z[n - 1];
        for (int i = n - 2; i > 0; i--) z[i] = (z[i] - h[i] * z[i + 1]) / d[i];
    }
",0
12357583,7,"    public void setHeader(int headerID, Object headerValue) {
        int i;
        for (i = 0; h_id[i] != headerID && i < h_val.size(); i++) ;
        if (h_val.size() == max_id_no) {
            Debug.println(BCC.DEBUG_LEVEL_WARN, ""Max number of header sets reached - change "" + ""the value of OBEXHeaderSet.max_id_no if needed"");
        } else {
            if (headerValue == null) {
                for (int j = i; j < (h_val.size() - 1); j++) {
                    h_id[j] = h_id[j + 1];
                }
                if (i < h_val.size()) {
                    h_val.remove(i);
                    Debug.println(BCC.DEBUG_LEVEL_INFO, ""Removed header with "" + ""header ID "" + OBEXHeaderSet.hex((byte) headerID));
                } else {
                    Debug.println(BCC.DEBUG_LEVEL_WARN, ""Header with header ID "" + OBEXHeaderSet.hex((byte) headerID) + "" does not exist in this header set - nothing to remove"");
                }
            } else {
                if (i == h_val.size()) h_id[i] = headerID;
                if ((headerID & 0xc0) != 0x00 && headerValue instanceof String) {
                    int pos = 0;
                    int hvLen = ((String) headerValue).length();
                    byte[] typeHV = new byte[hvLen];
                    for (pos = 0; pos < hvLen; pos++) {
                        typeHV[pos] = (byte) (((String) headerValue).charAt(pos) & 0xff);
                    }
                    h_val.add(typeHV);
                } else {
                    h_val.add(headerValue);
                }
            }
        }
    }
",1
2235436,7,"    private LinkedList<Datum> calculateBLUEsFromPhenotypes(MarkerPhenotypeAdapter mpa, String datasetName) {
        if (isInteractive()) {
            String msg = ""The data set you have selected does not contain any marker data. Do you want to calculate BLUEs (best linear unbiased estimates) of the phenotypes?"";
            String title = ""Calculate BLUEs"";
            int action = JOptionPane.showConfirmDialog(getParentFrame(), msg, title, JOptionPane.YES_NO_OPTION);
            if (action != JOptionPane.YES_OPTION) return null;
        }
        LinkedList<Datum> theResults = new LinkedList<Datum>();
        LinkedList<Object[]> anovaResults = new LinkedList<Object[]>();
        LinkedList<double[]> blueList = new LinkedList<double[]>();
        ArrayList<ArrayList<Object>> taxaListList = new ArrayList<ArrayList<Object>>();
        int numberOfCovariates = mpa.getNumberOfCovariates();
        int numberOfFactors = mpa.getNumberOfFactors();
        int numberOfPhenotypes = mpa.getNumberOfPhenotypes();
        for (int ph = 0; ph < numberOfPhenotypes; ph++) {
            double[] phenotypeData = mpa.getPhenotypeValues(ph);
            boolean[] missing = mpa.getMissingPhenotypes(ph);
            ArrayList<String[]> factorList = MarkerPhenotypeAdapterUtils.getFactorList(mpa, ph, missing);
            ArrayList<double[]> covariateList = MarkerPhenotypeAdapterUtils.getCovariateList(mpa, ph, missing);
            int[] nonmissingRows = MarkerPhenotypeAdapterUtils.getNonMissingIndex(missing);
            int numberOfObs = nonmissingRows.length;
            double[] y = new double[numberOfObs];
            for (int i = 0; i < numberOfObs; i++) {
                y[i] = phenotypeData[nonmissingRows[i]];
            }
            ArrayList<ModelEffect> modelEffects = new ArrayList<ModelEffect>();
            FactorModelEffect meanEffect = new FactorModelEffect(new int[numberOfObs], false);
            meanEffect.setID(""mean"");
            modelEffects.add(meanEffect);
            Identifier[] alltaxa = mpa.getTaxa(ph);
            Identifier[] taxa = new Identifier[numberOfObs];
            ArrayList<Object> taxaIds = new ArrayList<Object>();
            for (int i = 0; i < numberOfObs; i++) {
                taxa[i] = alltaxa[nonmissingRows[i]];
            }
            int[] taxaLevels = ModelEffectUtils.getIntegerLevels(taxa, taxaIds);
            taxaListList.add(taxaIds);
            FactorModelEffect taxaEffect = new FactorModelEffect(taxaLevels, true, ""Taxa"");
            modelEffects.add(taxaEffect);
            if (numberOfFactors > 0) {
                for (int f = 0; f < numberOfFactors; f++) {
                    String[] afactor = factorList.get(f);
                    String[] factorLabels = new String[numberOfObs];
                    for (int i = 0; i < numberOfObs; i++) factorLabels[i] = afactor[nonmissingRows[i]];
                    FactorModelEffect fme = new FactorModelEffect(ModelEffectUtils.getIntegerLevels(factorLabels), true, mpa.getFactorName(f));
                    modelEffects.add(fme);
                }
            }
            if (numberOfCovariates > 0) {
                for (int c = 0; c < numberOfCovariates; c++) {
                    double[] covar = new double[numberOfObs];
                    double[] covariateData = covariateList.get(c);
                    for (int i = 0; i < numberOfObs; i++) covar[i] = covariateData[nonmissingRows[i]];
                    modelEffects.add(new CovariateModelEffect(covar, mpa.getCovariateName(c)));
                }
            }
            SweepFastLinearModel sflm = new SweepFastLinearModel(modelEffects, y);
            double[] taxaSSdf = sflm.getMarginalSSdf(1);
            double[] modelSSdf = sflm.getFullModelSSdf();
            double[] errorSSdf = sflm.getResidualSSdf();
            double[] beta = sflm.getBeta();
            double F, p;
            F = taxaSSdf[0] / taxaSSdf[1] / errorSSdf[0] * errorSSdf[1];
            try {
                p = LinearModelUtils.Ftest(F, taxaSSdf[1], errorSSdf[1]);
            } catch (Exception e) {
                p = Double.NaN;
            }
            Object[] result = new Object[9];
            result[0] = mpa.getPhenotypeName(ph);
            result[1] = new Double(F);
            result[2] = new Double(p);
            result[3] = new Double(taxaSSdf[1]);
            result[4] = new Double(taxaSSdf[0] / taxaSSdf[1]);
            result[5] = new Double(errorSSdf[1]);
            result[6] = new Double(errorSSdf[0] / errorSSdf[1]);
            result[7] = new Double(modelSSdf[1]);
            result[8] = new Double(modelSSdf[0] / modelSSdf[1]);
            anovaResults.add(result);
            double overallMean = beta[0];
            int nEffects = modelEffects.size();
            int start = 0;
            for (int i = 1; i < nEffects; i++) {
                ModelEffect me = modelEffects.get(i);
                if (me instanceof FactorModelEffect && !me.getID().equals(""Taxa"")) {
                    FactorModelEffect fme = (FactorModelEffect) me;
                    int nLevels = fme.getNumberOfLevels();
                    int nEstimates;
                    if (fme.getRestricted()) {
                        nEstimates = nLevels - 1;
                    } else {
                        nEstimates = nLevels;
                    }
                    double factorMean = 0;
                    for (int j = 0; j < nEstimates; j++) {
                        factorMean += beta[j + start];
                    }
                    factorMean /= nLevels;
                    overallMean += factorMean;
                    start += nEstimates;
                } else {
                    start += me.getNumberOfLevels();
                }
            }
            int n = taxaIds.size();
            double[] blues = new double[n];
            for (int i = 0; i < n - 1; i++) {
                blues[i] = beta[i + 1] + overallMean;
            }
            blues[n - 1] = overallMean;
            blueList.add(blues);
            taxaListList.add(taxaIds);
        }
        String[] anovaColumnLabels = new String[] { ""Trait"", ""F"", ""p"", ""taxaDF"", ""taxaMS"", ""errorDF"", ""errorMS"", ""modelDF"", ""modelMS"" };
        Object[][] table = new Object[anovaResults.size()][];
        anovaResults.toArray(table);
        String datumName = ""Phenotype ANOVA from "" + datasetName;
        StringBuilder datumComments = new StringBuilder(""ANOVA for Phenotypes using GLM\n"");
        datumComments.append(""Data set: "").append(datasetName);
        datumComments.append(""\nmodel: trait = mean + taxa"");
        for (int i = 0; i < mpa.getNumberOfFactors(); i++) {
            datumComments.append("" + "");
            datumComments.append(mpa.getFactorName(i));
        }
        for (int i = 0; i < mpa.getNumberOfCovariates(); i++) {
            datumComments.append("" + "");
            datumComments.append(mpa.getCovariateName(i));
        }
        SimpleTableReport str = new SimpleTableReport(datumName, anovaColumnLabels, table);
        Datum theAnova = new Datum(datumName, str, datumComments.toString());
        theResults.add(theAnova);
        TreeSet<Identifier> taxaSet = new TreeSet<Identifier>();
        for (ArrayList<Object> list : taxaListList) {
            for (Object taxon : list) taxaSet.add((Identifier) taxon);
        }
        HashMap<Identifier, Integer> taxaMap = new HashMap<Identifier, Integer>();
        int count = 0;
        for (Identifier taxon : taxaSet) {
            taxaMap.put(taxon, count++);
        }
        String[] blueColumnLabels = new String[numberOfPhenotypes + 1];
        blueColumnLabels[0] = ""Taxa"";
        for (int i = 0; i < numberOfPhenotypes; i++) {
            blueColumnLabels[i + 1] = mpa.getPhenotypeName(i);
        }
        int nrows = taxaSet.size();
        double[][] blues = new double[nrows][numberOfPhenotypes];
        for (int r = 0; r < nrows; r++) {
            for (int c = 0; c < numberOfPhenotypes; c++) {
                blues[r][c] = Double.NaN;
            }
        }
        LinkedList<Trait> traitList = new LinkedList<Trait>();
        for (int c = 0; c < numberOfPhenotypes; c++) {
            traitList.add(new Trait(mpa.getPhenotypeName(c), false, Trait.TYPE_DATA));
            double[] pheno = blueList.get(c);
            int n = pheno.length;
            ArrayList<Object> taxaList = taxaListList.get(c);
            for (int i = 0; i < n; i++) {
                int ndx = taxaMap.get(taxaList.get(i));
                if (ndx > -1) blues[ndx][c] = pheno[i];
            }
        }
        Identifier[] taxaIds = new Identifier[taxaSet.size()];
        taxaSet.toArray(taxaIds);
        Phenotype thePhenotype = new SimplePhenotype(new SimpleIdGroup(taxaIds), traitList, blues);
        theResults.add(new Datum(""BLUEs_"" + datasetName, thePhenotype, ""BLUEs calculated from "" + datasetName));
        return theResults;
    }
",1
17845910,7,"        double pop() {
            double result = r[0];
            for (int i = 0; i < 3; i++) {
                r[i] = r[i + 1];
            }
            return result;
        }
",1
12450259,7,"    public void randomize(IntegerChromosome chrom, int min, int max) {
        int len = max - min + 1;
        int[] base = new int[len];
        for (int i = 0; i < len; i++) base[i] = chrom.getValue(min + i);
        for (int i = 0; len > 0; --len, ++i) {
            int pos = Random.getInstance().nextInt(0, len);
            chrom.setValue(min + i, base[pos]);
            for (int j = pos; j < (len - 1); j++) {
                base[j] = base[j + 1];
            }
        }
    }
",1
937654,7,"    public void run() {
        VM_Controller.boot();
        VM_ApplicationClassLoader.setPathProperty();
        ClassLoader cl = new VM_ApplicationClassLoader(VM_SystemClassLoader.getVMClassLoader());
        String[] mainArgs = null;
        VM_Class cls = null;
        try {
            cls = (VM_Class) cl.loadClass(args[0], true).getVMType();
        } catch (ClassNotFoundException e) {
            VM.sysWrite(e + ""\n"");
            return;
        }
        mainMethod = cls.findMainMethod();
        if (mainMethod == null) {
            VM.sysWrite(cls.getName() + "" doesn't have a \""public static void main(String[])\"" method to execute\n"");
            return;
        }
        mainArgs = new String[args.length - 1];
        for (int i = 0, n = mainArgs.length; i < n; ++i) mainArgs[i] = args[i + 1];
        mainMethod.compile();
        VM_Callbacks.notifyStartup();
        VM.debugBreakpoint();
        VM_Magic.invokeMain(mainArgs, mainMethod.getCurrentCompiledMethod().getInstructions());
    }
",1
13716366,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
",1
7765115,7,"    private void svd(float[][] mat, float[] s, float[][] u, float[][] v, float progStop, boolean noProg) {
        final int m = mat.length;
        final int n = mat[0].length;
        final int nu = Math.min(m, n);
        final int ns = Math.min(m + 1, n);
        final boolean wantu = u != null;
        final boolean wantv = v != null;
        if ((s.length != ns) || (wantu && ((u.length != m) || (u[0].length != nu))) || (wantv && ((v.length != n) || (v[0].length != n)))) throw new IllegalArgumentException();
        final float[] e = new float[n];
        final float[] work = new float[m];
        final float eps = (float) Math.pow(2.0, -48.0);
        final float tiny = (float) Math.pow(2.0, -120.0);
        final int nct = Math.min(m - 1, n);
        final int nrt = Math.max(0, Math.min(n - 2, m));
        final int nk = Math.max(nct, nrt);
        final int np = Math.min(n, m + 1);
        final float progOff = getProgression();
        final float progW = (progStop - progOff) / (((long) nk * (nk + 1) / 2) + ((long) np * (np + 1) / 2) + (wantu ? ((long) nct * (nct + 1) / 2) : 0) + (wantv ? n : 0));
        long progC = 0;
        for (int k = 0; (k < nk) && (noProg || threadRunning); k++) {
            if (k < nct) {
                s[k] = 0;
                for (int i = k; i < m; i++) {
                    s[k] = hypot(s[k], mat[i][k]);
                }
                if (s[k] != 0.0f) {
                    if (mat[k][k] < 0.0f) {
                        s[k] = -s[k];
                    }
                    for (int i = k; i < m; i++) {
                        mat[i][k] /= s[k];
                    }
                    mat[k][k] += 1.0f;
                }
                s[k] = -s[k];
            }
            for (int j = k + 1; j < n; j++) {
                if ((k < nct) && (s[k] != 0.0f)) {
                    float t = 0;
                    for (int i = k; i < m; i++) {
                        t += mat[i][k] * mat[i][j];
                    }
                    t = -t / mat[k][k];
                    for (int i = k; i < m; i++) {
                        mat[i][j] += t * mat[i][k];
                    }
                }
                e[j] = mat[k][j];
            }
            if (wantu && (k < nct)) {
                for (int i = k; i < m; i++) {
                    u[i][k] = mat[i][k];
                }
            }
            if (k < nrt) {
                e[k] = 0;
                for (int i = k + 1; i < n; i++) {
                    e[k] = hypot(e[k], e[i]);
                }
                if (e[k] != 0.0f) {
                    if (e[k + 1] < 0.0f) {
                        e[k] = -e[k];
                    }
                    for (int i = k + 1; i < n; i++) {
                        e[i] /= e[k];
                    }
                    e[k + 1] += 1.0f;
                }
                e[k] = -e[k];
                if (((k + 1) < m) && (e[k] != 0.0f)) {
                    for (int i = k + 1; i < m; i++) {
                        work[i] = 0.0f;
                    }
                    for (int j = k + 1; j < n; j++) {
                        for (int i = k + 1; i < m; i++) {
                            work[i] += e[j] * mat[i][j];
                        }
                    }
                    for (int j = k + 1; j < n; j++) {
                        final float t = -e[j] / e[k + 1];
                        for (int i = k + 1; i < m; i++) {
                            mat[i][j] += t * work[i];
                        }
                    }
                }
                if (wantv) {
                    for (int i = k + 1; i < n; i++) {
                        v[i][k] = e[i];
                    }
                }
            }
            progC += (nk - k);
            setProgression(progC * progW + progOff);
        }
        if (!(noProg || threadRunning)) return;
        int p = np;
        if (nct < n) {
            s[nct] = mat[nct][nct];
        }
        if (m < p) {
            s[p - 1] = 0.0f;
        }
        if ((nrt + 1) < p) {
            e[nrt] = mat[nrt][p - 1];
        }
        e[p - 1] = 0.0f;
        if (wantu) {
            for (int j = nct; j < nu; j++) {
                for (int i = 0; i < m; i++) {
                    u[i][j] = 0.0f;
                }
                u[j][j] = 1.0f;
            }
            for (int k = nct - 1; k >= 0; k--) {
                if (s[k] != 0.0f) {
                    for (int j = k + 1; j < nu; j++) {
                        float t = 0;
                        for (int i = k; i < m; i++) {
                            t += u[i][k] * u[i][j];
                        }
                        t = -t / u[k][k];
                        for (int i = k; i < m; i++) {
                            u[i][j] += t * u[i][k];
                        }
                    }
                    for (int i = k; i < m; i++) {
                        u[i][k] = -u[i][k];
                    }
                    u[k][k] = 1.0f + u[k][k];
                    for (int i = 0; i < k - 1; i++) {
                        u[i][k] = 0.0f;
                    }
                } else {
                    for (int i = 0; i < m; i++) {
                        u[i][k] = 0.0f;
                    }
                    u[k][k] = 1.0f;
                }
                progC += (nct - k);
                setProgression(progC * progW + progOff);
            }
        }
        if (wantv) {
            for (int k = n - 1; k >= 0; k--) {
                if ((k < nrt) && (e[k] != 0.0f)) {
                    for (int j = k + 1; j < nu; j++) {
                        float t = 0;
                        for (int i = k + 1; i < n; i++) {
                            t += v[i][k] * v[i][j];
                        }
                        t = -t / v[k + 1][k];
                        for (int i = k + 1; i < n; i++) {
                            v[i][j] += t * v[i][k];
                        }
                    }
                }
                for (int i = 0; i < n; i++) {
                    v[i][k] = 0.0f;
                }
                v[k][k] = 1.0f;
                progC++;
                setProgression(progC * progW + progOff);
            }
        }
        final int pp = p - 1;
        int iter = 0;
        while ((p > 0) && (noProg || threadRunning)) {
            int k, kase;
            for (k = p - 2; k >= -1; k--) {
                if (k == -1) break;
                if (Math.abs(e[k]) <= tiny + eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {
                    e[k] = 0.0f;
                    break;
                }
            }
            if (k == p - 2) {
                kase = 4;
            } else {
                int ks;
                for (ks = p - 1; ks >= k; ks--) {
                    if (ks == k) break;
                    final float t = (ks != p ? Math.abs(e[ks]) : 0.0f) + (ks != k + 1 ? Math.abs(e[ks - 1]) : 0.0f);
                    if (Math.abs(s[ks]) <= tiny + eps * t) {
                        s[ks] = 0.0f;
                        break;
                    }
                }
                if (ks == k) {
                    kase = 3;
                } else if (ks == p - 1) {
                    kase = 1;
                } else {
                    kase = 2;
                    k = ks;
                }
            }
            k++;
            switch(kase) {
                case 1:
                    {
                        float f = e[p - 2];
                        e[p - 2] = 0.0f;
                        for (int j = p - 2; j >= k; j--) {
                            final float t = hypot(s[j], f);
                            final float cs = s[j] / t;
                            final float sn = f / t;
                            s[j] = t;
                            if (j != k) {
                                f = -sn * e[j - 1];
                                e[j - 1] = cs * e[j - 1];
                            }
                            if (wantv) {
                                for (int i = 0; i < n; i++) {
                                    final float tt = cs * v[i][j] + sn * v[i][p - 1];
                                    v[i][p - 1] = -sn * v[i][j] + cs * v[i][p - 1];
                                    v[i][j] = tt;
                                }
                            }
                        }
                    }
                    break;
                case 2:
                    {
                        float f = e[k - 1];
                        e[k - 1] = 0.0f;
                        for (int j = k; j < p; j++) {
                            final float t = hypot(s[j], f);
                            final float cs = s[j] / t;
                            final float sn = f / t;
                            s[j] = t;
                            f = -sn * e[j];
                            e[j] = cs * e[j];
                            if (wantu) {
                                for (int i = 0; i < m; i++) {
                                    final float tt = cs * u[i][j] + sn * u[i][k - 1];
                                    u[i][k - 1] = -sn * u[i][j] + cs * u[i][k - 1];
                                    u[i][j] = tt;
                                }
                            }
                        }
                    }
                    break;
                case 3:
                    {
                        final float scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));
                        final float sp = s[p - 1] / scale;
                        final float spm1 = s[p - 2] / scale;
                        final float epm1 = e[p - 2] / scale;
                        final float sk = s[k] / scale;
                        final float ek = e[k] / scale;
                        final float b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0f;
                        final float c = (sp * epm1) * (sp * epm1);
                        final float shift;
                        if ((b != 0.0f) || (c != 0.0f)) {
                            final float t;
                            if (b >= 0.0f) {
                                t = (float) Math.sqrt(b * b + c);
                            } else {
                                t = (float) -Math.sqrt(b * b + c);
                            }
                            shift = c / (b + t);
                        } else {
                            shift = 0.0f;
                        }
                        float f = (sk + sp) * (sk - sp) + shift;
                        float g = sk * ek;
                        for (int j = k; j < (p - 1); j++) {
                            float t = hypot(f, g);
                            float cs = f / t;
                            float sn = g / t;
                            if (j != k) {
                                e[j - 1] = t;
                            }
                            f = cs * s[j] + sn * e[j];
                            e[j] = cs * e[j] - sn * s[j];
                            g = sn * s[j + 1];
                            s[j + 1] = cs * s[j + 1];
                            if (wantv) {
                                for (int i = 0; i < n; i++) {
                                    final float tt = cs * v[i][j] + sn * v[i][j + 1];
                                    v[i][j + 1] = -sn * v[i][j] + cs * v[i][j + 1];
                                    v[i][j] = tt;
                                }
                            }
                            t = hypot(f, g);
                            cs = f / t;
                            sn = g / t;
                            s[j] = t;
                            f = cs * e[j] + sn * s[j + 1];
                            s[j + 1] = -sn * e[j] + cs * s[j + 1];
                            g = sn * e[j + 1];
                            e[j + 1] = cs * e[j + 1];
                            if (wantu && (j < (m - 1))) {
                                for (int i = 0; i < m; i++) {
                                    final float tt = cs * u[i][j] + sn * u[i][j + 1];
                                    u[i][j + 1] = -sn * u[i][j] + cs * u[i][j + 1];
                                    u[i][j] = tt;
                                }
                            }
                        }
                        e[p - 2] = f;
                        iter++;
                    }
                    break;
                case 4:
                    {
                        if (s[k] <= 0.0f) {
                            s[k] = (s[k] < 0.0f ? -s[k] : 0.0f);
                            if (wantv) {
                                for (int i = 0; i <= pp; i++) {
                                    v[i][k] = -v[i][k];
                                }
                            }
                        }
                        while (k < pp) {
                            if (s[k] >= s[k + 1]) break;
                            float t = s[k];
                            s[k] = s[k + 1];
                            s[k + 1] = t;
                            if (wantv && (k < (n - 1))) {
                                for (int i = 0; i < n; i++) {
                                    t = v[i][k + 1];
                                    v[i][k + 1] = v[i][k];
                                    v[i][k] = t;
                                }
                            }
                            if (wantu && (k < (m - 1))) {
                                for (int i = 0; i < m; i++) {
                                    t = u[i][k + 1];
                                    u[i][k + 1] = u[i][k];
                                    u[i][k] = t;
                                }
                            }
                            k++;
                        }
                        iter = 0;
                        progC += p;
                        p--;
                        setProgression(progC * progW + progOff);
                    }
                    break;
            }
        }
    }
",1
9470469,7,"    private int testOTP(String msg, String[] challenge) {
        String[] lines = Utilities.split(msg, ""\r\n"");
        for (int i = 0; i < lines.length; i++) {
            String[] t = Utilities.split(lines[i], "" "");
            for (int k = 1; k < t.length; k++) {
                try {
                    if (Pattern.matches(""[0-9]+"", t[k])) {
                        challenge[0] = t[k];
                        challenge[1] = t[k + 1];
                        if (lines[i].indexOf(""md4"") != -1) return 4; else return 5;
                    }
                } catch (Exception e) {
                }
            }
        }
        return -1;
    }
",1
1243836,7,"    public String[] getFieldList() {
        String[] fieldList = new String[fields.length - 1];
        for (int i = 0; i < fieldList.length; i++) {
            fieldList[i] = fields[i + 1];
        }
        return fieldList;
    }
",1
8832284,7,"    public byte[] evaluateEvidence(byte[] peerEvidence) throws SaslException {
        byte[] key = K.getEncoded();
        int t = key[0];
        for (int i = 0; i < key.length - 1; i++) key[i] = key[i + 1];
        key[key.length - 1] = (byte) t;
        K = new SRPSecretKey(key);
        return ((SRPContext) getSaslSecurityContext()).getSignature();
    }
",1
15311981,7,"    private void calcGridVal(int i, int j, int k, double[][][] data, Gridcell grid) {
        grid.val[0] = data[i][j][k];
        grid.val[1] = data[i + 1][j][k];
        grid.val[2] = data[i + 1][j + 1][k];
        grid.val[3] = data[i][j + 1][k];
        grid.val[4] = data[i][j][k + 1];
        grid.val[5] = data[i + 1][j][k + 1];
        grid.val[6] = data[i + 1][j + 1][k + 1];
        grid.val[7] = data[i][j + 1][k + 1];
    }
",1
3721994,7,"    private void backSpace() {
        int textPos = getTextPosition() - 1;
        if (textPos < 0) return;
        for (int i = textPos; i < text.length - 1; i++) text[i] = text[i + 1];
        text[text.length - 1] = fillValue;
        showText();
        setCaretPosition(textPos + textPos / 2, false, false);
    }
",1
41238,7,"    public void readCommand(OsProcess proc) {
        String str;
        user = proc;
        if (rawTTY) str = readFromRawTTY(); else str = readFromCookedTTY();
        String[] words = toArgs(str);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
",1
14264469,7,"    public SyntaxPoint[] getSyntaxPoints() {
        ArrayList<SyntaxPoint> list = new ArrayList<SyntaxPoint>(syntaxPoints);
        Collections.sort(list);
        SyntaxPoint[] result = (SyntaxPoint[]) list.toArray(new SyntaxPoint[syntaxPoints.size()]);
        for (int i = 0; i + 1 < result.length; i++) {
            if (result[i].getType().equals(""TextLine"") && result[i + 1].getType().equals(""TextLine"") && result[i].getLine() == result[i + 1].getLine() && result[i].getColumn() == result[i + 1].getColumn() && !result[i].isBegin() && result[i + 1].isBegin()) {
                SyntaxPoint temp = result[i];
                result[i] = result[i + 1];
                result[i + 1] = temp;
            }
        }
        return result;
    }
",1
15891729,7,"    public void setPalette(IPalette palette) {
        if (m_src_index_color_raster == null) {
            throw new IllegalStateException(""this image is not support index color model !"");
        }
        if (palette != null) {
            try {
                byte[] colors = palette.getIndexColors();
                int color_count = palette.getIndexColorCount();
                int transparent_color_index = palette.getTransparentColorIndex();
                byte[] ra = new byte[color_count];
                byte[] ga = new byte[color_count];
                byte[] ba = new byte[color_count];
                byte[] ralpha = new byte[color_count];
                for (int i = 0, j = 0; (i < colors.length) && (j < color_count); i += 3, ++j) {
                    ra[j] = colors[i];
                    ga[j] = colors[i + 1];
                    ba[j] = colors[i + 2];
                    ralpha[j] = (byte) ((j == transparent_color_index) ? 0 : 255);
                }
                IndexColorModel icm = new IndexColorModel(8, color_count, ra, ga, ba, ralpha);
                BufferedImage new_image = new BufferedImage(icm, m_src_index_color_raster, icm.isAlphaPremultiplied(), null);
                m_image = createBuffer(new_image);
            } catch (Exception exp) {
                exp.printStackTrace();
            }
        }
    }
",1
761030,7,"    void removePoint(int index) {
        int npoints = x.length;
        int[] temp_x = new int[npoints - 1];
        int[] temp_y = new int[npoints - 1];
        for (int i = 0; i < index; i++) {
            temp_x[i] = x[i];
            temp_y[i] = y[i];
        }
        for (int j = index; j < npoints - 1; j++) {
            temp_x[j] = x[j + 1];
            temp_y[j] = y[j + 1];
        }
        x = temp_x;
        y = temp_y;
    }
",0
119525,7,"    private void sortByNum() {
        int i, j, w;
        for (i = count - 1; i >= 0; i--) {
            ChannelItem ch = chans[i];
            w = ch.getUsers();
            j = i;
            while ((j < count - 1) && (chans[j + 1].getUsers() > w)) {
                chans[j] = chans[j + 1];
                j++;
            }
            chans[j] = ch;
        }
    }
",1
3197712,7,"    private void initCodeDynamic() {
        this.child = new int[TREESIZE];
        this.parent = new int[TREESIZE];
        this.block = new int[TREESIZE];
        this.edge = new int[TREESIZE];
        this.stock = new int[TREESIZE];
        this.sNode = new int[TREESIZE / 2];
        this.freq = new int[TREESIZE];
        n1 = (nMax >= (256 + maxMatch - THRESHOLD + 1)) ? 512 : nMax - 1;
        for (int i = 0; i < TREESIZE_CODE; ++i) {
            stock[i] = i;
            block[i] = 0;
        }
        int j = nMax * 2 - 2;
        for (int i = 0; i < nMax; ++i, --j) {
            freq[j] = 1;
            child[j] = ~i;
            sNode[i] = j;
            block[j] = 1;
        }
        avail = 2;
        edge[1] = nMax - 1;
        for (int i = nMax * 2 - 2; j >= 0; i -= 2, --j) {
            int f = freq[j] = freq[i] + freq[i - 1];
            child[j] = i;
            parent[i] = parent[i - 1] = j;
            if (f == freq[j + 1]) {
                block[j] = block[j + 1];
            } else {
                block[j] = stock[avail++];
            }
            edge[block[j]] = j;
        }
    }
",1
23216115,7,"    public void setPalette(IPalette palette) {
        if (m_src_index_color_raster == null) {
            throw new IllegalStateException(""this image is not support index color model !"");
        }
        if (palette != null) {
            try {
                byte[] colors = palette.getIndexColors();
                int color_count = palette.getIndexColorCount();
                int transparent_color_index = palette.getTransparentColorIndex();
                byte[] ra = new byte[color_count];
                byte[] ga = new byte[color_count];
                byte[] ba = new byte[color_count];
                byte[] ralpha = new byte[color_count];
                for (int i = 0, j = 0; (i < colors.length) && (j < color_count); i += 3, ++j) {
                    ra[j] = colors[i];
                    ga[j] = colors[i + 1];
                    ba[j] = colors[i + 2];
                    ralpha[j] = (byte) ((j == transparent_color_index) ? 0 : 255);
                }
                IndexColorModel icm = new IndexColorModel(8, color_count, ra, ga, ba, ralpha);
                BufferedImage new_image = new BufferedImage(icm, m_src_index_color_raster, icm.isAlphaPremultiplied(), null);
                this.m_image = createBuffer(new_image);
            } catch (Exception exp) {
                exp.printStackTrace();
            }
        }
    }
",1
14775949,7,"    public AlgorithmData execute(AlgorithmData data) throws AlgorithmException {
        AlgorithmParameters map = data.getParams();
        function = map.getInt(""distance-function"", EUCLIDEAN);
        factor = map.getFloat(""distance-factor"", 1.0f);
        absolute = map.getBoolean(""distance-absolute"", false);
        calculateMeans = map.getBoolean(""calculate-means"", true);
        kmcGenes = map.getBoolean(""kmc-cluster-genes"", true);
        hcl_function = map.getInt(""hcl-distance-function"", EUCLIDEAN);
        hcl_absolute = map.getBoolean(""hcl-distance-absolute"", false);
        int number_of_iterations = map.getInt(""number-of-iterations"", 0);
        int number_of_clusters = map.getInt(""number-of-clusters"", 0);
        boolean hierarchical_tree = map.getBoolean(""hierarchical-tree"", false);
        int method_linkage = map.getInt(""method-linkage"", 0);
        boolean calculate_genes = map.getBoolean(""calculate-genes"", false);
        boolean calculate_experiments = map.getBoolean(""calculate-experiments"", false);
        this.expMatrix = data.getMatrix(""experiment"");
        number_of_genes = this.expMatrix.getRowDimension();
        number_of_samples = this.expMatrix.getColumnDimension();
        this.clusterConvergence = new int[number_of_clusters];
        KMCluster[] clusters;
        FloatMatrix means = null;
        FloatMatrix medians = null;
        FloatMatrix variances = null;
        if (calculateMeans) {
            clusters = calculate(number_of_genes, number_of_clusters, number_of_iterations);
            means = getMeans(clusters);
            variances = getVariances(clusters, means);
        } else {
            clusters = calculateMedians(number_of_genes, number_of_clusters, number_of_iterations);
            medians = getMedians(clusters);
            variances = getVariances(clusters, medians);
        }
        float[] tempConv = new float[clusterConvergence.length];
        for (int i = 0; i < clusterConvergence.length; i++) {
            tempConv[i] = (float) clusterConvergence[i];
        }
        QSort qsort = new QSort(tempConv);
        tempConv = qsort.getSorted();
        int[] sortedClusterIndices = qsort.getOrigIndx();
        int temp;
        for (int i = 0; i < number_of_clusters - 1; i++) {
            for (int j = 0; j < number_of_clusters - 1 - i; j++) {
                if (tempConv[j] == tempConv[j + 1]) {
                    if (clusters[sortedClusterIndices[j]].size() < clusters[sortedClusterIndices[j + 1]].size()) {
                        temp = sortedClusterIndices[j];
                        sortedClusterIndices[j] = sortedClusterIndices[j + 1];
                        sortedClusterIndices[j + 1] = temp;
                    }
                }
            }
        }
        KMCluster[] newClusterOrder = new KMCluster[clusters.length];
        FloatMatrix newMeansMedsOrder = new FloatMatrix(clusters.length, number_of_samples);
        FloatMatrix newVariancesOrder = new FloatMatrix(clusters.length, number_of_samples);
        for (int i = 0; i < clusters.length; i++) {
            newClusterOrder[i] = clusters[sortedClusterIndices[i]];
            newVariancesOrder.A[i] = variances.A[sortedClusterIndices[i]];
            if (calculateMeans) newMeansMedsOrder.A[i] = means.A[sortedClusterIndices[i]]; else newMeansMedsOrder.A[i] = medians.A[sortedClusterIndices[i]];
            clusterConvergence[i] = (int) (tempConv[i]);
        }
        clusters = newClusterOrder;
        variances = newVariancesOrder;
        if (calculateMeans) means = newMeansMedsOrder; else medians = newMeansMedsOrder;
        AlgorithmEvent event = null;
        if (hierarchical_tree) {
            event = new AlgorithmEvent(this, AlgorithmEvent.SET_UNITS, clusters.length, ""Calculate Hierarchical Trees"");
            fireValueChanged(event);
            event.setIntValue(0);
            event.setId(AlgorithmEvent.PROGRESS_VALUE);
            fireValueChanged(event);
        }
        Cluster result_cluster = new Cluster();
        NodeList nodeList = result_cluster.getNodeList();
        int[] features;
        for (int i = 0; i < clusters.length; i++) {
            if (stop) {
                throw new AbortException();
            }
            features = convert2int(clusters[i]);
            Node node = new Node(features);
            nodeList.addNode(node);
            if (hierarchical_tree) {
                node.setValues(calculateHierarchicalTree(features, method_linkage, calculate_genes, calculate_experiments));
                event.setIntValue(i + 1);
                fireValueChanged(event);
            }
        }
        AlgorithmData result = new AlgorithmData();
        result.addCluster(""cluster"", result_cluster);
        if (calculateMeans) result.addMatrix(""clusters_means"", means); else result.addMatrix(""clusters_means"", medians);
        result.addMatrix(""clusters_variances"", variances);
        result.addParam(""iterations"", String.valueOf(getIterations()));
        result.addParam(""converged"", String.valueOf(getConverged()));
        result.addIntArray(""convergence-iterations"", clusterConvergence);
        return result;
    }
",0
3284095,7,"    public static boolean runGrey(SegmentImageData sourceData, final byte[] dest, int[] greenGrey, int[] blueGrey, int[] redGrey, int[] bclut, IProgressMonitor monitor) {
        if (sourceData == null || sourceData.data == null) {
            SWT.error(SWT.ERROR_CANNOT_BE_ZERO);
            return false;
        }
        if (!(sourceData.bpp == 3 || sourceData.bpp == 4)) {
            SWT.error(SWT.ERROR_INVALID_ARGUMENT);
            return false;
        }
        int scanLineEnd = -1;
        final int step = sourceData.bpp;
        scanLineEnd = sourceData.start + sourceData.scanLineLength - step;
        final int bs = sourceData.blueShift;
        final int gs = sourceData.greenShift;
        final int rs = sourceData.redShift;
        int r, g, b, gray;
        final byte[] source = sourceData.data;
        final int length = sourceData.length - sourceData.pad;
        for (int i = sourceData.start; i < length; i += step) {
            b = bclut[source[i + bs] & 0xff];
            g = bclut[source[i + gs] & 0xff];
            r = bclut[source[i + rs] & 0xff];
            gray = ((greenGrey[g]) + (blueGrey[b]) + (redGrey[r]));
            gray = gray > 255 ? 255 : gray;
            dest[i] = dest[i + 1] = dest[i + 2] = (byte) gray;
            if (i == scanLineEnd) {
                scanLineEnd += sourceData.scanLineLength + sourceData.pad;
                i += sourceData.pad;
                if (monitor != null) {
                    monitor.worked(1);
                }
            }
        }
        return true;
    }
",1
908924,7,"    public static void main(String[] args) {
        long[] arr;
        arr = new long[100];
        int nElems = 0;
        int j;
        long searchKey;
        arr[0] = 77;
        arr[1] = 99;
        arr[2] = 44;
        arr[3] = 55;
        arr[4] = 22;
        arr[5] = 88;
        arr[6] = 11;
        arr[7] = 00;
        arr[8] = 66;
        arr[9] = 33;
        nElems = 10;
        for (j = 0; j < nElems; j++) System.out.print(arr[j] + "" "");
        System.out.println("""");
        searchKey = 66;
        for (j = 0; j < nElems; j++) if (arr[j] == searchKey) break;
        if (j == nElems) System.out.println(""Can't find "" + searchKey); else System.out.println(""Found "" + searchKey);
        searchKey = 55;
        for (j = 0; j < nElems; j++) if (arr[j] == searchKey) break;
        for (int k = j; k < nElems; k++) arr[k] = arr[k + 1];
        nElems--;
        for (j = 0; j < nElems; j++) System.out.print(arr[j] + "" "");
        System.out.println("""");
    }
",1
7785434,7,"    private void swapaux() {
        index = 2;
        byte i;
        i = event[index];
        sevent[index] = event[index + 1];
        sevent[index + 1] = i;
        index += 2;
        i = (byte) ((event[0] & ~0x80) & 0xff);
        switch(i) {
            case 0:
                _swapInt();
                _swapShort();
                break;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
                i = event[index];
                sevent[index] = event[index + 3];
                sevent[index + 3] = i;
                i = event[index + 1];
                sevent[index + 1] = event[index + 2];
                sevent[index + 2] = i;
                index += 4;
                i = event[index];
                sevent[index] = event[index + 3];
                sevent[index + 3] = i;
                i = event[index + 1];
                sevent[index + 1] = event[index + 2];
                sevent[index + 2] = i;
                index += 4;
                i = event[index];
                sevent[index] = event[index + 3];
                sevent[index + 3] = i;
                i = event[index + 1];
                sevent[index + 1] = event[index + 2];
                sevent[index + 2] = i;
                index += 4;
                i = event[index];
                sevent[index] = event[index + 3];
                sevent[index + 3] = i;
                i = event[index + 1];
                sevent[index + 1] = event[index + 2];
                sevent[index + 2] = i;
                index += 4;
                i = event[index];
                sevent[index] = event[index + 1];
                sevent[index + 1] = i;
                index += 2;
                i = event[index];
                sevent[index] = event[index + 1];
                sevent[index + 1] = i;
                index += 2;
                i = event[index];
                sevent[index] = event[index + 1];
                sevent[index + 1] = i;
                index += 2;
                i = event[index];
                sevent[index] = event[index + 1];
                sevent[index + 1] = i;
                index += 2;
                i = event[index];
                sevent[index] = event[index + 1];
                sevent[index + 1] = i;
                break;
            case 9:
            case 10:
                _swapInt();
                break;
            case 12:
                _swapInt();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                break;
            case 13:
                _swapInt();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                break;
            case 14:
                _swapInt();
                _swapShort();
                break;
            case 15:
                _swapInt();
                break;
            case 16:
                _swapInt();
                _swapInt();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                break;
            case 17:
            case 18:
            case 19:
            case 20:
                _swapInt();
                _swapInt();
                break;
            case 21:
                _swapInt();
                _swapInt();
                _swapInt();
                _swapShort();
                _swapShort();
                break;
            case 22:
                _swapInt();
                _swapInt();
                _swapInt();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                break;
            case 23:
                _swapInt();
                _swapInt();
                _swapInt();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                _swapShort();
                break;
            case 24:
                _swapInt();
                _swapInt();
                _swapShort();
                _swapShort();
                break;
            case 25:
                _swapInt();
                _swapShort();
                _swapShort();
                break;
            case 26:
            case 27:
            case 28:
            case 29:
                _swapInt();
                _swapInt();
                _swapInt();
                break;
            case 30:
                _swapInt();
                _swapInt();
                _swapInt();
                _swapInt();
                _swapInt();
                _swapInt();
                break;
            case 31:
                _swapInt();
                _swapInt();
                _swapInt();
                _swapInt();
                _swapInt();
                break;
            case 32:
                _swapInt();
                _swapInt();
                break;
            case 33:
                _swapInt();
                _swapInt();
                switch(event[1]) {
                    case 32:
                        for (int ii = 0; ii < 5; ii++) _swapInt();
                        break;
                    default:
                }
                break;
            default:
                if (64 < i) {
                    Extension.swap((int) i, this);
                }
        }
    }
",1
14095674,7,"    private void getNextChangingElement(int a0, boolean isWhite, int[] ret) {
        int[] pce = this.prevChangingElems;
        int ces = this.changingElemSize;
        int start = (lastChangingElement > 0) ? (lastChangingElement - 1) : 0;
        if (isWhite) {
            start &= ~0x1;
        } else {
            start |= 0x1;
        }
        int i = start;
        for (; i < ces; i += 2) {
            int temp = pce[i];
            if (temp > a0) {
                lastChangingElement = i;
                ret[0] = temp;
                break;
            }
        }
        if ((i + 1) < ces) {
            ret[1] = pce[i + 1];
        }
    }
",1
7630322,7,"    public static void switchEndianness(byte[] samples) {
        for (int i = 0; i < samples.length; i += 2) {
            byte tmp = samples[i];
            samples[i] = samples[i + 1];
            samples[i + 1] = tmp;
        }
    }
",0
1336659,7,"    public static Object financialNpv(Object[] args, XelContext ctx) {
        double[] d = UtilFns.toDoubleArray(UtilFns.toList(args, ctx));
        double[] values = new double[d.length - 1];
        for (int i = 0; i < values.length; i++) {
            values[i] = d[i + 1];
        }
        double result = npv(d[0], values);
        return new Double(result);
    }
",1
713334,7,"    private void sortByNum() {
        int i, j, w;
        for (i = count - 1; i >= 0; i--) {
            ChannelItem ch = chans[i];
            w = ch.getUsers();
            j = i;
            while ((j < count - 1) && (chans[j + 1].getUsers() > w)) {
                chans[j] = chans[j + 1];
                j++;
            }
            chans[j] = ch;
        }
    }
",1
23365039,7,"    public void calcCurve() throws JuggleExceptionInternal {
        this.n = numpoints - 1;
        if (n < 1) throw new JuggleExceptionInternal(""lineCurve error 1"");
        this.a = new double[n][3];
        this.b = new double[n][3];
        this.durations = new double[n];
        for (int i = 0; i < n; i++) {
            durations[i] = times[i + 1] - times[i];
            if (durations[i] < 0.0) throw new JuggleExceptionInternal(""lineCurve error 2"");
        }
        double[] x = new double[n + 1];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < (n + 1); j++) x[j] = positions[j].getIndex(i);
            for (int j = 0; j < n; j++) {
                a[j][i] = x[j];
                b[j][i] = (x[j + 1] - x[j]) / durations[j];
            }
        }
    }
",1
21728058,7,"    @Override
    public void reComputeFunctionValueAndGradient(double[] weights) {
        double[] weights2 = weights;
        if (shouldComputeGradientForScalingFactor) {
            if (weights.length != numFeatures + 1) {
                System.out.println(""number of weights is not right"");
                System.exit(1);
            }
            scalingFactor = weights[0];
            weights2 = new double[numFeatures];
            for (int i = 0; i < numFeatures; i++) weights2[i] = weights[i + 1];
        }
        for (int i = 0; i < gradientsForTheta.length; i++) gradientsForTheta[i] = 0;
        if (shouldComputeGradientForScalingFactor) gradientForScalingFactor = 0;
        functionValue = 0;
        sumGain = 0;
        sumEntropy = 0;
        hgFactory.startLoop();
        if (numThreads <= 1) reComputeFunctionValueAndGradientHelperSingleThread(weights2); else reComputeFunctionValueAndGradientHelper(weights2);
        hgFactory.endLoop();
        printLastestStatistics();
        numCalls++;
    }
",1
17047445,7,"    public byte[] openBytes(int no) throws FormatException, IOException {
        FormatTools.assertId(currentId, true, 1);
        FormatTools.checkPlaneNumber(this, no);
        LayerInfo info = (LayerInfo) layerInfoList[series].get(no);
        in.seek(info.layerStart);
        readTagHeader();
        if ((tag != 67 && tag != 68) || (!fmt.equals(""PICT"") && !fmt.equals(""RAWi""))) {
            throw new FormatException(""Corrupt LIFF file."");
        }
        in.skipBytes(24);
        int volumeType = in.readShort();
        in.skipBytes(272);
        int top, left, bottom, right;
        if (version == 2) {
            in.skipBytes(2);
            top = in.readShort();
            left = in.readShort();
            bottom = in.readShort();
            right = in.readShort();
            if (core.sizeX[series] == 0) core.sizeX[series] = right - left;
            if (core.sizeY[series] == 0) core.sizeY[series] = bottom - top;
        } else {
            core.sizeX[series] = in.readInt();
            core.sizeY[series] = in.readInt();
        }
        in.seek(info.layerStart);
        byte[] b = new byte[0];
        if (version == 2) {
            long nextTag = readTagHeader();
            if ((tag != 67 && tag != 68) || !fmt.equals(""PICT"")) {
                throw new FormatException(""Corrupt LIFF file."");
            }
            in.skipBytes(298);
            Exception exception = null;
            try {
                b = new byte[(int) (nextTag - in.getFilePointer())];
                in.read(b);
                BufferedImage img = pict.open(b);
                byte[][] tmp = ImageTools.getBytes(img);
                b = new byte[tmp.length * tmp[0].length];
                int pt = 0;
                for (int i = 0; i < tmp[0].length; i++) {
                    for (int j = 0; j < tmp.length; j++) {
                        b[pt++] = tmp[j][i];
                    }
                }
            } catch (FormatException exc) {
                exception = exc;
            } catch (IOException exc) {
                exception = exc;
            }
            if (exception != null) {
                if (debug) trace(exception);
                b = null;
                in.seek(info.layerStart + 12);
                int blockSize = DataTools.read4SignedBytes(in, false);
                byte toRead = (byte) in.read();
                if (toRead == 1) in.skipBytes(128);
                in.skipBytes(169);
                byte[] q = new byte[blockSize];
                in.read(q);
                byte[] pixelData = new byte[blockSize];
                int pixPos = 0;
                int length = q.length;
                int num, size;
                int totalBlocks = -1;
                int expectedBlock = 0;
                int pos = 0;
                while (expectedBlock != totalBlocks) {
                    while (pos + 7 < length && (q[pos] != 73 || q[pos + 1] != 86 || q[pos + 2] != 69 || q[pos + 3] != 65 || q[pos + 4] != 100 || q[pos + 5] != 98 || q[pos + 6] != 112 || q[pos + 7] != 113)) {
                        pos++;
                    }
                    pos += 8;
                    num = DataTools.bytesToInt(q, pos, 4, false);
                    if (num != expectedBlock) {
                        throw new FormatException(""Expected iPic block not found"");
                    }
                    expectedBlock++;
                    if (totalBlocks == -1) {
                        totalBlocks = DataTools.bytesToInt(q, pos + 4, 4, false);
                    } else {
                        if (DataTools.bytesToInt(q, pos + 4, 4, false) != totalBlocks) {
                            throw new FormatException(""Unexpected totalBlocks numbein.read"");
                        }
                    }
                    pos += 16;
                    size = DataTools.bytesToInt(q, pos, 4, false);
                    pos += 8;
                    System.arraycopy(q, pos, pixelData, pixPos, size);
                    pixPos += size;
                }
                System.gc();
                b = new byte[pixPos];
                System.arraycopy(pixelData, 0, b, 0, b.length);
            }
        } else {
            readTagHeader();
            if (tag != 68 || !fmt.equals(""RAWi"")) {
                throw new FormatException(""Corrupt LIFF file."");
            }
            if (subTag != 0) {
                throw new FormatException(""Wrong compression type."");
            }
            in.skipBytes(24);
            volumeType = in.readShort();
            in.skipBytes(280);
            int size = in.readInt();
            int compressedSize = in.readInt();
            b = new byte[size];
            byte[] c = new byte[compressedSize];
            in.read(c);
            LZOCodec lzoc = new LZOCodec();
            b = lzoc.decompress(c);
            if (b.length != size) {
                LogTools.println(""LZOCodec failed to predict image size"");
                LogTools.println(size + "" expected, got "" + b.length + "". The image displayed may not be correct."");
            }
            if (volumeType == MAC_24_BIT) {
                bytesPerPixel = b.length >= core.sizeX[series] * core.sizeY[series] * 4 ? 4 : 3;
                int destRowBytes = core.sizeX[series] * bytesPerPixel;
                int srcRowBytes = b.length / core.sizeY[series];
                byte[] tmp = new byte[destRowBytes * core.sizeY[series]];
                int src = 0;
                int dest = 0;
                for (int y = 0; y < core.sizeY[series]; y++) {
                    System.arraycopy(b, src, tmp, dest, destRowBytes);
                    src += srcRowBytes;
                    dest += destRowBytes;
                }
                if (bytesPerPixel == 4) {
                    b = new byte[(3 * tmp.length) / 4];
                    dest = 0;
                    for (int i = 0; i < tmp.length; i += 4) {
                        b[dest] = tmp[i + 1];
                        b[dest + (b.length / 3)] = tmp[i + 2];
                        b[dest + ((2 * b.length) / 3)] = tmp[i + 3];
                        dest++;
                    }
                    bytesPerPixel = 3;
                }
            } else if (volumeType == MAC_256_GREYS) {
                byte[] tmp = b;
                b = new byte[core.sizeX[series] * core.sizeY[series]];
                for (int y = 0; y < core.sizeY[series]; y++) {
                    System.arraycopy(tmp, y * (core.sizeX[series] + 16), b, y * core.sizeX[series], core.sizeX[series]);
                }
            } else if (volumeType < MAC_24_BIT) {
                throw new FormatException(""Unsupported image type : "" + volumeType);
            }
        }
        int bpp = b.length / (core.sizeX[series] * core.sizeY[series]);
        int expected = core.sizeX[series] * core.sizeY[series] * bpp;
        if (b.length > expected) {
            byte[] tmp = b;
            b = new byte[expected];
            System.arraycopy(tmp, 0, b, 0, b.length);
        }
        return b;
    }
",1
8886969,7,"    public Packet(byte[] arr) {
        this.header = arr[0];
        this.data = new byte[3];
        for (int i = 0; i < 3; i++) {
            this.data[i] = arr[i + 1];
        }
    }
",1
14128654,7,"    public void atribuicaoAritmeticaVetor(String sentenca[]) {
        String rotuloVetorRecebe = sentenca[0];
        String posicaoVetor = sentenca[1];
        String expressao[] = new String[sentenca.length - 1];
        expressao[0] = new String(rotuloVetorRecebe + ""-"" + posicaoVetor);
        for (int i = 1; i < expressao.length; i++) {
            expressao[i] = sentenca[i + 1];
        }
        atribuicaoAritmetica(expressao);
    }
",0
10541266,7,"    public void shiftLines() {
        int trueNb = tiles.length;
        for (int i = 0; i < (trueNb - 1); i++) {
            tiles[i] = tiles[i + 1];
        }
    }
",1
19358125,7,"    private float[] evenOddFiltering(float[] src, int WTTypes) throws ErrorException {
        int subbandSize = src.length;
        int half = subbandSize / 2;
        float dst[] = new float[subbandSize];
        for (int k = 0; k < half; k++) {
            dst[2 * k] = src[k];
            dst[2 * k + 1] = src[half + k];
        }
        switch(WTTypes) {
            case 1:
                dst[subbandSize - 1] = dst[subbandSize - 1] - (float) (Math.floor((dst[subbandSize - 2] + dst[subbandSize - 2] + 2) / 4));
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - (float) (Math.floor(((dst[k - 1] + dst[k + 1] + 2) / 4)));
                }
                dst[0] = dst[0] + (float) (Math.floor(((dst[1] + dst[1]) / 2)));
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] + (float) (Math.floor(((dst[k - 1] + dst[k + 1]) / 2)));
                }
                break;
            case 2:
            case 3:
                final float alfa_97 = -1.586134342059924F;
                final float beta_97 = -0.052980118572961F;
                final float gamma_97 = 0.882911075530934F;
                final float delta_97 = 0.443506852043971F;
                final float nh_97, nl_97;
                if (WTTypes == 2) {
                    nh_97 = 1.230174104914001F;
                    nl_97 = 1F / nh_97;
                } else {
                    nl_97 = 1.14960430535816F;
                    nh_97 = -1F / nl_97;
                }
                for (int k = 0; k < subbandSize; k += 2) {
                    dst[k] = dst[k] / nh_97;
                    dst[k + 1] = dst[k + 1] / nl_97;
                }
                dst[subbandSize - 1] = dst[subbandSize - 1] - delta_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - delta_97 * (dst[k - 1] + dst[k + 1]);
                }
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - gamma_97 * (dst[k - 1] + dst[k + 1]);
                }
                dst[0] = dst[0] - gamma_97 * (dst[1] + dst[1]);
                dst[subbandSize - 1] = dst[subbandSize - 1] - beta_97 * (dst[subbandSize - 2] + dst[subbandSize - 2]);
                for (int k = 1; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - beta_97 * (dst[k - 1] + dst[k + 1]);
                }
                for (int k = 2; k < subbandSize - 1; k += 2) {
                    dst[k] = dst[k] - alfa_97 * (dst[k - 1] + dst[k + 1]);
                }
                dst[0] = dst[0] - alfa_97 * (dst[1] + dst[1]);
                break;
            case 4:
                if (subbandSize >= 6) {
                    final float alfa1 = (9F / 16F);
                    final float alfa2 = (1F / 16F);
                    final float beta = (1F / 4F);
                    dst[0] = dst[0] + (float) (Math.floor(-beta * (dst[1] + dst[1]) + 0.5F));
                    for (int k = 2; k < subbandSize; k += 2) {
                        dst[k] = dst[k] + (float) (Math.floor(-beta * (dst[k - 1] + dst[k + 1]) + 0.5F));
                    }
                    dst[1] = dst[1] + (float) (Math.floor(alfa1 * (dst[0] + dst[2]) - alfa2 * (dst[2] + dst[4]) + 0.5F));
                    for (int k = 3; k < subbandSize - 3; k += 2) {
                        dst[k] = dst[k] + (float) (Math.floor(alfa1 * (dst[k - 1] + dst[k + 1]) - alfa2 * (dst[k - 3] + dst[k + 3]) + 0.5F));
                    }
                    dst[subbandSize - 3] = dst[subbandSize - 3] + (float) (Math.floor(alfa1 * (dst[subbandSize - 4] + dst[subbandSize - 2]) - alfa2 * (dst[subbandSize - 6] + dst[subbandSize - 2]) + 0.5F));
                    dst[subbandSize - 1] = dst[subbandSize - 1] + (float) (Math.floor(alfa1 * (dst[subbandSize - 2] + dst[subbandSize - 2]) - alfa2 * (dst[subbandSize - 4] + dst[subbandSize - 4]) + 0.5F));
                } else {
                    throw new ErrorException(""Size should be greater or equal than 6 in order to perform 9/7M"");
                }
                break;
            case 7:
                float sample1 = 0, sample2 = 0;
                float normFactor = (float) (Math.sqrt(2));
                for (int k = 0; k < subbandSize; k += 2) {
                    sample1 = dst[k] + dst[k + 1];
                    sample2 = dst[k] - dst[k + 1];
                    dst[k] = sample1 * normFactor;
                    dst[k + 1] = sample2 * normFactor;
                }
                break;
            case 8:
                float s = 0;
                for (int k = 0; k < subbandSize; k += 2) {
                    s = dst[k] - (float) Math.floor(dst[k + 1] / 2);
                    dst[k] = dst[k + 1] + s;
                    dst[k + 1] = s;
                }
                break;
            default:
                throw new ErrorException(""Unrecognized wavelet transform type."");
        }
        return (dst);
    }
",1
13902474,7,"    public void consume() throws TokenException {
        for (int i = 0; i < (depth - 1); i++) {
            buffer[i] = buffer[i + 1];
        }
        buffer[depth - 1] = input.read();
    }
",0
2045246,7,"    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        if (args.length < 1) throw new RuntimeException(""Usage: java "" + TimedRun.class.getCanonicalName() + "" ClassName [args]"");
        final ClassLoader cl = TimedRun.class.getClassLoader();
        final Class<?> target = cl.loadClass(args[0]);
        final Method runMe = target.getMethod(""main"", String[].class);
        final String[] otherArgs = new String[args.length - 1];
        for (int i = 0; i < otherArgs.length; i++) otherArgs[i] = args[i + 1];
        final long now = Calendar.getInstance().getTimeInMillis();
        runMe.invoke(null, new Object[] { otherArgs });
        final long delta = Calendar.getInstance().getTimeInMillis() - now;
        System.out.println(""Run time : "" + formatTime(delta));
    }
",1
16636768,7,"    boolean moveDelta(int index, int dx, int dy) {
        if (dx == 0 && dy == 0) return false;
        boolean needResize = false;
        boolean needLayout = false;
        if (dy == 0) {
            int[] ws = new int[items.length];
            for (int i = 0; i < ws.length; i++) {
                ws[i] = items[i].idealWidth;
            }
            boolean needCalculate = false;
            CoolItem item = items[index];
            if (item.wrap && (dx < 0 || isLastItemOfRow(index))) {
                return false;
            }
            if ((index == 0 && items.length > 1) || (item.wrap && !isLastItemOfRow(index))) {
                if (dx >= item.lastCachedWidth) {
                    CoolItem next = items[index + 1];
                    items[index] = next;
                    items[index + 1] = item;
                    if (item.wrap) {
                        next.wrap = true;
                        item.wrap = false;
                    }
                    int width = next.idealWidth;
                    next.idealWidth = item.idealWidth;
                    item.idealWidth = width;
                    dx = dx - item.lastCachedWidth;
                    index++;
                    needLayout = true;
                }
            }
            if (dx != 0 && index > 0 && !(item.wrap && !isLastItemOfRow(index))) {
                CoolItem cur = item;
                CoolItem prev = items[index - 1];
                int idx = index - 1;
                while (dx < 0) {
                    if (prev.lastCachedWidth + dx < minWidth(prev)) {
                        int ddx = prev.lastCachedWidth - minWidth(prev);
                        prev.idealWidth -= ddx;
                        item.idealWidth += ddx;
                        needCalculate = true;
                        dx += ddx;
                        if (dx < 0) {
                            if (idx - 1 >= 0 && !items[idx].wrap) {
                                idx--;
                                prev = items[idx];
                            } else {
                                if (dx + 11 <= 0) {
                                    CoolItem swpItem = prev;
                                    int swpIndex = index;
                                    while (dx + minWidth(swpItem) <= 0) {
                                        dx += minWidth(swpItem);
                                        swpItem = items[swpIndex - 1];
                                        items[swpIndex - 1] = items[swpIndex];
                                        items[swpIndex] = swpItem;
                                        if (swpItem.wrap) {
                                            items[swpIndex - 1].wrap = true;
                                            swpItem.wrap = false;
                                        }
                                        needLayout = true;
                                        swpIndex--;
                                        if (swpIndex == 0 || swpItem.wrap) {
                                            break;
                                        }
                                    }
                                }
                                dx = 0;
                                break;
                            }
                        }
                    } else {
                        break;
                    }
                }
                CoolItem next = null;
                idx = index;
                while (dx > 0 && cur.lastCachedWidth - dx < minWidth(cur)) {
                    int dxx = cur.lastCachedWidth - minWidth(cur);
                    prev.idealWidth += dxx;
                    cur.idealWidth -= dxx;
                    needCalculate = true;
                    dx -= dxx;
                    if (dx > 0) {
                        if (idx + 1 < items.length && !isLastItemOfRow(idx)) {
                            idx++;
                            cur = items[idx];
                            if (next == null) {
                                next = cur;
                            }
                        } else {
                            if (dx >= 11 && next != null) {
                                CoolItem swpItem = next;
                                int swpIndex = index;
                                while (dx >= minWidth(swpItem)) {
                                    items[swpIndex + 1] = items[swpIndex];
                                    items[swpIndex] = swpItem;
                                    if (swpItem.wrap) {
                                        items[swpIndex].wrap = true;
                                        swpItem.wrap = false;
                                    }
                                    swpItem = items[swpIndex + 1];
                                    needLayout = true;
                                    dx -= minWidth(swpItem);
                                    swpIndex++;
                                    if (swpIndex >= items.length || isLastItemOfRow(swpIndex)) {
                                        break;
                                    }
                                }
                            }
                            dx = 0;
                            break;
                        }
                    }
                }
                prev.idealWidth += dx;
                if (dx != 0) {
                    needCalculate = true;
                }
                if (item != cur) {
                    if (cur.idealWidth - dx < 0) {
                        if (cur.idealWidth != 0) {
                            needCalculate = true;
                        }
                        cur.idealWidth = 0;
                    } else {
                        cur.idealWidth -= dx;
                    }
                } else {
                    item.idealWidth -= dx;
                }
            }
            if (needCalculate && !needLayout) {
                for (int i = 0; i < ws.length; i++) {
                    if (ws[i] != items[i].idealWidth) {
                        needLayout = true;
                        break;
                    }
                }
            }
        } else {
            int line = verticalLine(index);
            if (line + dy < 0) {
                if (index == 0 && isLastItemOfRow(index)) {
                } else {
                    CoolItem ci = items[index];
                    if ((index == 0 && items.length > 1) || (ci.wrap && index < items.length - 1)) {
                        items[index + 1].wrap = true;
                    }
                    for (int i = index; i > 0; i--) {
                        items[i] = items[i - 1];
                    }
                    items[0] = ci;
                    items[1].wrap = true;
                    ci.wrap = false;
                    needLayout = true;
                    needResize = true;
                }
            } else if (line + dy < getVerticalLines()) {
                int lineNumber = line + dy;
                int i = 0;
                for (i = 0; i < items.length; i++) {
                    if (lineNumber == 0) {
                        break;
                    }
                    if (items[i].wrap) {
                        lineNumber--;
                    }
                }
                if (i > 0) i--;
                CoolItem ci = items[index];
                if (index == 0 && isLastItemOfRow(index)) {
                    needResize = true;
                }
                if (ci.wrap) {
                    if (isLastItemOfRow(index)) {
                        needResize = true;
                    }
                    if (index < items.length - 1) {
                        items[index + 1].wrap = true;
                    }
                }
                int x = ci.getPosition().x + dx;
                if (x <= 0) {
                    if (i == 0) {
                        ci.wrap = false;
                    } else {
                        if (index == 0 && i == 1) {
                        } else {
                            ci.wrap = true;
                        }
                        if (i < items.length - 1) {
                            items[i + 1].wrap = false;
                        }
                    }
                } else {
                    int rowWidth = 0;
                    int separator = 2;
                    for (; i < items.length; i++) {
                        CoolItem item = items[i];
                        int minimum = item.minimumWidth + (item.minimumWidth != 0 ? 2 : 0);
                        rowWidth += 7 + 2 + Math.max(item.idealWidth, minimum) + separator;
                        int xx = item.getPosition().x;
                        if (xx < x && (x <= rowWidth || isLastItemOfRow(i))) {
                            item.idealWidth = Math.max(0, x - xx - (7 + 2 + minimum + separator));
                            minimum = ci.minimumWidth + (ci.minimumWidth != 0 ? 2 : 0);
                            int mw = 7 + 2 + minimum + separator;
                            ci.idealWidth = Math.max(item.minimumWidth, Math.max(ci.idealWidth, rowWidth - x - mw));
                            if (rowWidth - x - mw < ci.idealWidth) {
                                needResize = true;
                            }
                            break;
                        }
                    }
                    ci.wrap = false;
                }
                if (dy < 0 && x > 0 && i < items.length - 1) {
                    i++;
                }
                if (dy > 0) {
                    for (int j = index; j < i; j++) {
                        items[j] = items[j + 1];
                    }
                } else {
                    for (int j = index; j > i; j--) {
                        items[j] = items[j - 1];
                    }
                }
                items[i] = ci;
                items[0].wrap = false;
                needLayout = true;
            } else {
                if ((items[index].wrap || index == 0) && isLastItemOfRow(index)) {
                } else {
                    CoolItem ci = items[index];
                    if (index > 0 && ci.wrap) {
                        items[index + 1].wrap = true;
                    }
                    for (int i = index; i < items.length - 1; i++) {
                        items[i] = items[i + 1];
                    }
                    items[items.length - 1] = ci;
                    ci.wrap = true;
                    needLayout = true;
                    needResize = true;
                }
            }
        }
        int w = width;
        int h = height;
        if (needResize) {
            Point computeSize = computeSize(-1, -1, false);
            w = computeSize.x;
            h = computeSize.y;
        }
        if (needLayout) {
            SetWindowPos(handle, null, left, top, width, h, -1);
        }
        if (w > width) {
            for (int i = index; i < items.length; i++) {
                if (isLastItemOfRow(i)) {
                    moveDelta(i, width - height, 0);
                    break;
                }
            }
        }
        if (h != height && !ignoreResize) {
            setBounds(left, top, Math.max(0, width), Math.max(0, h), SWT.NONE);
            sendEvent(SWT.Resize);
        }
        return needLayout;
    }
",1
18099983,7,"    public void removeFromCategory(String category) {
        synchronized (i2) {
            checkItemDeleted();
            boolean catexist = false;
            if (category == null) throw new NullPointerException();
            loadPIMStruct();
            int j;
            for (j = 0; j < Integer.parseInt(categories[0]); j++) {
                if (category.equals(categories[j + 1])) {
                    catexist = true;
                    break;
                }
            }
            if (catexist) {
                int numCat = Integer.parseInt(categories[0]);
                for (int k = j; k < categories.length - 1; k++) {
                    categories[k] = categories[k + 1];
                }
                categories[0] = Integer.toString(--numCat);
                modified = true;
                if (numCat <= categories.length / 2) categories = adjustStringArray(categories, numCat + 2);
            }
        }
    }
",1
3123622,7,"        private void remove(int index) {
            Scan removed = scans[index];
            for (int i = index; i < length - 1; i++) {
                scans[i] = scans[i + 1];
            }
            scans[length - 1] = removed;
            length--;
        }
",1
8626036,7,"    public ActionEvent(Object source, String command) {
        super(source, java.awt.event.ActionEvent.ACTION_PERFORMED, command, 0, 0);
        String[] strs = command.split("" "");
        this.command = strs[0];
        if (strs.length > 1) {
            this.arguments = new String[strs.length - 1];
            for (int i = 0; i < strs.length - 1; i++) {
                this.arguments[i] = strs[i + 1];
            }
        }
    }
",0
13731773,7,"    private void sort(int jc) {
        TaskResult taux;
        int length = taur.length;
        for (int i = jc; i < length; i++) {
            if (taur[i] == null) {
                int i2;
                for (i2 = i; i2 < length - 1; i2++) {
                    taur[i2] = taur[i2 + 1];
                    taur[i2 + 1] = null;
                }
                length--;
            } else {
                for (int j = i + 1; j < length; j++) {
                    if (taur[j] != null) {
                        if (taur[i].getT1() > taur[j].getT1()) {
                            taux = taur[i];
                            taur[i] = taur[j];
                            taur[j] = taux;
                        } else {
                            if (taur[i].getT1() == taur[j].getT1()) {
                                if (taur[i].p < taur[j].p) {
                                    taux = taur[i];
                                    taur[i] = taur[j];
                                    taur[j] = taux;
                                } else {
                                    if (taur[i].p == taur[j].p) {
                                        if (taur[i].getInst() > taur[j].getInst()) {
                                            taux = taur[i];
                                            taur[i] = taur[j];
                                            taur[j] = taux;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
",1
683955,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
",1
10484126,7,"    @Override
    public void run() {
        final int[] opponentCards = new int[MonteCarlo.NB_HOLECARDS];
        for (int i = 0; i < m_nbSimulations; ++i) {
            for (int j = 0; j < m_nbMissingTableCards; ++j) {
                m_dynamicTable[m_nbCardsShowedOnTable + j] = m_deck[j];
            }
            final long boardCode = (MonteCarlo.Encode(m_dynamicTable, 0));
            final long myResult = HandEvaluator.hand7Eval(MonteCarlo.Encode(m_playerCards, boardCode));
            boolean lost = false;
            for (int j = m_nbMissingTableCards; j < m_nbCardsToDraw; j += 2) {
                opponentCards[0] = m_deck[j];
                opponentCards[1] = m_deck[j + 1];
                final int opponentResult = HandEvaluator.hand7Eval(MonteCarlo.Encode(opponentCards, boardCode));
                if (opponentResult > myResult) {
                    lost = true;
                    break;
                }
            }
            if (!lost) {
                m_gamesWon++;
            }
            for (int k = 0; k != m_nbCardsToDraw; ++k) {
                final int l = m_myRandom.nextInt(m_deck.length - k) + k;
                final int tmp = m_deck[l];
                m_deck[l] = m_deck[k];
                m_deck[k] = tmp;
            }
        }
    }
",1
17066345,7,"    private static int[] getNeighbors(int imgval[][], int x, int y, int w, int h) {
        int a[] = new int[10];
        for (int n = 1; n < 10; n++) {
            a[n] = 0;
        }
        if (y - 1 >= 0) {
            a[2] = imgval[x][y - 1];
            if (x + 1 < w) {
                a[3] = imgval[x + 1][y - 1];
            }
            if (x - 1 >= 0) {
                a[9] = imgval[x - 1][y - 1];
            }
        }
        if (y + 1 < h) {
            a[6] = imgval[x][y + 1];
            if (x + 1 < w) {
                a[5] = imgval[x + 1][y + 1];
            }
            if (x - 1 >= 0) {
                a[7] = imgval[x - 1][y + 1];
            }
        }
        if (x + 1 < w) {
            a[4] = imgval[x + 1][y];
        }
        if (x - 1 >= 0) {
            a[8] = imgval[x - 1][y];
        }
        return a;
    }
",0
20267701,7,"    void extendRuns(byte[] tags) {
        for (int i = 1; i < monomerCount - 4; ++i) if (tags[i] == TAG_NADA && tags[i + 1] != TAG_NADA) tags[i] = tags[i + 1];
        tags[0] = tags[1];
        tags[monomerCount - 1] = tags[monomerCount - 2];
    }
",1
3172480,7,"    public Hashtable[] removeArrayElement(Hashtable[] cons, int i) {
        if (cons != null && cons.length > i) {
            Hashtable[] newhash = new Hashtable[cons.length - 1];
            for (int j = 0; j < i; j++) {
                newhash[j] = cons[j];
            }
            for (int j = i + 1; j < newhash.length; j++) {
                newhash[j] = cons[j + 1];
            }
            return newhash;
        }
        return null;
    }
",0
20506212,7,"    private void getNextChangingElement(int a0, boolean isWhite, int[] ret) {
        int[] pce = this.prevChangingElems;
        int ces = this.changingElemSize;
        int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
        if (isWhite) {
            start &= ~0x1;
        } else {
            start |= 0x1;
        }
        int i = start;
        for (; i < ces; i += 2) {
            int temp = pce[i];
            if (temp > a0) {
                lastChangingElement = i;
                ret[0] = temp;
                break;
            }
        }
        if (i + 1 < ces) {
            ret[1] = pce[i + 1];
        }
    }
",1
11714316,7,"    private void getNextChangingElement(int a0, boolean isWhite, int[] ret) {
        int[] pce = this.prevChangingElems;
        int ces = this.changingElemSize;
        int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
        if (isWhite) {
            start &= ~0x1;
        } else {
            start |= 0x1;
        }
        int i = start;
        for (; i < ces; i += 2) {
            int temp = pce[i];
            if (temp > a0) {
                lastChangingElement = i;
                ret[0] = temp;
                break;
            }
        }
        if (i + 1 < ces) {
            ret[1] = pce[i + 1];
        }
    }
",1
43239,7,"    void removeBall(int index) {
        int npoints = all_x.length;
        int[] temp_all_x = new int[npoints - 1];
        int[] temp_all_y = new int[npoints - 1];
        double[] temp_all_radii = new double[npoints - 1];
        for (int i = 0; i < index; i++) {
            temp_all_x[i] = all_x[i];
            temp_all_y[i] = all_y[i];
            temp_all_radii[i] = all_radii[i];
        }
        for (int j = index; j < npoints - 1; j++) {
            temp_all_x[j] = all_x[j + 1];
            temp_all_y[j] = all_y[j + 1];
            temp_all_radii[j] = all_radii[j + 1];
        }
        all_x = temp_all_x;
        all_y = temp_all_y;
        all_radii = temp_all_radii;
    }
",1
7419197,7,"    public void compact(int i) {
        for (int j = i; j < K - 1; j++) {
            r[j] = r[j + 1];
            w[j] = w[j + 1];
            wm[j] = wm[j + 1];
        }
        K--;
    }
",1
7074779,7,"    public void splitEdgeNearPoint(GraphEdgeModel edge, Point2D pt) {
        Point2D edgeControls[] = getActualEdgeControls(edge);
        Point2D ctrls[];
        if (edgeControls.length < 4) {
            ctrls = new Point2D[4];
            lineToBezier(edgeControls, 0, ctrls, 0);
        } else ctrls = NearestPointOnCurve.splitBezierSetNearPoint(pt, edgeControls);
        Point2D newCtrls[] = new Point2D[ctrls.length - 2];
        for (int i = 0; i < newCtrls.length; i++) newCtrls[i] = ctrls[i + 1];
        edge.setControlPoints(newCtrls);
        repaint(edge.getChangeBBox());
    }
",0
17800181,7,"    public String getAdjustedString(String text) {
        String[] tokens = text.toLowerCase().split(""\\s+"");
        for (int i = 0; i < tokens.length - 1; i++) {
            if (tokens[i + 1].equals(""$"")) {
                try {
                    Double.parseDouble(tokens[i]);
                    String num = tokens[i];
                    tokens[i] = tokens[i + 1];
                    tokens[i + 1] = num;
                    i++;
                } catch (NumberFormatException e) {
                }
            }
        }
        List<String> splitTokens = new ArrayList<String>(tokens.length * 2);
        for (String token : tokens) {
            String[] tokenSplits = token.replace(""-"", "" - "").split(""[_ ]"");
            for (String s : tokenSplits) splitTokens.add(s);
        }
        StringBuffer retval = new StringBuffer();
        for (int i = 0; i < splitTokens.size() - 1; i++) {
            retval.append(splitTokens.get(i));
            retval.append(' ');
        }
        retval.append(splitTokens.get(splitTokens.size() - 1));
        return retval.toString();
    }
",0
14062089,7,"    private static GeneralPathX parseOracleStruct(STRUCT s) throws SQLException {
        GeneralPathX resp = new GeneralPathX();
        ARRAY infoARRAY = null;
        ARRAY ordsARRAY = null;
        Datum[] info_array = null;
        Datum[] ords_array = null;
        int info_array_size = 0;
        int[] start_ind;
        int[] end_ind;
        int dims = 0;
        boolean next_must_do_first = true;
        Datum[] aux = s.getOracleAttributes();
        infoARRAY = (ARRAY) aux[3];
        ordsARRAY = (ARRAY) aux[4];
        dims = ((NUMBER) aux[0]).intValue() / 1000;
        if (dims == 0) {
            dims = 2;
        }
        info_array = (Datum[]) infoARRAY.getOracleArray();
        ords_array = (Datum[]) ordsARRAY.getOracleArray();
        info_array_size = info_array.length / 3;
        int last_index = ords_array.length - dims + 1;
        start_ind = new int[info_array_size];
        end_ind = new int[info_array_size];
        for (int i = 0; i < info_array_size; i++) start_ind[i] = ((NUMBER) info_array[3 * i]).intValue();
        for (int i = 0; i < (info_array_size - 1); i++) end_ind[i] = start_ind[i + 1] - 1;
        end_ind[info_array_size - 1] = last_index;
        int lineType = PathIterator.SEG_LINETO;
        if (end_ind[0] == 0) {
            for (int i = 1; i < info_array_size; i++) {
                lineType = getLineToType(info_array, i);
                next_must_do_first = addOrdsToGPX(resp, start_ind[i] - 1, end_ind[i] - 1, ords_array, dims, lineType, (i == 1), next_must_do_first);
            }
        } else {
            for (int i = 0; i < info_array_size; i++) {
                lineType = getLineToType(info_array, i);
                addOrdsToGPX(resp, start_ind[i] - 1, end_ind[i] - 1, ords_array, dims, lineType, true, true);
            }
        }
        return resp;
    }
",0
15153779,7,"    public double[] melFilter(double bin[], int cbin[]) {
        double temp[] = new double[numMelFilters + 2];
        for (int k = 1; k <= numMelFilters; k++) {
            double num1 = 0, num2 = 0;
            for (int i = cbin[k - 1]; i <= cbin[k]; i++) {
                num1 += ((i - cbin[k - 1] + 1) / (cbin[k] - cbin[k - 1] + 1)) * bin[i];
            }
            for (int i = cbin[k] + 1; i <= cbin[k + 1]; i++) {
                num2 += (1 - ((i - cbin[k]) / (cbin[k + 1] - cbin[k] + 1))) * bin[i];
            }
            temp[k] = num1 + num2;
        }
        double fbank[] = new double[numMelFilters];
        for (int i = 0; i < numMelFilters; i++) {
            fbank[i] = temp[i + 1];
        }
        return fbank;
    }
",1
16405055,7,"    void setDestinations(int nArgs, FtsAtom[] args) {
        destinations = new String[nArgs / 2];
        destinationChannels = new int[nArgs / 2];
        int j = 0;
        for (int i = 0; i < nArgs; i += 2) {
            destinations[j] = args[i].symbolValue.toString();
            destinationChannels[j] = args[i + 1].intValue;
            j++;
        }
        if (listener != null) listener.destinationsChanged();
    }
",1
604775,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
9019996,7,"        public final Value doApply(Interpreter r, Value[] vlr) throws ContinuationException {
            final int vls = vlr.length;
            SIZESWITCH: switch(vls) {
                case 0:
                    switch(id) {
                        case CLASSPATHEXTENSION:
                            URL[] urls = r.dynenv.getClassPath();
                            Pair p = EMPTYLIST;
                            for (int i = urls.length - 1; i >= 0; i--) {
                                p = new Pair(new SchemeString(urls[i].toString()), p);
                            }
                            return p;
                        case COMPACTSTRINGREP:
                            return truth(SchemeString.compactRepresentation);
                        case CURRENTWIND:
                            return r.dynenv.wind;
                        case GENSYM:
                            long unv = r.tctx.nextUnique();
                            return Symbol.intern(GENSYM_MAGIC_PREFIX + base64encode(unv));
                        case INTERACTIONENVIRONMENT:
                            return r.tpl.asValue();
                        case SISCINITIAL:
                            try {
                                return new MemorySymEnv(r.lookupContextEnv(Util.SISC_SPECIFIC));
                            } catch (ArrayIndexOutOfBoundsException e) {
                                throwPrimException(liMessage(SISCB, ""nosiscspecificenv""));
                            }
                        default:
                            break SIZESWITCH;
                    }
                case 1:
                    switch(id) {
                        case CLASSPATHEXTENSIONAPPEND:
                            for (Pair p = pair(vlr[0]); p != EMPTYLIST; p = (Pair) p.cdr()) {
                                r.dynenv.extendClassPath(url(p.car()));
                            }
                            return VOID;
                        case SEALIMMUTABLEPAIR:
                            immutablePair(vlr[0]).makeImmutable();
                            return VOID;
                        case SEALIMMUTABLEVECTOR:
                            immutableVector(vlr[0]).makeImmutable();
                            return VOID;
                        case COMPACTSTRINGREP:
                            SchemeString.compactRepresentation = truth(vlr[0]);
                            return VOID;
                        case NUMBER2STRING:
                            return new SchemeString(num(vlr[0]).toString());
                        case GETENVIRONMENT:
                            try {
                                return r.getCtx().lookupContextEnv(symbol(vlr[0])).asValue();
                            } catch (ArrayIndexOutOfBoundsException e) {
                                throwPrimException(liMessage(SISCB, ""noenv"", vlr[0].synopsis()));
                                return VOID;
                            }
                        case PARENTENVIRONMENT:
                            SymbolicEnvironment env = env(vlr[0]);
                            SymbolicEnvironment parent = env.getParent();
                            if (parent == null) return FALSE; else return parent.asValue();
                        case GETSIDECAR:
                            return r.tpl.getSidecarEnvironment(symbol(vlr[0])).asValue();
                        case GETENV:
                            String str = r.getCtx().getProperty(string(vlr[0]));
                            if (str == null) {
                                return FALSE;
                            } else {
                                return new SchemeString(str);
                            }
                        case GENSYM:
                            long unv = r.tctx.nextUnique();
                            return Symbol.intern(GENSYM_MAGIC_PREFIX + base64encode(unv));
                        case COMPILE:
                            return new Closure(false, (short) 0, r.compile(vlr[0]), ZV, new int[0]);
                        case CALLEC:
                            Value kproc = vlr[0];
                            r.setupTailCall(CALLEC_APPEVAL, r.captureEscapingContinuation());
                            return kproc;
                        case CALLCC:
                            kproc = vlr[0];
                            r.setupTailCall(CALLCC_APPEVAL, r.captureContinuation());
                            return kproc;
                        case CALLFC:
                            kproc = vlr[0];
                            r.setupTailCall(CALLFC_APPEVAL, r.fk.capture(r));
                            return kproc;
                        case CURRENTWIND:
                            r.dynenv.wind = vlr[0];
                            return VOID;
                        case LOADNL:
                            try {
                                Class clazz = Class.forName(string(vlr[0]), true, Util.currentClassLoader());
                                return (NativeLibrary) clazz.newInstance();
                            } catch (Exception e) {
                                throwPrimException(e.getMessage());
                            }
                        case GETPROP:
                            int loc = r.tpl.getLoc(symbol(vlr[0]));
                            if (loc == -1) return FALSE; else return r.tpl.lookup(loc);
                        case STRING2NUMBER:
                            String st = string(vlr[0]);
                            try {
                                return (Quantity) r.dynenv.parser.nextExpression(new PushbackReader(new StringReader(st)));
                            } catch (ClassCastException cce) {
                                return FALSE;
                            } catch (NumberFormatException nf) {
                                return FALSE;
                            } catch (IOException e) {
                                return FALSE;
                            }
                        case NLBINDINGNAMES:
                            Value[] va = nlib(vlr[0]).getLibraryBindingNames(r);
                            return valArrayToList(va, 0, va.length);
                        case INTERACTIONENVIRONMENT:
                            Value last = r.getCtx().toplevel_env.asValue();
                            r.getCtx().toplevel_env = env(vlr[0]);
                            return last;
                        case REPORTENVIRONMENT:
                            if (FIVE.equals(num(vlr[0]))) try {
                                return new MemorySymEnv(r.lookupContextEnv(Util.REPORT));
                            } catch (ArrayIndexOutOfBoundsException e) {
                                throwPrimException(liMessage(SISCB, ""noreportenv""));
                            } else throwPrimException(liMessage(SISCB, ""unsupportedstandardver""));
                        case NULLENVIRONMENT:
                            switch(num(vlr[0]).indexValue()) {
                                case 5:
                                    MemorySymEnv ae = new MemorySymEnv();
                                    sisc.compiler.Compiler.addSpecialForms(ae);
                                    return ae;
                                case 0:
                                    return new MemorySymEnv();
                                default:
                                    throwPrimException(liMessage(SISCB, ""unsupportedstandardver""));
                                    return VOID;
                            }
                        default:
                            break SIZESWITCH;
                    }
                case 2:
                    switch(id) {
                        case NLBINDING:
                            return nlib(vlr[0]).getBindingValue(r, symbol(vlr[1]));
                        case COMPILE:
                            return new Closure(false, (short) 0, r.compile(vlr[0], env(vlr[1])), ZV, new int[0]);
                        case WITHENVIRONMENT:
                            Procedure thunk = proc(vlr[1]);
                            r.tpl = env(vlr[0]);
                            r.setupTailCall(WITHENV_APPEVAL, ZV);
                            return thunk;
                        case WITHFC:
                            Procedure proc = proc(vlr[1]);
                            Procedure ehandler = proc(vlr[0]);
                            r.setFailureContinuation(new ApplyValuesContEval(ehandler));
                            r.setupTailCall(WITHFC_APPEVAL, ZV);
                            return proc;
                        case CALLWITHVALUES:
                            Procedure producer = proc(vlr[0]);
                            Procedure consumer = proc(vlr[1]);
                            r.pushExpr(new ApplyValuesContEval(consumer));
                            r.setupTailCall(CALLWITHVALUES_APPEVAL, ZV);
                            return producer;
                        case GETPROP:
                            Value ret = null;
                            if (vlr[1] instanceof SymbolicEnvironment) {
                                ret = env(vlr[1]).lookup(symbol(vlr[0]));
                            } else {
                                ret = r.tpl.getSidecarEnvironment(symbol(vlr[1])).lookup(symbol(vlr[0]));
                            }
                            return (ret == null) ? FALSE : ret;
                        case REMPROP:
                            if (vlr[1] instanceof SymbolicEnvironment) {
                                env(vlr[1]).undefine(symbol(vlr[0]));
                            } else {
                                r.tpl.getSidecarEnvironment(symbol(vlr[1])).undefine(symbol(vlr[0]));
                            }
                            return VOID;
                        case PUTPROP:
                            r.tpl.define(symbol(vlr[0]), vlr[1]);
                            return VOID;
                        case SETBOX:
                            try {
                                box(vlr[0]).set(vlr[1]);
                            } catch (ImmutableException e) {
                                throwPrimException(liMessage(SISCB, ""isimmutable"", ""box"", vlr[0].synopsis()));
                            }
                            return VOID;
                        case SETCAR:
                            truePair(vlr[0]).setCar(vlr[1]);
                            return VOID;
                        case SETCDR:
                            truePair(vlr[0]).setCdr(vlr[1]);
                            return VOID;
                        case SETENVIRONMENT:
                            r.getCtx().defineContextEnv(symbol(vlr[0]), env(vlr[1]));
                            return VOID;
                        case SIGHOOK:
                            SignalHook.addHandler(string(vlr[0]), proc(vlr[1]), r.dynenv);
                            return VOID;
                        case SIGUNHOOK:
                            SignalHook.removeHandler(string(vlr[0]), proc(vlr[1]), r.dynenv);
                            return VOID;
                        case GETSIDECAR:
                            return env(vlr[1]).getSidecarEnvironment(symbol(vlr[0])).asValue();
                        case STRING2NUMBER:
                            try {
                                int radix = num(vlr[1]).indexValue();
                                if (r.dynenv.parser.lexer.strictR5RS && !(radix == 10 || radix == 16 || radix == 2 || radix == 8)) throwPrimException(liMessage(SISCB, ""invalidradix""));
                                return (Quantity) r.dynenv.parser.nextExpression(new PushbackReader(new StringReader(string(vlr[0]))), radix, 0);
                            } catch (NumberFormatException nf) {
                                return FALSE;
                            } catch (IOException e) {
                                return FALSE;
                            }
                        case NUMBER2STRING:
                            int radix = num(vlr[1]).indexValue();
                            if (r.dynenv.parser.lexer.strictR5RS && !(radix == 10 || radix == 16 || radix == 2 || radix == 8)) throwPrimException(liMessage(SISCB, ""invalidradix""));
                            return new SchemeString(num(vlr[0]).toString(radix));
                        case STRINGFILL:
                            SchemeString st = str(vlr[0]);
                            char c = character(vlr[1]);
                            for (int i = 0; i < st.length(); i++) st.set(i, c);
                            return VOID;
                        case VECTORFILL:
                            vec(vlr[0]).fill(vlr[1]);
                            return VOID;
                        default:
                            break SIZESWITCH;
                    }
                case 3:
                    switch(id) {
                        case STRINGSET:
                            int index = num(vlr[1]).indexValue();
                            try {
                                str(vlr[0]).set(index, character(vlr[2]));
                            } catch (ArrayIndexOutOfBoundsException e) {
                                throwPrimException(liMessage(SISCB, ""indexoob"", new Object[] { new Integer(index), vlr[0].synopsis() }));
                            }
                            return VOID;
                        case VECTORSET:
                            index = num(vlr[1]).indexValue();
                            try {
                                vec(vlr[0]).set(index, vlr[2]);
                            } catch (ArrayIndexOutOfBoundsException e) {
                                throwPrimException(liMessage(SISCB, ""indexoob"", new Object[] { new Integer(index), vlr[0].synopsis() }));
                            }
                            return VOID;
                        case GETPROP:
                            Value ret = null;
                            if (vlr[1] instanceof SymbolicEnvironment) {
                                ret = env(vlr[1]).lookup(symbol(vlr[0]));
                            } else {
                                ret = r.tpl.getSidecarEnvironment(symbol(vlr[1])).lookup(symbol(vlr[0]));
                            }
                            return (ret == null) ? vlr[2] : ret;
                        case PUTPROP:
                            Symbol lhs = symbol(vlr[0]);
                            Value rhs = vlr[2];
                            SymbolicEnvironment env;
                            if (vlr[1] instanceof SymbolicEnvironment) {
                                env = (SymbolicEnvironment) vlr[1];
                            } else {
                                env = r.tpl.getSidecarEnvironment((Symbol) vlr[1]);
                            }
                            updateName(rhs, lhs);
                            env.define(lhs, rhs);
                            return VOID;
                    }
            }
            switch(id) {
                case APPLY:
                    Procedure proc = proc(vlr[0]);
                    int l = vls - 2;
                    Pair args = pair(vlr[l + 1]);
                    Value newvlr[] = r.createValues(l + length(args));
                    int j;
                    for (j = 0; j < l; j++) {
                        newvlr[j] = vlr[j + 1];
                    }
                    for (; args != EMPTYLIST; args = (Pair) args.cdr()) {
                        newvlr[j++] = args.car();
                    }
                    r.setupTailCall(APPLY_APPEVAL, newvlr);
                    return proc;
                default:
                    throwArgSizeException();
            }
            return VOID;
        }
",1
2477024,7,"        public List<Node> neighbours() {
            List<Node> neighbours = new ArrayList<Node>();
            for (int i = 0; i < rows.length - 1; i++) {
                int[] newrows = Arrays.copyOf(rows, rows.length);
                int temp = newrows[i];
                newrows[i] = newrows[i + 1];
                newrows[i + 1] = temp;
                neighbours.add(getNode(newrows));
            }
            return neighbours;
        }
",1
858094,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
8233624,7,"    public int[] getStateSequence(int[] ob) {
        int l = ob.length;
        int stateCount = stProb.length;
        int[][] top = new int[l][stateCount];
        double[][] d = new double[l][stateCount];
        for (int i = 0; i < stateCount; i++) {
            d[0][i] = stProb[i] * obProb[i][ob[0]];
        }
        for (int t = 1; t < l; t++) {
            for (int i = 0; i < stateCount; i++) {
                double max = -Double.MAX_VALUE;
                int top_state = -1;
                for (int j = 0; j < stateCount; j++) {
                    double v = d[t - 1][j] * transProb[j][i];
                    if (v > max) {
                        max = v;
                        top_state = j;
                    }
                }
                d[t][i] = max * obProb[i][ob[t]];
                top[t][i] = top_state;
            }
        }
        int[] seq = new int[l];
        double max = -Double.MAX_VALUE;
        int maxi = -1;
        for (int i = 0; i < stateCount; i++) {
            double v = d[l - 1][i];
            if (v > max) {
                max = v;
                maxi = i;
            }
        }
        seq[l - 1] = maxi;
        for (int t = l - 2; t >= 0; t--) {
            seq[t] = top[t + 1][seq[t + 1]];
        }
        return seq;
    }
",1
22476969,7,"    public String convertTime(long millis) {
        String[] symbols = { ""wks"", ""days"", ""hrs"", ""mins"", ""secs"" };
        long[] multiples = { 7L, 24L, 60L, 60L };
        long[] units = new long[5];
        units[4] = 1000;
        for (int i = 3; i >= 0; i--) units[i] = units[i + 1] * multiples[i];
        StringBuilder b = new StringBuilder();
        long rest = millis;
        for (int i = 0; i < 5; i++) {
            int num = (int) (rest / units[i]);
            if (num > 0) b.append(num + symbols[i] + "" "");
            rest %= units[i];
        }
        return b.toString();
    }
",1
6032211,7,"    public SkytraqTransportMessageModel(byte[] payload) {
        this.messageID = payload[0];
        this.messageBody = new byte[payload.length - 1];
        for (int i = messageBody.length - 1; i >= 0; i--) {
            messageBody[i] = payload[i + 1];
        }
    }
",1
2404010,7,"    public Block<?> getTestBlockForCon(Constructor<T> pCon, Expression<?>[] curPlans) {
        notNull(pCon);
        notNull(curPlans);
        final Class<T> testeeType = pCon.getDeclaringClass();
        final Block<?> b = new BlockImpl(testeeType, pCon, testBlockSpaces);
        final BlockStatement<?>[] bs = new BlockStatement[curPlans.length + 1];
        final Variable<?>[] ids = new Variable[curPlans.length];
        Class<?>[] paramsTypes = pCon.getParameterTypes();
        for (int i = 0; i < curPlans.length; i++) {
            ids[i] = b.getNextID(paramsTypes[i]);
            bs[i] = new LocalVariableDeclarationStatement(ids[i], curPlans[i]);
        }
        ConstructorCall<T> conPlan = null;
        if (typeGraph.getWrapper(pCon.getDeclaringClass()).isInnerClass()) {
            Expression[] paramPlans = new Expression[curPlans.length - 1];
            for (int j = 0; j < paramPlans.length; j++) {
                paramPlans[j] = ids[j + 1];
            }
            conPlan = new ConstructorCall<T>(testeeType, pCon, paramPlans, ids[0]);
        } else {
            conPlan = new ConstructorCall<T>(testeeType, pCon, ids);
        }
        bs[curPlans.length] = new ExpressionStatement<T>(conPlan);
        List<BlockStatement> blockStatements = new LinkedList<BlockStatement>();
        for (BlockStatement blockStatement : bs) blockStatements.add(blockStatement);
        b.setBlockStmts(blockStatements);
        return b;
    }
",1
19731645,7,"    public void moveFloor(int from, int to) {
        if (from < 0 || from >= floors.length) throw new IndexOutOfBoundsException(""from"");
        if (to < 0 || to >= floors.length) throw new IndexOutOfBoundsException(""to"");
        if (from == to) return;
        MapFloor mover = floors[from];
        if (from > to) {
            for (int i = from; i > to; i--) floors[i] = floors[i - 1];
            floors[to] = mover;
        } else {
            for (int i = from; i < to; i++) floors[i] = floors[i + 1];
            floors[to] = mover;
        }
    }
",1
5731800,7,"    public static void main(String[] args) {
        int nmcnt = 0;
        int mmcnt = 0;
        int umcnt = 0;
        int qccnt = 0;
        int total = 0;
        int[] lenHisto = new int[100];
        if (args.length < 2) {
            System.out.println(""usage: <output file name> <eland files>"");
            System.exit(0);
        }
        String outName = args[0];
        String[] files = new String[args.length - 1];
        for (int i = 0; i < files.length; i++) {
            files[i] = args[i + 1];
        }
        System.out.println(""Working with:"");
        for (String s : files) {
            System.out.println(s);
        }
        int[] lengths = getLengths(files);
        BufferedReader[] elands = new BufferedReader[files.length];
        String[] lines = new String[files.length];
        String all_f = outName + "".all.eland"";
        String sum_f = outName + "".summary"";
        System.out.println(""Writing to:\n"" + all_f + ""\n"" + sum_f);
        FileWriter fw_all = null;
        FileWriter sum = null;
        try {
            fw_all = new FileWriter(all_f);
            sum = new FileWriter(sum_f);
        } catch (IOException io) {
            System.out.println(""Can't initialize files!"");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
            System.exit(0);
        }
        assert (fw_all != null);
        assert (sum != null);
        for (int i = 0; i < elands.length; i++) {
            try {
                elands[i] = new BufferedReader(new FileReader(files[i]));
            } catch (FileNotFoundException e) {
                System.out.println(""Can't find file: "" + files[i]);
            }
        }
        try {
            while (elands[0].ready()) {
                total++;
                if (total % 10000 == 0) {
                    System.out.print(""."");
                }
                for (int i = 0; i < elands.length; i++) {
                    lines[i] = elands[i].readLine();
                }
                if (!sameRead(lines)) {
                    System.out.println(""reads are not the same!"");
                    write(lines);
                    System.exit(0);
                }
                if (hasQCerror(lines[0])) {
                    qccnt++;
                    fw_all.write(alnToLine(lines[lines.length - 1], lengths[lines.length - 1]) + ""\tQC\n"");
                    continue;
                }
                if (hasNoMatch(lines[0])) {
                    try {
                        fw_all.write(alnToLine(lines[lines.length - 1], lengths[lines.length - 1]) + ""\tNM\n"");
                    } catch (IOException io) {
                        System.out.println(""Warning sequence length not as long as line length: "" + lines[lines.length - 1]);
                        System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
                        continue;
                    }
                    nmcnt++;
                    continue;
                }
                boolean umatch = false;
                for (int i = lines.length - 1; i >= 0; i--) {
                    if (hasUniqueMatch(lines[i])) {
                        fw_all.write(lines[i].substring(0, lines[i].indexOf('\t') + 1));
                        String seq = null;
                        seq = getSeq(lines[i], lengths[i]);
                        lenHisto[seq.length()]++;
                        fw_all.write(seq);
                        fw_all.write(lines[i].substring(lines[i].indexOf('\t', lines[i].indexOf(seq) + 1)));
                        fw_all.write(""\n"");
                        umatch = true;
                        umcnt++;
                        break;
                    }
                }
                if (umatch) {
                    continue;
                }
                boolean mmatch = false;
                for (int i = lines.length - 1; i >= 0; i--) {
                    if (hasMultiMatch(lines[i])) {
                        alnToLine(lines[i], lengths[i]);
                        fw_all.write(alnToLine(lines[i], lengths[i]) + ""\tMM\n"");
                        mmatch = true;
                        mmcnt++;
                        break;
                    }
                }
                if (!mmatch) {
                    System.out.println(""Error! No matches?!?!"");
                    for (String l : lines) System.out.println(l);
                }
            }
            sum.write(""total\t"" + total + ""\n"");
            sum.write(""unique\t"" + umcnt + ""\n"");
            sum.write(""multi\t"" + mmcnt + ""\n"");
            sum.write(""none\t"" + nmcnt + ""\n"");
            sum.write(""QC\t"" + qccnt + ""\n"");
            for (int i = 0; i < lenHisto.length; i++) {
                if (lenHisto[i] != 0) {
                    sum.write(i + ""\t"" + lenHisto[i] + ""\n"");
                }
            }
            System.out.printf(""%n||Total reads |%d|%n||Unique Matches |%d|%n||Multimatches |%d|%n||No Match |%d|%n||Poor quality |%d|%n"", total, umcnt, mmcnt, nmcnt, qccnt);
            fw_all.close();
            sum.close();
        } catch (IOException io) {
            System.out.println(""Error Iterating on file"");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
        }
    }
",1
5829828,7,"    protected void buildGUI() {
        if (static_pr == null) {
            static_pr = new PropertyArray();
            static_pr.text = prText;
            static_pr.textName = prTextName;
            static_pr.bool = prBool;
            static_pr.boolName = prBoolName;
        }
        if (static_presets == null) {
            static_presets = new Presets(getClass(), static_pr.toProperties(true));
        }
        presets = static_presets;
        pr = (PropertyArray) static_pr.clone();
        batchVector = new ArrayList();
        new BatchObjectArray();
        GridBagConstraints con;
        JButton ggCmd;
        JCheckBox ggVisible, ggConsole;
        JScrollPane ggBatchPane, ggParamPane;
        gui = new GUISupport();
        con = gui.getGridBagConstraints();
        con.insets = new Insets(1, 2, 1, 2);
        final BatchDlg enc_this = this;
        cbo = new ClipboardOwner() {

            public void lostOwnership(Clipboard clipboard, Transferable contents) {
            }
        };
        procL = new ProcessorListener() {

            public void processorStarted(ProcessorEvent e) {
                teleAction();
            }

            public void processorStopped(ProcessorEvent e) {
                teleAction();
            }

            public void processorPaused(ProcessorEvent e) {
                teleAction();
            }

            public void processorResumed(ProcessorEvent e) {
                teleAction();
            }

            public void processorProgress(ProcessorEvent e) {
                teleAction();
            }

            private void teleAction() {
                synchronized (enc_this) {
                    enc_this.notify();
                }
            }
        };
        ActionListener al = new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                int ID = gui.getItemID(e);
                int i, j, k;
                int[] rows;
                BatchObject[] dup;
                Transferable t;
                BatchObject bObj;
                switch(ID) {
                    case GG_CMDOPEN:
                        if (batchTable.getSelectedRowCount() != 1) break;
                        bObj = (BatchObject) batchVector.get(batchTable.getSelectedRow());
                        if (bObj.command != BatchObject.CMD_MODULE) break;
                        DocumentFrame procWin;
                        try {
                            procWin = getProcInstance(bObj, null);
                            procWin.fillGUI();
                            procWin.setVisible(true);
                        } catch (Exception e1) {
                            GUIUtil.displayError(getComponent(), e1, getTitle());
                        }
                        break;
                    case GG_CMDADD:
                        i = batchTable.getSelectedRow() + 1;
                        i = i == 0 ? batchVector.size() : i;
                        batchTable.clearSelection();
                        batchVector.add(i, new BatchObject());
                        batchTM.fireTableRowsInserted(i, i);
                        batchTable.setRowSelectionInterval(i, i);
                        break;
                    case GG_CMDCUT:
                    case GG_CMDCOPY:
                        rows = batchTable.getSelectedRows();
                        if (rows.length > 0) {
                            dup = new BatchObject[rows.length];
                            for (i = 0; i < rows.length; i++) {
                                dup[i] = new BatchObject((BatchObject) batchVector.get(rows[i]));
                            }
                            AbstractApplication.getApplication().getClipboard().setContents(new BatchObjectArray(dup), cbo);
                            if (ID == GG_CMDCUT) {
                                for (boolean finished = false; !finished; ) {
                                    for (i = 0, j = -1, k = -1; i < rows.length; i++) {
                                        if (rows[i] > j) {
                                            j = rows[i];
                                            k = i;
                                        }
                                    }
                                    if (j >= 0) {
                                        batchVector.remove(j);
                                        rows[k] = -1;
                                        batchTM.fireTableRowsDeleted(j, j);
                                    } else {
                                        finished = true;
                                    }
                                }
                            }
                        }
                        break;
                    case GG_CMDPASTE:
                        i = batchTable.getSelectedRow() + 1;
                        i = i == 0 ? batchVector.size() : i;
                        try {
                            t = AbstractApplication.getApplication().getClipboard().getContents(enc_this);
                            if (t != null) {
                                if (t.isDataFlavorSupported(BatchObjectArray.flavor)) {
                                    dup = (BatchObject[]) t.getTransferData(BatchObjectArray.flavor);
                                    if (dup.length > 0) {
                                        batchTable.clearSelection();
                                        for (j = 0, k = i; j < dup.length; j++, k++) {
                                            batchVector.add(k, dup[j]);
                                        }
                                        batchTM.fireTableRowsInserted(i, k - 1);
                                        batchTable.setRowSelectionInterval(i, k - 1);
                                    }
                                }
                            }
                        } catch (IllegalStateException e97) {
                        } catch (IOException e98) {
                        } catch (UnsupportedFlavorException e99) {
                        }
                        break;
                }
            }
        };
        tml = new TableModelListener() {

            public void tableChanged(TableModelEvent e) {
                int i, k;
                BatchObject bObj;
                if (e.getSource() == batchTM) {
                    if (e.getType() == TableModelEvent.DELETE) return;
                    k = e.getFirstRow();
                    if (k >= 0 && !batchVector.isEmpty()) {
                        bObj = (BatchObject) batchVector.get(k);
                        if ((bObj.command == BatchObject.CMD_MODULE) && (bObj.modObj.modClass == null)) {
                            final DocumentHandler dh = AbstractApplication.getApplication().getDocumentHandler();
                            final DocumentFrame[] modules = new DocumentFrame[dh.getDocumentCount()];
                            for (int m = 0; m < modules.length; m++) {
                                modules[m] = ((Session) dh.getDocument(m)).getFrame();
                            }
                            String[] winNames;
                            ListDlg dlg;
                            PropertyArray pa;
                            String str;
                            int winNum = modules.length;
                            List v;
                            for (i = 0; i < winNum; i++) {
                                str = modules[i].getClass().getName();
                                str = str.substring(str.lastIndexOf('.') + 1);
                                if ((modules[i] == enc_this) || Util.isValueInArray(str, EXCLUDE_DLG)) {
                                    winNum--;
                                    for (int j = i; j < winNum; j++) {
                                        modules[j] = modules[j + 1];
                                    }
                                    i--;
                                    continue;
                                }
                            }
                            winNames = new String[winNum];
                            for (i = 0; i < winNum; i++) {
                                winNames[i] = modules[i].getTitle();
                            }
                            if (winNum > 1) {
                                dlg = new ListDlg(getWindow(), ""Choose Module"", winNames);
                                i = dlg.getList();
                            } else {
                                i = winNum - 1;
                            }
                            if (i < 0) return;
                            bObj.modObj.name = winNames[i];
                            ((DocumentFrame) modules[i]).fillPropertyArray();
                            pa = ((DocumentFrame) modules[i]).getPropertyArray();
                            bObj.modObj.prParam = pa.toProperties(true);
                            bObj.modObj.modClass = modules[i].getClass().getName();
                            v = new ArrayList();
                            for (int j = 0; j < pa.text.length; j++) {
                                if (pa.textName[j].indexOf(""File"") >= 0) {
                                    v.add(new Integer(j));
                                }
                            }
                            bObj.modObj.modParam = new String[v.size()][2];
                            for (int j = 0; j < v.size(); j++) {
                                bObj.modObj.modParam[j][0] = pa.textName[j];
                                bObj.modObj.modParam[j][1] = pa.text[j];
                            }
                            batchTM.fireTableRowsUpdated(k, k);
                            updateParamTable();
                        }
                    }
                } else if (e.getSource() == paramTM) {
                }
            }
        };
        con.fill = GridBagConstraints.BOTH;
        con.gridwidth = GridBagConstraints.REMAINDER;
        gui.addLabel(new GroupLabel(""Batch List"", GroupLabel.ORIENT_HORIZONTAL, GroupLabel.BRACE_NONE));
        con.gridwidth = GridBagConstraints.REMAINDER;
        con.weightx = 1.0;
        con.weighty = 1.0;
        initBatchTable();
        gui.registerGadget(batchTable, GG_BATCH);
        ggBatchPane = new JScrollPane(batchTable);
        gui.addGadget(ggBatchPane, GG_BATCHPANE);
        con.fill = GridBagConstraints.HORIZONTAL;
        con.gridwidth = 1;
        con.weightx = 0.05;
        con.weighty = 0.0;
        final JToolBar tb = new JToolBar();
        tb.setBorderPainted(false);
        tb.setFloatable(false);
        ggCmd = new JButton("" Add "");
        gui.registerGadget(ggCmd, GG_CMDADD);
        tb.add(ggCmd);
        ggCmd.addActionListener(al);
        ggCmd = new JButton("" Cut "");
        gui.registerGadget(ggCmd, GG_CMDCUT);
        tb.add(ggCmd);
        ggCmd.addActionListener(al);
        ggCmd = new JButton("" Copy "");
        gui.registerGadget(ggCmd, GG_CMDCOPY);
        tb.add(ggCmd);
        ggCmd.addActionListener(al);
        ggCmd = new JButton("" Paste "");
        gui.registerGadget(ggCmd, GG_CMDPASTE);
        tb.add(ggCmd);
        ggCmd.addActionListener(al);
        ggCmd = new JButton("" Open "");
        gui.registerGadget(ggCmd, GG_CMDOPEN);
        tb.add(ggCmd);
        ggCmd.addActionListener(al);
        con.gridwidth = GridBagConstraints.REMAINDER;
        gui.addGadget(tb, GG_OFF_OTHER + 666);
        con.fill = GridBagConstraints.BOTH;
        con.gridwidth = GridBagConstraints.REMAINDER;
        gui.addLabel(new GroupLabel(""Module Parameter Settings"", GroupLabel.ORIENT_HORIZONTAL, GroupLabel.BRACE_NONE));
        con.gridwidth = GridBagConstraints.REMAINDER;
        con.weightx = 1.0;
        con.weighty = 0.3;
        initParamTable();
        gui.registerGadget(paramTable, GG_PARAMS);
        ggParamPane = new JScrollPane(paramTable);
        gui.addGadget(ggParamPane, GG_PARAMSPANE);
        con.weighty = 0.0;
        con.fill = GridBagConstraints.BOTH;
        con.gridwidth = GridBagConstraints.REMAINDER;
        gui.addLabel(new GroupLabel(""Control Settings"", GroupLabel.ORIENT_HORIZONTAL, GroupLabel.BRACE_NONE));
        con.fill = GridBagConstraints.HORIZONTAL;
        con.gridwidth = 1;
        ggVisible = new JCheckBox(""Visible modules"");
        gui.addCheckbox(ggVisible, GG_VISIBLE, null);
        con.gridwidth = GridBagConstraints.REMAINDER;
        ggConsole = new JCheckBox(""Console output"");
        gui.addCheckbox(ggConsole, GG_CONSOLE, null);
        setPreferredSize(new Dimension(500, 600));
        initGUI(this, FLAGS_PRESETS | FLAGS_PROGBAR | FLAGS_PROGBARASYNC, gui);
    }
",1
292293,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
40613,7,"    public boolean delete(long value) {
        int j;
        for (j = 0; j < nElems; j++) if (value == a[j]) break;
        if (j == nElems) return false; else {
            for (int k = j; k < nElems; k++) a[k] = a[k + 1];
            nElems--;
            return true;
        }
    }
",1
19135765,7,"    void executeCommand(String[] cmd) {
        boolean result;
        CommandHandler handler;
        if (cmd[0].equals(helpCommand)) {
            if (cmd.length == 1) printAvailableCommands(); else {
                for (int i = 0; i < handlers.size(); i++) {
                    handler = (CommandHandler) handlers.elementAt(i);
                    if (handler.getCommandName().equals(cmd[1])) {
                        handler.printCommandHelp(System.out, CommandHandler.longHelp);
                    }
                }
            }
            return;
        }
        for (int i = 0; i < handlers.size(); i++) {
            handler = (CommandHandler) handlers.elementAt(i);
            if (handler.getCommandName().equals(cmd[0])) {
                String[] cmdArgs = new String[cmd.length - 1];
                for (int j = 0; j < cmdArgs.length; j++) cmdArgs[j] = cmd[j + 1];
                try {
                    System.out.println();
                    result = handler.processCommand(cmdArgs, orb, System.out);
                    if (result == CommandHandler.parseError) {
                        handler.printCommandHelp(System.out, CommandHandler.longHelp);
                    }
                    System.out.println();
                } catch (Exception ex) {
                }
                return;
            }
        }
        printAvailableCommands();
    }
",0
5533635,7,"    public void setPermutationNumber(BigInteger Number) {
        if (fak == null) {
            fak = new BigInteger[N];
            fak[N - 1] = BigInteger.ONE;
            for (int i = N - 2; i >= 0; i--) fak[i] = fak[i + 1].multiply(new BigInteger(N - i - 1 + """"));
        }
        Number = Number.mod(fakultaet(N));
        for (int i = 0; i < N; i++) Al[i] = i;
        if (Number.equals(BigInteger.ZERO)) return;
        for (int i = 0; i < N - 1; i++) {
            BigInteger[] bi = Number.divideAndRemainder(fak[i]);
            int j = bi[0].intValue();
            if (j != 0) {
                int m = Al[i + j];
                for (; j > 0; j--) Al[i + j] = Al[i + j - 1];
                Al[i] = m;
                Number = bi[1];
            }
        }
    }
",1
5131727,7,"    public void reorderTable(int[] t, int[] dest) {
        final int a = t[0], b = t[1], c = t[2], d = t[3], e = t[4], f = t[5];
        final int c1 = a + d, c2 = b + e, c3 = c + f;
        final int n1 = a + b + c, n2 = d + e + f;
        for (int i = 0; i < t.length; i++) {
            dest[i] = t[i];
        }
        int cmin = Math.min(c1, Math.min(c2, c3));
        if (c1 > cmin) {
            int col = c2 > cmin ? 2 : 1;
            dest[0] = t[col];
            dest[3] = t[col + 3];
            dest[col] = t[0];
            dest[col + 3] = t[3];
        }
        if (n1 > n2) {
            int temp;
            for (int i = 0; i < 3; i++) {
                temp = dest[i];
                dest[i] = dest[i + 3];
                dest[i + 3] = temp;
            }
        }
    }
",1
19498173,7,"    static void unpadArray(double[] source, double[] target) {
        for (int i = 0; i < target.length; i++) {
            target[i] = source[i + 1];
        }
    }
",1
4030760,7,"    private final void deleteRoomAt(int index) {
        for (int i = index; i < events_fill_p; i++) events[i] = events[i + 1];
        events_fill_p--;
    }
",1
15050484,7,"    private int[] doAbsorbingRandowWalk(final Matrix mP, int highest) {
        final int size = mP.numRows();
        final int[] ranking = new int[size];
        ranking[0] = highest;
        final int[] map = new int[size];
        for (int i = 0; i < highest; ++i) map[i] = i;
        for (int i = highest; i < size - 1; ++i) map[i] = i + 1;
        for (int absorbed = 1; absorbed < size; ++absorbed) {
            System.out.println(""absorbed "" + absorbed);
            final int sizeOfQ = size - absorbed;
            final Matrix mIminusQ = new DenseMatrix(sizeOfQ, sizeOfQ);
            for (int i = 0; i < sizeOfQ; ++i) for (int j = 0; j < sizeOfQ; ++j) mIminusQ.set(i, j, (i == j ? 1.0 : 0.0) - mP.get(map[i], map[j]));
            final Matrix mI = Matrices.identity(sizeOfQ);
            final Matrix mN = mI.copy();
            mIminusQ.solve(mI, mN);
            final Vector v = new DenseVector(sizeOfQ);
            for (int i = 0; i < sizeOfQ; ++i) {
                for (int j = 0; j < sizeOfQ; ++j) v.add(i, mN.get(i, j));
                v.set(i, v.get(i) / sizeOfQ);
            }
            highest = findHighestRanked(v);
            ranking[absorbed] = map[highest];
            for (int i = highest; i < size - 1; ++i) map[i] = map[i + 1];
        }
        return ranking;
    }
",1
1874798,7,"    private edu.cmu.sphinx.decoder.linguist.SentenceHMMState expandPronunciation(edu.cmu.sphinx.decoder.linguist.PronunciationState state) {
        Pronunciation pronunciation = state.getPronunciation();
        Unit[] units = pronunciation.getUnits();
        edu.cmu.sphinx.decoder.linguist.SentenceHMMState combineState = new CombineState(state.getParent(), state.getWhich());
        combineState.setColor(Color.RED);
        for (int a = 0; a < acousticModels.length; a++) {
            AcousticModel model = acousticModels[a];
            edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = state;
            for (int i = 0; i < units.length; i++) {
                ParallelUnitState unitState = null;
                if (i == 0 || i == (units.length - 1)) {
                    unitState = new ParallelUnitState(state, model.getName(), i, units[i], tokenStackCapacity);
                } else {
                    Unit[] leftContext = new Unit[1];
                    Unit[] rightContext = new Unit[1];
                    leftContext[0] = units[i - 1];
                    rightContext[0] = units[i + 1];
                    Context context = LeftRightContext.get(leftContext, rightContext);
                    Unit unit = new Unit(units[i].getName(), units[i].isFiller(), context);
                    unitState = new ParallelUnitState(state, model.getName(), i, unit, tokenStackCapacity);
                }
                unitState.setColor(Color.GREEN);
                attachState(lastState, unitState, logMath.getLogOne(), logMath.getLogOne(), unitInsertionProbability);
                lastState = expandUnit(unitState, model);
                if (unitState.getUnit().isSilence()) {
                    attachState(lastState, unitState, logMath.getLogOne(), logMath.getLogOne(), logMath.getLogOne());
                }
            }
            Unit lastUnit = units[units.length - 1];
            if (addSelfLoopWordEndSilence && !lastUnit.isSilence()) {
                addLoopSilence(lastState, state, model);
            }
            attachState(lastState, combineState, logMath.getLogOne(), logMath.getLogOne(), logMath.getLogOne());
        }
        return combineState;
    }
",1
4030782,7,"    public void moveEvent(ScrEvent event, int newTime) {
        int index = indexOf(event);
        int newIndex = getIndexAfter(newTime);
        if (newIndex == NO_SUCH_EVENT) newIndex = events_fill_p - 1; else if (event.getTime() <= newTime) newIndex -= 1;
        if (index == NO_SUCH_EVENT) {
            System.err.println(""no such event error"");
            for (int i = 0; i < length(); i++) {
                System.err.println(""#"" + i + "" t "" + getEventAt(i).getTime() + "" p "" + getEventAt(i).getPitch());
            }
            return;
        }
        if (index == EMPTY_COLLECTION) index = 0;
        event.setTime(newTime);
        Object args[] = new Object[6];
        args[0] = new Integer(index);
        args[1] = new Integer(event.getTime());
        args[2] = new Integer(event.getPitch());
        args[3] = new Integer(event.getVelocity());
        args[4] = new Integer(event.getDuration());
        args[5] = new Integer(event.getChannel());
        remoteCall(REMOTE_CHANGE, args);
        if (index < newIndex) {
            for (int i = index; i < newIndex; i++) {
                events[i] = events[i + 1];
            }
        } else {
            for (int i = index; i > newIndex; i--) {
                events[i] = events[i - 1];
            }
            events[newIndex] = event;
        }
        events[newIndex] = event;
        notifyObjectMoved(event, index, newIndex);
    }
",1
22066209,7,"    private static int[] removeDuplicates(int[] a) {
        int[] tmp = new int[a.length];
        int count = 0;
        tmp[count] = a[count];
        for (int i = 0; i < a.length - 1; i++) {
            if (tmp[count] != a[i + 1]) {
                count++;
                tmp[count] = a[i + 1];
            }
        }
        count++;
        int[] tmp2 = new int[count];
        for (int i = 0; i < tmp2.length; i++) {
            tmp2[i] = tmp[i];
        }
        return tmp2;
    }
",1
19687988,7,"    public BsplineKnotVector reverse() {
        if (knotSpec != KnotType.UNSPECIFIED) {
            return this;
        }
        int n_kel = nKnotValues();
        int[] new_multi = new int[n_kel];
        double[] new_knots = new double[n_kel];
        int i, j;
        new_multi[degree] = 1;
        new_knots[degree] = 0.0;
        int lk_idx = degree + nSegments();
        for (i = degree - 1, j = lk_idx; i >= 0; i--, j++) {
            new_knots[i] = new_knots[i + 1] - (knotValueAt(j + 1) - knotValueAt(j));
            new_multi[i] = 1;
        }
        for (i = degree + 1, j = lk_idx; i < n_kel; i++, j--) {
            new_knots[i] = new_knots[i - 1] + (knotValueAt(j) - knotValueAt(j - 1));
            new_multi[i] = 1;
        }
        return new BsplineKnotVector(degree, knotSpec, periodic, new_multi, new_knots, nControlPoints).beautify();
    }
",1
20647931,7,"    private static void rotate(byte[] key) {
        byte[] x = new byte[64];
        System.arraycopy(key, 0, x, 0, x.length);
        for (int i = 0; i < 55; i++) {
            x[i] = x[i + 1];
        }
        x[27] = key[0];
        x[55] = key[28];
        System.arraycopy(x, 0, key, 0, key.length);
    }
",1
1611680,7,"    public static String[] subArgs(String[] args) {
        String[] ret = new String[args.length - 1];
        for (int i = 0; i < ret.length; ++i) {
            ret[i] = args[i + 1];
        }
        return ret;
    }
",1
862981,7,"    public void usunElement(int nr) {
        boolean zmien = false;
        for (int i = 0; i < inArt; i++) {
            if (i == nr) {
                zmien = true;
            }
            if (zmien) {
                art[i] = art[i + 1];
            }
        }
        if (zmien) {
            inArt--;
        }
    }
",1
3937543,7,"        public void run() {
            if (waitscreen != null) {
                int increment = 0;
                int progress = 0;
                increment = (20 / services.length) % 10;
                waitscreen.setPercent(0);
                Service services_new[] = new Service[services.length];
                if (pos1 == -1) {
                    for (int i = 0; i < services.length - 1; i++) {
                        services_new[i] = services[i + 1];
                        progress += increment;
                        waitscreen.setPercent(progress);
                        Thread.yield();
                    }
                    services_new[services.length - 1] = services[0];
                } else if (pos2 == -1) {
                    for (int i = 1; i < services.length; i++) {
                        services_new[i] = services[i - 1];
                        progress += increment;
                        waitscreen.setPercent(progress);
                        Thread.yield();
                    }
                    services_new[0] = services[services.length - 1];
                } else {
                    for (int i = 0; i < services.length; i++) {
                        services_new[i] = services[i];
                        if (i == pos1) {
                            services_new[i] = services[pos2];
                        } else if (i == pos2) {
                            services_new[i] = services[pos1];
                        }
                        progress += increment;
                        waitscreen.setPercent(progress);
                        Thread.yield();
                    }
                }
                formatServices();
                for (int i = (services_new.length - 1); i >= 0; i--) {
                    Service.insService(services_new[i].getString());
                    progress += (increment * 4);
                    waitscreen.setPercent(progress);
                    Thread.yield();
                }
                waitscreen.setPercent(Utils.WaitProgressScreen.PERCENT_MAX);
            }
        }
",1
13543086,7,"    private void dfsProcess(char[] str, int l, int r, Vector<String> vs) {
        String[] value = this.verbAbbrMap.get(String.copyValueOf(str, l, r - l + 1).toLowerCase());
        if (value != null) {
            for (int i = 0; i < value.length; i++) {
                if (value[i].length() > 0) vs.add(value[i]);
            }
            return;
        }
        int id = l;
        while (true) {
            while (id <= r && !isMark[str[id]]) id++;
            if (id > r) {
                break;
            }
            if (!isMark[str[id + 1]]) {
                id++;
                continue;
            }
            dfsProcess(str, l, id - 1, vs);
            while (isMark[str[id]]) id++;
            l = id;
        }
        for (int i = r - 1; i > l; i--) {
            if (str[i] != '.' && str[i] != ',') continue;
            if (Character.isDigit(str[i - 1]) && Character.isDigit(str[i + 1])) {
                for (int j = i; j < r; j++) str[j] = str[j + 1];
                r--;
            }
        }
        int len = r - l + 1;
        while (len > 2 && (str[r - 1] == '\'' || str[r - 1] == '""') && (str[r] == 's' || str[r] == 'S' || str[r] == 't' || str[r] == 'd')) {
            r -= 2;
            len -= 2;
        }
        while (len > 3 && (str[r - 2] == '\'' || str[r - 2] == '""') && str[r - 1] == 'l' && str[r] == 'l') {
            r -= 3;
            len -= 3;
        }
        int letterOrDigitRequired = 3;
        id = l + 1;
        while (true) {
            for (; id < r && str[id] != '-'; id++) ;
            if (id >= r) break;
            int isLetter = 2;
            for (int i = id - 1; i >= id - letterOrDigitRequired; i--) {
                if (i < l || !Character.isLetterOrDigit(str[i])) {
                    isLetter--;
                    break;
                }
            }
            for (int i = id + 1; i <= id + letterOrDigitRequired; i++) {
                if (i > r || !Character.isLetterOrDigit(str[i])) {
                    isLetter--;
                    break;
                }
            }
            if (isLetter > 0) {
                dfsProcess(str, l, id - 1, vs);
                l = id + 1;
            }
            id += 1;
        }
        letterOrDigitRequired = 3;
        id = l + 1;
        while (true) {
            for (; id < r && str[id] != '.' && str[id] != ':' && str[id] != '\''; id++) ;
            if (id >= r) break;
            boolean isLetter = true;
            for (int i = id - 1; i >= id - letterOrDigitRequired; i--) {
                if (i < l || !Character.isLetterOrDigit(str[i])) {
                    isLetter = false;
                    break;
                }
            }
            for (int i = id + 1; i <= id + letterOrDigitRequired; i++) {
                if (i > r || !Character.isLetterOrDigit(str[i])) {
                    isLetter = false;
                    break;
                }
            }
            if (isLetter) {
                dfsProcess(str, l, id - 1, vs);
                l = id + 1;
            }
            id += 1;
        }
        if (this.timeToConst) {
            if (r - l + 1 == 5) {
                if (str[l + 2] == ':' && Character.isDigit(str[l]) && Character.isDigit(str[l + 1]) && Character.isDigit(str[l + 3]) && Character.isDigit(str[l + 4])) {
                    boolean valid = true;
                    if (str[l] > '2') valid = false;
                    if (str[l] == '2' && str[l + 1] > '4') valid = false;
                    if (str[l + 3] > '5') valid = false;
                    if (valid) {
                        vs.add(Constant.TIME_FEATURE);
                        return;
                    }
                }
            }
        }
        len = r - l + 1;
        id = l;
        while (true) {
            for (; id <= r && !this.isBadMark[str[id]]; id++) ;
            if (id > r) break;
            if (str[id] == '/' && len <= 4) {
                id++;
                continue;
            }
            dfsProcess(str, l, id - 1, vs);
            id = l = id + 1;
            len = r - l + 1;
        }
        if (this.numToConst) {
            for (id = l; id <= r; id++) {
                if (!Character.isDigit(str[id]) && !this.isMark[str[id]]) break;
            }
            if (id > r) {
                vs.add(Constant.NUMBER_FEATURE);
                return;
            }
        }
        vs.add(String.copyValueOf(str, l, r - l + 1));
    }
",1
13076072,7,"    private static int chopspace(byte[] buf, int len) {
        for (int i = 0; i < len; i++) {
            if ('A' <= buf[i] && buf[i] <= 'Z') {
                buf[i] = (byte) ('a' + buf[i] - 'A');
            } else if (buf[i] == ' ') {
                len--;
                for (int j = i; j < len; j++) {
                    buf[j] = buf[j + 1];
                }
                i--;
            }
        }
        return len;
    }
",1
8112195,7,"    public double[] predict(WordType wordType) {
        if (maxOrder == 1) {
            double[] res = new double[WordType.vocabularySize()];
            double sum = 0;
            for (int i = 0; i < WordType.vocabularySize(); i++) {
                String pred = WordType.values()[i].getOriginalTag();
                res[i] = Math.exp(unigram.get(pred).getProb());
                sum += res[i];
            }
            for (int i = 0; i < WordType.vocabularySize(); i++) {
                res[i] /= sum;
            }
            return res;
        }
        if (history == null) {
            history = new String[maxOrder - 1];
        }
        if (wordType == WordType.PERIOD || wordType == null) {
            history[0] = ""<s>"";
            historyLen = 1;
        } else {
            for (int i = 0; i < historyLen - 1; i++) {
                history[i] = history[i + 1];
            }
            if (historyLen == history.length) {
                history[historyLen - 1] = wordType.getOriginalTag();
            } else {
                history[historyLen] = wordType.getOriginalTag();
                historyLen++;
            }
        }
        double[] res = predictAll(history, historyLen);
        return res;
    }
",1
19204899,7,"    public final void removeElementAt(int id) {
        if (id >= 0) {
            for (int i = id; i < current_item - 1; i++) items[i] = items[i + 1];
            items[current_item - 1] = 0;
        } else items[0] = 0;
        current_item--;
    }
",1
8325797,7,"    public int refreshStateAtTurnEnd() {
        int deadGeneralId = 0;
        for (int i = 0; i < len; i++) {
            if (soldiers[i].getNum() <= 0) {
                logger.info(""ɾ������"" + soldiers[i]);
                if (soldiers[i].getType() == SoldierType.WU) {
                    deadGeneralId = soldiers[i].getGeneralId();
                }
                if (soldiers[i].getId() == firstSoldierId) {
                    if (i < len - 1) {
                        firstSoldierId = soldiers[i + 1].getId();
                    } else {
                        firstSoldierId = soldiers[0].getId();
                    }
                }
                for (int j = i; j < len - 1; j++) {
                    soldiers[j] = soldiers[j + 1];
                }
                len--;
            }
        }
        if (soldiers[0].getMove() <= 0) {
            soldiers[0].setAction(SoldierAction.STOP);
            circle();
        }
        return deadGeneralId;
    }
",1
744373,7,"    String[] deleteFirst(String[] a) {
        assert a.length > 0;
        String[] b = new String[a.length - 1];
        for (int i = 0; i < b.length; i++) b[i] = a[i + 1];
        return b;
    }
",1
22314779,7,"    void scrValid() {
        if (xloc >= columns) if (wrap) {
            xloc = 0;
            yloc++;
        } else xloc = columns - 1;
        if (yloc >= lines) {
            for (int j = 0; j < lines - 1; j++) {
                screen[j] = screen[j + 1];
                screenfg[j] = screenfg[j + 1];
                screenbg[j] = screenbg[j + 1];
                lineRedraw[j] = true;
            }
            screen[lines - 1] = new char[columns];
            screenfg[lines - 1] = new Color[columns];
            screenbg[lines - 1] = new Color[columns];
            for (int j = 0; j < columns; j++) {
                screen[lines - 1][j] = ' ';
                screenfg[lines - 1][j] = fgcolor;
                screenbg[lines - 1][j] = bgcolor;
            }
            lineRedraw[lines - 1] = true;
            yloc--;
        }
    }
",1
5629980,7,"    private void processGetContext(final String[] part) {
        if (part.length < GET_CONTEXT_PARTS) {
            usage(GET_CONTEXT);
            return;
        }
        int separator;
        for (separator = 1; separator < part.length; separator++) {
            if (part[separator].equals(""/"")) {
                break;
            }
        }
        if (separator == part.length || separator <= 0) {
            usage(GET_CONTEXT);
            return;
        }
        String[] agents = new String[separator - 1];
        String[] contexts = new String[part.length - 1 - separator];
        for (int i = 0; i < agents.length; i++) {
            agents[i] = part[i + 1];
        }
        int offset = separator + 1;
        for (int i = 0; i < contexts.length; i++) {
            contexts[i] = part[i + offset];
        }
        String reply;
        try {
            reply = cp.getContext(agents, contexts);
        } catch (UnknownContextException e) {
            sendError(e.getMessage());
            return;
        } catch (AgentNotFoundException e) {
            sendError(e.getMessage());
            return;
        }
        send(reply);
    }
",1
19914231,7,"    public void removeChild(String name, String value) {
        boolean found = false;
        for (int i = 0; i < values.length; i++) {
            if (!found) {
                if (values[i].getId().equals(name)) {
                    if (values[i].get().equals(value)) {
                        values[i] = null;
                        found = true;
                        numValidChildren--;
                    }
                }
            }
            if (i < (values.length - 1)) values[i] = values[i + 1];
        }
        if (found) values[values.length - 1] = null;
    }
",1
23357894,7,"    private CommandLine parseCommandLine(TclObject argv[]) throws ParseException {
        String[] args = new String[argv.length - 1];
        for (int i = 0; i < argv.length - 1; i++) args[i] = argv[i + 1].toString();
        CommandLine cl = (new PosixParser()).parse(this.opts, args);
        return cl;
    }
",0
17617955,7,"    public Object call(Object[] args) throws Throwable {
        final Object[] nargs = new Object[args.length - 1];
        for (int i = 0; i < nargs.length; i++) {
            nargs[i] = args[i + 1];
        }
        try {
            return mtd.getMethod().invoke(args[0], nargs);
        } catch (java.lang.reflect.InvocationTargetException e) {
            throw Utils.wrapInvocationException(e);
        }
    }
",1
950505,7,"    void deletePFrame() {
        if (npframes > 1) {
            for (int i = upba.currentFrameIndex; i < npframes - 1; i++) {
                pframes[i] = pframes[i + 1];
            }
            pframes[npframes - 1] = null;
            if (upba.currentFrameIndex > 0) {
                upba.currentFrameIndex--;
            }
            npframes--;
            this.resethist();
        }
    }
",1
14427372,7,"    public static Map mapGames(Set sessions, String method) {
        Map retMap = new TreeMap();
        try {
            String[] elements = method.split(""~"");
            String strMethod = elements[0];
            String[] params = new String[elements.length - 1];
            Class[] cArr = new Class[params.length];
            for (int i = 0; i < params.length; i++) {
                params[i] = elements[i + 1];
                cArr[i] = String.class;
            }
            java.lang.reflect.Method meth = Game.class.getMethod(strMethod, cArr);
            Iterator sIt = sessions.iterator();
            while (sIt.hasNext()) {
                Iterator gIt = ((Session) sIt.next()).getGames().iterator();
                while (gIt.hasNext()) {
                    Game tempGame = (Game) gIt.next();
                    Object key = meth.invoke(tempGame, params);
                    Set gameList = new TreeSet();
                    if (retMap.containsKey(key)) gameList = (Set) retMap.get(key);
                    gameList.add(tempGame);
                    retMap.put(key, gameList);
                }
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            System.exit(1);
        } catch (InvocationTargetException e) {
            e.printStackTrace();
            System.exit(1);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
            System.exit(1);
        }
        return retMap;
    }
",1
19628228,7,"    public static Object newMsg(Object[] _p) {
        FooLib.checkClassArgument(Class.class, _p[0], 0);
        Class c = (Class) _p[0];
        Constructor m = FooLib.getConstructor(c, c.getName(), _p.length - 1);
        Object[] q = new Object[_p.length - 1];
        for (int i = 0; i < q.length; i++) q[i] = _p[i + 1];
        return FooLib.invokeConstructor(m, q);
    }
",1
21687170,7,"    protected final void spline(int n, double[] x, double[] y, double[] b, double[] c, double[] d) {
        if (n < 3) {
            b[0] = 0;
            if (n == 2) b[0] = (y[1] - y[0]) / (x[1] - x[0]);
            c[0] = 0;
            d[0] = 0;
            b[1] = b[0];
            c[1] = 0;
            d[1] = 0;
            return;
        }
        d[0] = x[1] - x[0];
        c[1] = (y[1] - y[0]) / d[0];
        for (int i = 1; i < n - 1; ++i) {
            d[i] = x[i + 1] - x[i];
            b[i] = 2.0 * (d[i - 1] + d[i]);
            c[i + 1] = (y[i + 1] - y[i]) / d[i];
            c[i] = c[i + 1] - c[i];
        }
        b[0] = -d[0];
        b[n - 1] = -d[n - 2];
        c[0] = 0.0;
        c[n - 1] = 0.0;
        if (n > 3) {
            c[0] = c[2] / (x[3] - x[1]) - c[1] / (x[2] - x[0]);
            c[n - 1] = c[n - 2] / (x[n - 1] - x[n - 3]) - c[n - 3] / (x[n - 2] - x[n - 4]);
            c[0] = c[0] * d[0] * d[0] / (x[3] - x[0]);
            c[n - 1] = -c[n - 1] * d[n - 2] * d[n - 2] / (x[n - 1] - x[n - 4]);
        }
        for (int i = 1; i < n; ++i) {
            double t = d[i - 1] / b[i - 1];
            b[i] = b[i] - t * d[i - 1];
            c[i] = c[i] - t * c[i - 1];
        }
        c[n - 1] = c[n - 1] / b[n - 1];
        for (int i = n - 2; i >= 0; --i) {
            c[i] = (c[i] - d[i] * c[i + 1]) / b[i];
        }
        b[n - 1] = (y[n - 1] - y[n - 2]) / d[n - 2] + d[n - 2] * (c[n - 2] + c[n - 1] + c[n - 1]);
        for (int i = 0; i < n - 1; ++i) {
            b[i] = (y[i + 1] - y[i]) / d[i] - d[i] * (c[i + 1] + c[i] + c[i]);
            d[i] = (c[i + 1] - c[i]) / d[i];
            c[i] = 3.0 * c[i];
        }
        c[n - 1] = 3.0 * c[n - 1];
        d[n - 1] = d[n - 2];
    }
",1
1807394,7,"        public void perform(Argument args[], Context context) throws ExtensionException, LogoException {
            try {
                String rname = args[0].getString();
                Object[] input = new Object[args.length - 1];
                LinkedHashMap<String, Object> hm = new LinkedHashMap<String, Object>();
                hm.put(rname, null);
                hm.put(""putnamedvector"", null);
                for (int i = 0; i < args.length - 1; i++) {
                    String varname = ((Integer) i).toString();
                    input[i] = args[i + 1].get();
                    hm.put(varname, input[i]);
                }
                rConn.storeObject(hm);
            } catch (Exception ex) {
                throw new ExtensionException(""Error in PutVector: \n"" + ex);
            }
        }
",1
6760292,7,"    public int removePlayer(Player pl) {
        if (pl == null || num_players == 0 || num_filled == 0) {
            System.out.println(""ERROR: null player or no players in BattleGame.removePlayer"");
            return BG_STATUS_NOADD;
        }
        int idx = getPlayerIndex(pl.getPlayerID());
        if (idx >= 0 && idx < num_filled) {
            for (int i = idx; i < (num_filled - 1); i++) {
                players[i] = players[i + 1];
            }
            players[num_filled - 1] = null;
            num_filled--;
        }
        status = BG_STATUS_AWAIT;
        return status;
    }
",1
4291508,7,"        public Address hash(K key, List<Address> members) {
            int hash = Math.abs(key.hashCode());
            int index = hash % HASH_SPACE;
            if (members != null && !members.isEmpty()) {
                Object[] tmp = new Object[nodes.length];
                System.arraycopy(nodes, 0, tmp, 0, nodes.length);
                for (int i = 0; i < tmp.length; i += 2) {
                    if (!members.contains(tmp[i + 1])) {
                        tmp[i] = tmp[i + 1] = null;
                    }
                }
                return findFirst(tmp, index);
            }
            return findFirst(nodes, index);
        }
",1
14543929,7,"    private void incrementalSortGameObjectsOnXPosition() {
        GameObject tempGameObject;
        for (int i = 0; i < size - 1; i++) {
            if (gameObjects[i].x - gameObjects[i].boundingDimension / 2 > gameObjects[i + 1].x - gameObjects[i + 1].boundingDimension / 2) {
                tempGameObject = gameObjects[i];
                gameObjects[i] = gameObjects[i + 1];
                gameObjects[i + 1] = tempGameObject;
                int j = i;
                while (j > 0 && gameObjects[j].x - gameObjects[j].boundingDimension / 2 < gameObjects[j - 1].x - gameObjects[j - 1].boundingDimension / 2) {
                    tempGameObject = gameObjects[j];
                    gameObjects[j] = gameObjects[j - 1];
                    gameObjects[j - 1] = tempGameObject;
                    j--;
                }
                j = i + 1;
                while (j < size - 1 && gameObjects[j].x - gameObjects[j].boundingDimension / 2 > gameObjects[j + 1].x - gameObjects[j + 1].boundingDimension / 2) {
                    tempGameObject = gameObjects[j];
                    gameObjects[j] = gameObjects[j + 1];
                    gameObjects[j + 1] = tempGameObject;
                    j++;
                }
            }
        }
    }
",1
430591,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
",1
15142980,7,"    public void removePoint() {
        Integer index = datapanel.getPointChosenIndex();
        if (index != null) {
            int newsize = sdata.length - 1;
            int iindex = index.intValue();
            double[] oldsdata = sdata;
            double[] olddata = data;
            double[] tempsdata = new double[newsize];
            double[] tempdata = new double[newsize];
            for (int i = 0; i < newsize; i++) {
                if (i < iindex) {
                    tempsdata[i] = oldsdata[i];
                    tempdata[i] = olddata[i];
                } else {
                    tempsdata[i] = oldsdata[i + 1];
                    tempdata[i] = olddata[i + 1];
                }
            }
            sdata = tempsdata;
            data = tempdata;
            plotData();
        }
    }
",0
12247511,7,"    private static String[] parsePattern(final String[] args, final String... commands) {
        final int ptnlen = commands.length;
        final String[] result = new String[ptnlen];
        int ri = 0;
        final int arglen = args.length;
        for (int i = COMMAND.length; i + 1 < arglen; i += 2) {
            final String s = args[i];
            final int pi = ArrayUtils.indexOf(commands, s, ri);
            if (pi == ArrayUtils.INDEX_NOT_FOUND) {
                continue;
            }
            result[pi] = args[i + 1];
            ri = pi + 1;
            if (ri >= ptnlen) {
                break;
            }
        }
        return result;
    }
",1
5248996,7,"    public void removeReaction(int pos) {
        reactions[pos].removeListener(this);
        for (int i = pos; i < reactionCount - 1; i++) {
            reactions[i] = reactions[i + 1];
        }
        reactions[reactionCount - 1] = null;
        reactionCount--;
        notifyChanged();
    }
",1
2168570,7,"    public void remove() {
        if (position <= 0) {
            throw new IllegalStateException(""You can't remove an item until you've done at least one next()"");
        }
        if (list[position - 1] != null) {
            for (int i = position - 1; i < (list.length - 1); i++) {
                list[i] = list[i + 1];
            }
            list[list.length - 1] = null;
        }
    }
",0
22486859,7,"    public int demote(Move move, int num) {
        if (num < 0) throw new IllegalArgumentException(""cannot perform negative demotion"");
        Move tmp = null;
        int newIndex = 0;
        int oldIndex = getIndex(move);
        if (oldIndex == -1) throw new NullPointerException(""Move is not a current variation""); else move = branches[oldIndex];
        if (num != 0) newIndex = oldIndex + num; else newIndex = branches.length - 1;
        if (newIndex >= branches.length) throw new ArrayIndexOutOfBoundsException(""Move cannot be demoted beyond the end of the list"");
        for (int i = oldIndex; i < newIndex; i++) {
            branches[i] = branches[i + 1];
        }
        branches[newIndex] = move;
        return newIndex;
    }
",1
23622497,7,"    public static void main(String argv[]) throws IOException {
        int i = 0;
        while (i < argv.length) {
            if (argv[i].equals(""-dbg"")) {
                i++;
                debugger.debugClass(argv[i], true);
            } else break;
            i++;
        }
        Mediaserver[] servs = Synch.getMediaservers(argv, i);
        if (servs.length < 1) {
            pa(""Please supply a Mediaserver data pool directory containing"" + ""client space."");
            System.exit(1);
        } else if (servs.length == 1) {
            ms = servs[0];
        } else {
            Mediaserver first = servs[0];
            Mediaserver[] other = new Mediaserver[servs.length - 1];
            for (int j = 0; j < other.length; j++) other[j] = servs[j + 1];
            ms = new MultiplexingMediaserver(first, null, other);
        }
        Mediaserver.Id spaceId = getPointer();
        pa(""Starting with space\n"" + spaceId.getString());
        space = new PermanentSpace(ms, spaceId);
        clientCell = space.getHomeCell().s(d1);
        if (clientCell == null) {
            pa(""No client cell in space"");
            System.exit(1);
        }
        client.start();
    }
",1
18921061,7,"    protected static void zRoots(float[] coeffBuf, int coeffNum, float[] roots, boolean polish) {
        int i, j, jj;
        float bRe, bIm, cRe, cIm;
        int coeffNum2 = coeffNum << 1;
        float[] ad = new float[coeffNum2 + 2];
        float[] x = new float[2];
        System.arraycopy(coeffBuf, 0, ad, 0, coeffNum2 + 2);
        for (j = coeffNum2; j >= 2; j -= 2) {
            jj = j - 2;
            x[0] = 0.0f;
            x[1] = 0.0f;
            i = laguerre(ad, j >> 1, x);
            if (Math.abs(x[1]) <= EXPECTEDERROR2 * Math.abs(x[0])) {
                x[1] = 0.0f;
            }
            roots[jj] = x[0];
            roots[jj + 1] = x[1];
            bRe = ad[j];
            bIm = ad[j + 1];
            for (; jj >= 0; jj -= 2) {
                cRe = ad[jj];
                cIm = ad[jj + 1];
                ad[jj] = bRe;
                ad[jj + 1] = bIm;
                bRe = x[0] * bRe - x[1] * bIm + cRe;
                bIm = x[1] * bRe + x[0] * bIm + cIm;
            }
        }
        if (polish) {
            for (j = 0; j < coeffNum2; ) {
                x[0] = roots[j];
                x[1] = roots[j + 1];
                laguerre(coeffBuf, coeffNum, x);
                roots[j++] = x[0];
                roots[j++] = x[1];
            }
        }
        for (j = 2; j < coeffNum2; j += 2) {
            x[0] = roots[j];
            x[1] = roots[j + 1];
            for (i = j - 2; i >= 2; i -= 2) {
                if (roots[i] <= x[0]) break;
                roots[i + 2] = roots[i];
                roots[i + 3] = roots[i + 1];
            }
            roots[i + 2] = x[0];
            roots[i + 3] = x[1];
        }
    }
",0
15246531,7,"    public static void main(String[] args) {
        int nmcnt = 0;
        int mmcnt = 0;
        int umcnt = 0;
        int qccnt = 0;
        int total = 0;
        int[] lenHisto = new int[100];
        if (args.length < 2) {
            System.out.println(""usage: <output file name> <eland files>"");
            System.exit(0);
        }
        String outName = args[0];
        String[] files = new String[args.length - 1];
        for (int i = 0; i < files.length; i++) {
            files[i] = args[i + 1];
        }
        System.out.println(""Working with:"");
        for (String s : files) System.out.println(s);
        int[] lengths = null;
        lengths = getLengths(files);
        BufferedReader[] elands = new BufferedReader[files.length];
        String[] lines = new String[files.length];
        String um_f = outName + "".um.eland"";
        String nm_f = outName + "".nm.eland"";
        String mm_f = outName + "".mm.eland"";
        String qc_f = outName + "".qc.eland"";
        String sum_f = outName + "".summary"";
        System.out.println(""Writing to:\n"" + um_f + ""\n"" + nm_f + ""\n"" + mm_f + ""\n"" + qc_f + ""\n"" + sum_f);
        FileWriter um = null;
        FileWriter nm = null;
        FileWriter mm = null;
        FileWriter qc = null;
        FileWriter sum = null;
        try {
            um = new FileWriter(um_f);
            nm = new FileWriter(nm_f);
            mm = new FileWriter(mm_f);
            qc = new FileWriter(qc_f);
            sum = new FileWriter(sum_f);
        } catch (IOException io) {
            System.out.println(""Can't create files.  Exiting"");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
            System.exit(0);
        }
        assert (um != null);
        assert (nm != null);
        assert (mm != null);
        assert (qc != null);
        assert (sum != null);
        for (int i = 0; i < elands.length; i++) {
            try {
                elands[i] = new BufferedReader(new FileReader(files[i]));
            } catch (FileNotFoundException FNF) {
                System.out.println(""Could not open a file provided: "" + files[i]);
            }
        }
        try {
            while (elands[0].ready()) {
                total++;
                if (total % 10000 == 0) {
                    System.out.print(""."");
                }
                for (int i = 0; i < elands.length; i++) {
                    lines[i] = elands[i].readLine();
                }
                if (!sameRead(lines)) {
                    System.out.println(""reads are not the same!"");
                    write(lines);
                    System.exit(0);
                }
                if (hasQCerror(lines[0])) {
                    qccnt++;
                    qc.write(alnToFasta(lines[lines.length - 1], lengths[lines.length - 1]) + ""\n"");
                    continue;
                }
                if (hasNoMatch(lines[0])) {
                    nm.write(alnToFasta(lines[lines.length - 1], lengths[lines.length - 1]) + ""\n"");
                    nmcnt++;
                    continue;
                }
                boolean umatch = false;
                for (int i = lines.length - 1; i >= 0; i--) {
                    if (hasUniqueMatch(lines[i])) {
                        um.write(lines[i].substring(0, lines[i].indexOf('\t') + 1));
                        String seq = null;
                        seq = getSeq(lines[i], lengths[i]);
                        lenHisto[seq.length()]++;
                        um.write(seq);
                        um.write(lines[i].substring(lines[i].indexOf('\t', lines[i].indexOf(seq) + 1)));
                        um.write(""\n"");
                        umatch = true;
                        umcnt++;
                        break;
                    }
                }
                if (umatch) {
                    continue;
                }
                boolean mmatch = false;
                for (int i = lines.length - 1; i >= 0; i--) {
                    if (hasMultiMatch(lines[i])) {
                        alnToFasta(lines[i], lengths[i]);
                        mm.write(alnToFasta(lines[i], lengths[i]) + ""\n"");
                        mmatch = true;
                        mmcnt++;
                        break;
                    }
                }
                if (!mmatch) {
                    System.out.println(""Error! No matches?!?!"");
                    write(lines);
                }
            }
        } catch (IOException io) {
            System.out.println(""Failure parsing file."");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
        }
        try {
            sum.write(""total\t"" + total + ""\n"");
            sum.write(""unique\t"" + umcnt + ""\n"");
            sum.write(""multi\t"" + mmcnt + ""\n"");
            sum.write(""none\t"" + nmcnt + ""\n"");
            sum.write(""QC\t"" + qccnt + ""\n"");
            for (int i = 0; i < lenHisto.length; i++) {
                if (lenHisto[i] != 0) {
                    sum.write(i + ""\t"" + lenHisto[i] + ""\n"");
                }
            }
        } catch (IOException io) {
            System.out.println(""Failure writing to files."");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
        }
        System.out.printf(""%n||Total reads |%d|%n||Unique Matches |%d|%n||Multimatches |%d|%n||No Match |%d|%n||Poor quality |%d|%n"", total, umcnt, mmcnt, nmcnt, qccnt);
        try {
            um.close();
            nm.close();
            mm.close();
            sum.close();
            qc.close();
        } catch (IOException io) {
            System.out.println(""Failure closing files."");
            System.out.println(""Message thrown by Java environment (may be null):"" + io.getMessage());
        }
    }
",1
6181090,7,"    public Deployer(String[] args) throws Exception {
        defaultConnection = false;
        String database = null;
        String user = null;
        String password = null;
        for (int i = 0; i < args.length; ++i) {
            if (args[i] == null) continue;
            boolean moreArgs = (i + 1 < args.length && !args[i + 1].startsWith(""-""));
            if (args[i].equals(""--database"")) {
                if (moreArgs) database = args[i + 1];
            } else if (args[i].equals(""--user"")) {
                if (moreArgs) user = args[i + 1];
            } else if (args[i].equals(""--password"")) {
                if (moreArgs) password = args[i + 1];
            } else continue;
            if (moreArgs) {
                args[i] = args[i + 1] = null;
                ++i;
            } else throw new Exception(""Missing argument for option "" + args[i]);
        }
        if (database == null) throw new Exception(""Option --database must be present"");
        conn = DriverManager.getConnection(""jdbc:firebirdsql:"" + database, user, password);
        conn.setAutoCommit(false);
    }
",1
18975004,7,"    private static void dualPivotQuicksort(final int[] a, final int low, final int high, final boolean leftmost) {
        final int length = high - low + 1;
        if (length < 32) {
            if (!leftmost) {
                for (int j, i = low + 1; i <= high; i++) {
                    final int ai = a[i];
                    for (j = i - 1; ai < a[j]; j--) {
                        a[j + 1] = a[j];
                    }
                    a[j + 1] = ai;
                }
            } else {
                for (int i = low, j = i; i < high; j = ++i) {
                    final int ai = a[i + 1];
                    while (ai < a[j]) {
                        a[j + 1] = a[j];
                        if (j-- == low) {
                            break;
                        }
                    }
                    a[j + 1] = ai;
                }
            }
            return;
        }
        final int seventh = (length >>> 3) + (length >>> 6) + 1;
        final int e3 = (low + high) >>> 1;
        final int e2 = e3 - seventh;
        final int e1 = e2 - seventh;
        final int e4 = e3 + seventh;
        final int e5 = e4 + seventh;
        if (a[e2] < a[e1]) {
            final int t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }
        if (a[e3] < a[e2]) {
            final int t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (t < a[e1]) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (a[e4] < a[e3]) {
            final int t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (t < a[e2]) {
                a[e3] = a[e2];
                a[e2] = t;
                if (t < a[e1]) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (a[e5] < a[e4]) {
            final int t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (t < a[e3]) {
                a[e4] = a[e3];
                a[e3] = t;
                if (t < a[e2]) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (t < a[e1]) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }
        final int pivot1 = a[e2];
        final int pivot2 = a[e4];
        int less = low;
        int great = high;
        if (pivot1 != pivot2) {
            a[e2] = a[low];
            a[e4] = a[high];
            while (a[++less] < pivot1) ;
            while (a[--great] > pivot2) ;
            outer: for (int k = less; k <= great; k++) {
                final int ak = a[k];
                if (ak < pivot1) {
                    a[k] = a[less];
                    a[less] = ak;
                    less++;
                } else if (ak > pivot2) {
                    while (a[great] > pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less] = a[great];
                        less++;
                    } else {
                        a[k] = a[great];
                    }
                    a[great] = ak;
                    great--;
                }
            }
            a[low] = a[less - 1];
            a[less - 1] = pivot1;
            a[high] = a[great + 1];
            a[great + 1] = pivot2;
            dualPivotQuicksort(a, low, less - 2, leftmost);
            dualPivotQuicksort(a, great + 2, high, false);
            if (less < e1 && e5 < great) {
                while (a[less] == pivot1) {
                    less++;
                }
                while (a[great] == pivot2) {
                    great--;
                }
                outer: for (int k = less; k <= great; k++) {
                    final int ak = a[k];
                    if (ak == pivot1) {
                        a[k] = a[less];
                        a[less] = ak;
                        less++;
                    } else if (ak == pivot2) {
                        while (a[great] == pivot2) {
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] == pivot1) {
                            a[k] = a[less];
                            a[less] = pivot1;
                            less++;
                        } else {
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        great--;
                    }
                }
            }
            dualPivotQuicksort(a, less, great, false);
        } else {
            for (int k = low; k <= great; k++) {
                if (a[k] == pivot1) {
                    continue;
                }
                final int ak = a[k];
                if (ak < pivot1) {
                    a[k] = a[less];
                    a[less] = ak;
                    less++;
                } else {
                    while (a[great] > pivot1) {
                        great--;
                    }
                    if (a[great] < pivot1) {
                        a[k] = a[less];
                        a[less] = a[great];
                        less++;
                    } else {
                        a[k] = pivot1;
                    }
                    a[great] = ak;
                    great--;
                }
            }
            dualPivotQuicksort(a, low, less - 1, leftmost);
            dualPivotQuicksort(a, great + 1, high, false);
        }
    }
",1
13837593,7,"    public Item dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        int random = StdRandom.uniform(N);
        Node n = (Node) array[random];
        Item item = n.item;
        Node prev = n.previous;
        Node next = n.next;
        if (prev == null) {
            if (next == null) {
                first = null;
                last = null;
                N--;
            } else {
                first = next;
                first.previous = null;
                N--;
            }
        } else {
            if (next == null) {
                last = n.previous;
                last.next = null;
                N--;
            } else {
                prev.next = n.next;
                next.previous = prev;
                N--;
            }
        }
        for (int i = random; i < N; i++) {
            array[i] = array[i + 1];
        }
        return item;
    }
",1
2438827,7,"    public int[] getStateSequence(double[][] ob) {
        int l = ob.length;
        int stateCount = stProb.length;
        int[][] top = new int[l][stateCount];
        double[][] d = new double[l][stateCount];
        for (int i = 0; i < stateCount; i++) {
            d[0][i] = stProb[i] + getLogDensity(i, ob[0]);
        }
        for (int t = 1; t < l; t++) {
            for (int i = 0; i < stateCount; i++) {
                double max = -Double.MAX_VALUE;
                int top_state = -1;
                for (int j = 0; j < stateCount; j++) {
                    double v = d[t - 1][j] + transProb[j][i];
                    if (v > max) {
                        max = v;
                        top_state = j;
                    }
                }
                d[t][i] = max + getLogDensity(i, ob[t]);
                top[t][i] = top_state;
            }
        }
        int[] seq = new int[l];
        double max = -Double.MAX_VALUE;
        int maxi = -1;
        for (int i = 0; i < stateCount; i++) {
            double v = d[l - 1][i];
            if (v > max) {
                max = v;
                maxi = i;
            }
        }
        seq[l - 1] = maxi;
        for (int t = l - 2; t >= 0; t--) {
            seq[t] = top[t + 1][seq[t + 1]];
        }
        return seq;
    }
",1
7999521,7,"    private void processColorCache(RdpPacket_Localised data) throws RdesktopException {
        byte[] palette = null;
        byte[] red = null;
        byte[] green = null;
        byte[] blue = null;
        int j = 0;
        int cache_id = data.get8();
        int n_colors = data.getLittleEndian16();
        palette = new byte[n_colors * 4];
        red = new byte[n_colors];
        green = new byte[n_colors];
        blue = new byte[n_colors];
        data.copyToByteArray(palette, 0, data.getPosition(), palette.length);
        data.incrementPosition(palette.length);
        for (int i = 0; i < n_colors; i++) {
            blue[i] = palette[j];
            green[i] = palette[j + 1];
            red[i] = palette[j + 2];
            j += 4;
        }
        IndexColorModel cm = new IndexColorModel(8, n_colors, red, green, blue);
        cache.put_colourmap(cache_id, cm);
    }
",1
4509735,7,"    private void removeObservation(int index) {
        final int N = y.numRows - 1;
        final double d[] = y.data;
        for (int i = index; i < N; i++) {
            d[i] = d[i + 1];
        }
        y.numRows--;
    }
",1
20340322,7,"    public static void sort(Object[] arr, int start, int end) {
        if (end - start <= 2) {
            if (end - start == 2 && arr[start].toString().compareTo(arr[start + 1].toString()) > 0) {
                Object tmp = arr[start];
                arr[start] = arr[start + 1];
                arr[start + 1] = tmp;
            }
            return;
        }
        if (end - start == 3) {
            sort(arr, start, start + 2);
            sort(arr, start + 1, start + 3);
            sort(arr, start, start + 2);
            return;
        }
        int middle = (start + end) / 2;
        sort(arr, start, middle);
        sort(arr, middle, end);
        Object[] tmp = new Object[end - start];
        int i0 = start;
        int i1 = middle;
        for (int i = 0; i < tmp.length; i++) {
            if (i0 == middle) {
                tmp[i] = arr[i1++];
            } else if (i1 == end || arr[i0].toString().compareTo(arr[i1].toString()) < 0) {
                tmp[i] = arr[i0++];
            } else {
                tmp[i] = arr[i1++];
            }
        }
        System.arraycopy(tmp, 0, arr, start, tmp.length);
    }
",1
4097918,7,"    void addLine(String s) {
        if (curRow < text.length - 1) {
            text[++curRow] = s;
        } else {
            for (int i = 0; i < text.length - 1; i++) {
                text[i] = text[i + 1];
            }
            text[text.length - 1] = s;
        }
    }
",1
20908528,7,"    public static void main(String[] args) {
        if (args.length < 1) {
            System.err.println(""Please pass the name of the class to run as first parameter"");
            System.exit(1);
        }
        String className = args[0];
        String[] newArgs = new String[args.length - 1];
        for (int i = 0; i < args.length - 1; i++) {
            newArgs[i] = args[i + 1];
        }
        String fullClassName = ""org.hitchhackers.tools.jmx."" + className;
        try {
            Class clazz = Class.forName(fullClassName);
            Object newInstance = clazz.newInstance();
            if (newInstance instanceof JMXClientBase) {
                try {
                    JMXClientBase theApplication = (JMXClientBase) newInstance;
                    theApplication.parse(newArgs);
                    theApplication.establishConnection();
                    theApplication.readParams();
                    theApplication.run();
                } catch (IllegalArgumentException e) {
                    System.err.println(""ERROR : "" + e.getMessage());
                    System.out.println("""");
                    Method method;
                    try {
                        method = clazz.getDeclaredMethod(""printUsage"", new Class[0]);
                        method.invoke(null, new Object[0]);
                    } catch (Throwable t) {
                        System.err.println(""There occurred an error, but the called class does not have usage information associated."");
                        System.err.println(""Unfortunately I don't know how to help you...good luck!"");
                        t.printStackTrace(System.err);
                    }
                    System.exit(1);
                } catch (IOException e) {
                    System.err.println(""could not establish connection to VM via JMX : "");
                    e.printStackTrace(System.err);
                }
            } else {
                System.err.println(""invalid class name '"" + className + ""' - I can work only with subclasses of JMXClientBase"");
                System.exit(1);
            }
        } catch (ClassNotFoundException e) {
            System.err.println(""could not find class '"" + fullClassName + ""'"");
            e.printStackTrace(System.err);
            System.exit(2);
        } catch (InstantiationException e) {
            System.err.println(""could not instantiate class '"" + fullClassName + ""' : "");
            e.printStackTrace(System.err);
        } catch (IllegalAccessException e) {
            System.err.println(""could not access class '"" + fullClassName + ""' : "");
            e.printStackTrace(System.err);
        } catch (Throwable t) {
            System.err.println(""There occurred an error: "");
            t.printStackTrace();
            System.exit(2);
        }
    }
",1
4856578,7,"    public void Delete(String HubAddr) {
        j = 0;
        while ((j < i) && (!list[j].getAddr().equals(HubAddr))) {
            j++;
        }
        if (j < i) {
            for (int x = j; x < i - 1; x++) {
                list[x] = list[x + 1];
            }
            i--;
        }
    }
",1
2053517,7,"    protected MultipleGradientPaintContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform t, RenderingHints hints, float[] fractions, Color[] colors, MultipleGradientPaint.CycleMethodEnum cycleMethod, MultipleGradientPaint.ColorSpaceEnum colorSpace) throws NoninvertibleTransformException {
        boolean fixFirst = false;
        boolean fixLast = false;
        int len = fractions.length;
        if (fractions[0] != 0f) {
            fixFirst = true;
            len++;
        }
        if (fractions[fractions.length - 1] != 1.0f) {
            fixLast = true;
            len++;
        }
        for (int i = 0; i < fractions.length - 1; i++) if (fractions[i] == fractions[i + 1]) len--;
        this.fractions = new float[len];
        Color[] loColors = new Color[len - 1];
        Color[] hiColors = new Color[len - 1];
        normalizedIntervals = new float[len - 1];
        gradientUnderflow = colors[0].getRGB();
        gradientOverflow = colors[colors.length - 1].getRGB();
        int idx = 0;
        if (fixFirst) {
            this.fractions[0] = 0;
            loColors[0] = colors[0];
            hiColors[0] = colors[0];
            normalizedIntervals[0] = fractions[0];
            idx++;
        }
        for (int i = 0; i < fractions.length - 1; i++) {
            if (fractions[i] == fractions[i + 1]) {
                if (!colors[i].equals(colors[i + 1])) {
                    hasDiscontinuity = true;
                }
                continue;
            }
            this.fractions[idx] = fractions[i];
            loColors[idx] = colors[i];
            hiColors[idx] = colors[i + 1];
            normalizedIntervals[idx] = fractions[i + 1] - fractions[i];
            idx++;
        }
        this.fractions[idx] = fractions[fractions.length - 1];
        if (fixLast) {
            loColors[idx] = hiColors[idx] = colors[colors.length - 1];
            normalizedIntervals[idx] = 1 - fractions[fractions.length - 1];
            idx++;
            this.fractions[idx] = 1;
        }
        AffineTransform tInv = t.createInverse();
        double[] m = new double[6];
        tInv.getMatrix(m);
        a00 = (float) m[0];
        a10 = (float) m[1];
        a01 = (float) m[2];
        a11 = (float) m[3];
        a02 = (float) m[4];
        a12 = (float) m[5];
        this.cycleMethod = cycleMethod;
        this.colorSpace = colorSpace;
        if (cm.getColorSpace() == lrgbmodel_A.getColorSpace()) dataModel = lrgbmodel_A; else if (cm.getColorSpace() == srgbmodel_A.getColorSpace()) dataModel = srgbmodel_A; else throw new IllegalArgumentException(""Unsupported ColorSpace for interpolation"");
        calculateGradientFractions(loColors, hiColors);
        model = GraphicsUtil.coerceColorModel(dataModel, cm.isAlphaPremultiplied());
    }
",1
13335722,7,"        public E poll() {
            if (isEmpty()) {
                return null;
            }
            E e = (E) elements[0];
            for (int i = 0; i < size - 1; i++) {
                elements[i] = elements[i + 1];
            }
            size--;
            return e;
        }
",0
215863,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
9189479,7,"    void setPixelData(byte[] data, ImageData imageData) {
        switch(headerChunk.getColorType()) {
            case PngIhdrChunk.COLOR_TYPE_GRAYSCALE_WITH_ALPHA:
                {
                    int width = imageData.width;
                    int height = imageData.height;
                    int destBytesPerLine = imageData.bytesPerLine;
                    int srcBytesPerLine = getAlignedBytesPerRow();
                    if (headerChunk.getBitDepth() > 8) srcBytesPerLine /= 2;
                    byte[] rgbData = new byte[destBytesPerLine * height];
                    byte[] alphaData = new byte[width * height];
                    for (int y = 0; y < height; y++) {
                        int srcIndex = srcBytesPerLine * y;
                        int destIndex = destBytesPerLine * y;
                        int destAlphaIndex = width * y;
                        for (int x = 0; x < width; x++) {
                            byte grey = data[srcIndex];
                            byte alpha = data[srcIndex + 1];
                            rgbData[destIndex + 0] = grey;
                            rgbData[destIndex + 1] = grey;
                            rgbData[destIndex + 2] = grey;
                            alphaData[destAlphaIndex] = alpha;
                            srcIndex += 2;
                            destIndex += 3;
                            destAlphaIndex++;
                        }
                    }
                    imageData.data = rgbData;
                    imageData.alphaData = alphaData;
                    break;
                }
            case PngIhdrChunk.COLOR_TYPE_RGB_WITH_ALPHA:
                {
                    int width = imageData.width;
                    int height = imageData.height;
                    int destBytesPerLine = imageData.bytesPerLine;
                    int srcBytesPerLine = getAlignedBytesPerRow();
                    if (headerChunk.getBitDepth() > 8) srcBytesPerLine /= 2;
                    byte[] rgbData = new byte[destBytesPerLine * height];
                    byte[] alphaData = new byte[width * height];
                    for (int y = 0; y < height; y++) {
                        int srcIndex = srcBytesPerLine * y;
                        int destIndex = destBytesPerLine * y;
                        int destAlphaIndex = width * y;
                        for (int x = 0; x < width; x++) {
                            rgbData[destIndex + 0] = data[srcIndex + 0];
                            rgbData[destIndex + 1] = data[srcIndex + 1];
                            rgbData[destIndex + 2] = data[srcIndex + 2];
                            alphaData[destAlphaIndex] = data[srcIndex + 3];
                            srcIndex += 4;
                            destIndex += 3;
                            destAlphaIndex++;
                        }
                    }
                    imageData.data = rgbData;
                    imageData.alphaData = alphaData;
                    break;
                }
            case PngIhdrChunk.COLOR_TYPE_PALETTE:
                imageData.data = data;
                if (alphaPalette != null) {
                    int size = imageData.width * imageData.height;
                    byte[] alphaData = new byte[size];
                    byte[] pixelData = new byte[size];
                    imageData.getPixels(0, 0, size, pixelData, 0);
                    for (int i = 0; i < pixelData.length; i++) {
                        alphaData[i] = alphaPalette[pixelData[i] & 0xFF];
                    }
                    imageData.alphaData = alphaData;
                }
                break;
            case PngIhdrChunk.COLOR_TYPE_RGB:
            default:
                int height = imageData.height;
                int destBytesPerLine = imageData.bytesPerLine;
                int srcBytesPerLine = getAlignedBytesPerRow();
                if (headerChunk.getBitDepth() > 8) srcBytesPerLine /= 2;
                if (destBytesPerLine != srcBytesPerLine) {
                    for (int y = 0; y < height; y++) {
                        System.arraycopy(data, y * srcBytesPerLine, imageData.data, y * destBytesPerLine, srcBytesPerLine);
                    }
                } else {
                    imageData.data = data;
                }
                break;
        }
    }
",0
22536574,7,"    static double[] deleteElement(double a[], int del) {
        if (del >= a.length) throw new IllegalArgumentException(""Del index "" + del + "" out of range"");
        double b[] = Arrays.copyOf(a, a.length - 1);
        for (int i = del; i < b.length; i++) b[i] = a[i + 1];
        return b;
    }
",1
4354847,7,"    public double remove(int index) {
        if (index >= length || index < 0) {
            throw new IndexOutOfBoundsException(""index out of bounds"");
        }
        int i = index;
        double ret = values[i];
        while (i < length - 1) {
            values[i] = values[i + 1];
            i++;
        }
        length--;
        findMean();
        findMedian();
        findMode();
        findDeviation();
        return ret;
    }
",1
21953975,7,"    public void moveEvent(TrackEvent event, double newTime) {
        int index = indexOf(event);
        int newIndex = getIndexAfter(newTime);
        if (newIndex == NO_SUCH_EVENT) newIndex = events_fill_p - 1; else if (event.getTime() <= newTime) newIndex -= 1;
        if (index == NO_SUCH_EVENT) {
            System.err.println(""no such event error"");
            return;
        }
        if (index == EMPTY_COLLECTION) index = 0;
        event.setTime(newTime);
        if (index < newIndex) {
            for (int i = index; i < newIndex; i++) {
                events[i] = events[i + 1];
            }
        } else {
            for (int i = index; i > newIndex; i--) {
                events[i] = events[i - 1];
            }
            events[newIndex] = event;
        }
        events[newIndex] = event;
        notifyObjectMoved(event, index, newIndex, true);
    }
",1
1838467,7,"    @SuppressWarnings(""unchecked"")
    public V remove(Object key) {
        int k = checkKey(key);
        int index = Arrays.binarySearch(keyIndices, k);
        if (index >= 0) {
            V old = (V) (values[index]);
            Object[] newValues = Arrays.copyOf(values, values.length - 1);
            int[] newIndices = Arrays.copyOf(keyIndices, keyIndices.length - 1);
            for (int i = index; i < values.length - 1; ++i) {
                newValues[i] = values[i + 1];
                newIndices[i] = keyIndices[i + 1];
            }
            values = newValues;
            keyIndices = newIndices;
            return old;
        }
        return null;
    }
",0
17106514,7,"    void setMinimum(DasDevicePosition row, double nposition) {
        double minima[] = getMinima();
        double maxima[] = getMaxima();
        int i = rows.indexOf(row);
        minima[i] = nposition;
        double alpha1 = this.row.getMinimum();
        double alpha2 = nposition;
        if (i == 0) {
            this.row.setMinimum(nposition);
        } else {
            int nAbove = i;
            double weight3 = integrateWeight(i);
            double fractionalIntegratedWeight = 0.;
            for (int j = 0; j < i; j++) {
                minima[j] = alpha2 * fractionalIntegratedWeight + alpha1 * (1 - fractionalIntegratedWeight);
                fractionalIntegratedWeight += ((Double) weights.get(j)).doubleValue() / weight3;
            }
        }
        for (int j = 0; j < rows.size() - 1; j++) {
            maxima[j] = minima[j + 1] - interMargin;
        }
        setWeights(minima, maxima);
    }
",1
3500205,7,"    public static Phenotype readAnnotatedAlignment(String inputFile) throws IOException {
        String sep = ""\\s+"";
        BufferedReader br = Utils.getBufferedReader(inputFile);
        String[] parsedline = br.readLine().split(sep);
        String missing = ""?"";
        int taxaNumber = 0;
        int locusNumber = 0;
        boolean isDelimited = false;
        while (!parsedline[0].equalsIgnoreCase(""<taxon_name>"")) {
            if (!parsedline[0].equalsIgnoreCase(""<Annotated>"")) {
                if ((parsedline[0].startsWith(""<"") == false) || (parsedline[0].endsWith("">"") == false)) {
                    throw new IllegalArgumentException(""Error before or with property: "" + parsedline[0]);
                }
                if ((parsedline[1].startsWith(""<"") == true) || (parsedline[1].endsWith("">"") == true)) {
                    throw new IllegalArgumentException(""Error before or with value: "" + parsedline[1]);
                }
                if (parsedline[0].equalsIgnoreCase(""<TRANSPOSED>"")) {
                    if (parsedline[1].startsWith(""N"")) throw new IllegalArgumentException(""Error in "" + inputFile + "": The annotated format only accepts transposed data. Data not imported. "");
                }
                if (parsedline[0].equalsIgnoreCase(""<TAXA_NUMBER>"")) {
                    taxaNumber = Integer.parseInt(parsedline[1]);
                }
                if (parsedline[0].equalsIgnoreCase(""<LOCUS_NUMBER>"")) {
                    locusNumber = Integer.parseInt(parsedline[1]);
                }
                if (parsedline[0].equalsIgnoreCase(""<DELIMITED_VALUES>"")) {
                    if (parsedline[1].startsWith(""Y"")) isDelimited = true;
                }
            }
            parsedline = br.readLine().split(sep);
        }
        String[] taxaNames = new String[taxaNumber];
        if (parsedline[0].equalsIgnoreCase(""<taxon_name>"")) {
            for (int i = 0; i < taxaNumber; i++) taxaNames[i] = parsedline[i + 1].toUpperCase();
        } else throw new IllegalArgumentException(""No taxon name section in "" + inputFile + "" . Data not read."");
        parsedline = br.readLine().split(sep);
        ArrayList<String> columns = new ArrayList<String>();
        int n = parsedline.length;
        int locusNameIndex = -1;
        int locusPosIndex = -1;
        for (int i = 0; i < n - 1; i++) {
            String colname = parsedline[i];
            if (!colname.startsWith(""<"") || !colname.endsWith("">"")) throw new IllegalArgumentException(""Improper format for column names in "" + inputFile + "". Data not imported.""); else if (colname.equalsIgnoreCase(""<chromosome_number>"")) columns.add(Trait.PROP_CHROMOSOME); else if (colname.equalsIgnoreCase(""<genetic_position>"")) columns.add(Trait.PROP_POSITION); else if (colname.equalsIgnoreCase(""<locus_name>"")) {
                locusNameIndex = i;
                columns.add(Trait.PROP_LOCUS);
            } else if (colname.equalsIgnoreCase(""<locus_position>"")) {
                locusPosIndex = i;
                columns.add(Trait.PROP_LOCUS_POSITION);
            }
        }
        int colNumber = columns.size();
        int firstValue = colNumber;
        int markerNumber = 1;
        LinkedList<Trait> traitList = new LinkedList<Trait>();
        String[] locusValues = new String[taxaNumber];
        double[] dblValues = new double[taxaNumber];
        DoubleMatrix2D genotypes = DoubleFactory2D.dense.make(taxaNumber, locusNumber);
        for (int loc = 0; loc < locusNumber; loc++) {
            parsedline = br.readLine().split(sep);
            if (isDelimited) {
                for (int t = 0; t < taxaNumber; t++) {
                    locusValues[t] = parsedline[t + firstValue];
                }
            } else {
                for (int t = 0; t < taxaNumber; t++) {
                    locusValues[t] = parsedline[firstValue].substring(t, t + 1);
                }
            }
            String traitname = """";
            if (locusNameIndex >= 0) traitname = parsedline[locusNameIndex]; else if (locusPosIndex >= 0) traitname = traitname + ""."" + parsedline[locusPosIndex]; else traitname = ""m"" + markerNumber++;
            Trait trait = makeCharacterTrait(locusValues, dblValues, traitname, Trait.TYPE_MARKER);
            for (int col = 0; col < colNumber; col++) {
                trait.setProperty(columns.get(col), parsedline[col + 1]);
            }
            traitList.add(trait);
            genotypes.viewColumn(loc).assign(dblValues);
        }
        br.close();
        return new SimplePhenotype(new SimpleIdGroup(taxaNames), traitList, genotypes);
    }
",1
19008074,7,"    protected final void addToken(SynonymToken token) {
        int l = tokens.length - 1;
        for (int i = 0; i < l; i++) tokens[i] = tokens[i + 1];
        tokens[l] = token;
        if (queueSize < tokens.length) queueSize++;
    }
",1
45973,7,"    public void readCommand(OsProcess proc) {
        String str;
        user = proc;
        if (rawTTY) str = readFromRawTTY(); else str = readFromCookedTTY();
        String[] words = toArgs(str);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
",1
18619512,7,"    public void deleteSheet() {
        if (numberOfSheets > 1) {
            Sheet[] old;
            old = s;
            s = new Sheet[numberOfSheets - 1];
            if (currentSheet == 0) {
                old[0].undraw(panel);
                for (int x = 0; x < numberOfSheets - 1; x++) {
                    s[x] = old[x + 1];
                }
                currentSheet = 0;
                s[currentSheet].draw(panel);
            } else if (currentSheet == numberOfSheets - 1) {
                old[numberOfSheets - 1].undraw(panel);
                for (int x = 0; x < numberOfSheets - 1; x++) {
                    s[x] = old[x];
                }
                currentSheet = currentSheet - 1;
                s[currentSheet].draw(panel);
            } else {
                old[currentSheet].undraw(panel);
                for (int x = 0; x < currentSheet; x++) {
                    s[x] = old[x];
                }
                for (int x = currentSheet + 1; x <= numberOfSheets - 1; x++) {
                    s[x - 1] = old[x];
                }
                currentSheet = currentSheet - 1;
                s[currentSheet].draw(panel);
            }
            numberOfSheets--;
        } else {
            s[0].undraw(panel);
            s = new Sheet[1];
            currentSheet = 0;
            s[0] = new Sheet(cat, panel, baseURL, outputFormat, xmlDragging, xmlThreeClicks);
            s[0].draw(panel);
        }
    }
",1
4488837,7,"    private static int[] createWeights(int length, int base) {
        int[] weights = new int[length];
        weights[length - 1] = 1;
        for (int i = length - 2; i >= 0; i--) weights[i] = weights[i + 1] * base;
        return weights;
    }
",0
15475533,7,"    protected void shiftArray(byte[] array) {
        for (int i = 0; i < (array.length - 1); i++) {
            array[i] = array[i + 1];
        }
        array[array.length - 1] = 0;
    }
",0
1214682,7,"    public RPoint[] getSideHandles(int s) {
        RPoint[] sideHandles;
        sideHandles = new RPoint[2];
        if (s != -1) {
            sideHandles[0] = handles[s];
            sideHandles[1] = handles[s + 1];
        }
        return sideHandles;
    }
",0
949832,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
1668849,7,"    @Theory
    public void testReorderModelBodyColumn(int dragFromModelBodyColumn, int dragToModelBodyColumn, @BodyConfigDataPoint IBodyConfig bodyConfig) {
        ColumnTransformSupport support = new ColumnTransformSupport(bodyConfig);
        support.reorderModelBodyColumn(dragFromModelBodyColumn, dragToModelBodyColumn);
        int[] expected = new int[bodyConfig.getColumnCount()];
        for (int i = 0; i < expected.length; i++) {
            expected[i] = i;
        }
        if (Math.max(dragFromModelBodyColumn, dragToModelBodyColumn) < bodyConfig.getColumnCount() && Math.min(dragFromModelBodyColumn, dragToModelBodyColumn) >= 0) {
            if (dragFromModelBodyColumn < dragToModelBodyColumn) {
                for (int i = dragFromModelBodyColumn; i < dragToModelBodyColumn; i++) {
                    expected[i] = expected[i + 1];
                }
                expected[dragToModelBodyColumn] = dragFromModelBodyColumn;
            } else if (dragToModelBodyColumn < dragFromModelBodyColumn) {
                for (int i = dragFromModelBodyColumn; i > dragToModelBodyColumn; i--) {
                    expected[i] = expected[i - 1];
                }
                expected[dragToModelBodyColumn] = dragFromModelBodyColumn;
            }
        }
        int[] modelBodyColumnOrder = support.getModelBodyColumnOrder();
        assertEquals(expected.length, modelBodyColumnOrder.length, 0);
        for (int i = 0; i < expected.length; i++) {
            assertEquals(expected[i], modelBodyColumnOrder[i], 0);
        }
    }
",1
9579906,7,"    public void mouseClickedAction(MathPainterPanelEvent mppe) {
        if (clickAction == ADD_POINT) {
            if (nPoints == 0) {
                xdata = new double[1];
                ydata = new double[1];
                xdata[0] = mppe.getMathSpaceX();
                ydata[0] = mppe.getMathSpaceY();
            } else {
                double newX = mppe.getMathSpaceX();
                double newY = mppe.getMathSpaceY();
                double[] newXData = new double[nPoints + 1];
                double[] newYData = new double[nPoints + 1];
                int ii = insertIndex(xdata, newX);
                for (int i = 0; i < ii; i++) {
                    newXData[i] = xdata[i];
                    newYData[i] = ydata[i];
                }
                newXData[ii] = newX;
                newYData[ii] = newY;
                for (int i = ii + 1; i < nPoints + 1; i++) {
                    newXData[i] = xdata[i - 1];
                    newYData[i] = ydata[i - 1];
                }
                xdata = newXData;
                ydata = newYData;
            }
            nPoints++;
            mathCoords.setPoints(xdata, ydata);
            graphicsPanel.clear();
            mathPainter.setPaint(dataColorBtn.getColor());
            pointPlotter.plot();
            if (nPoints > 1) {
                drawRegressionCurve(xdata, ydata);
            }
            graphicsPanel.update();
        } else {
            if (nPoints == 0) {
            } else {
                int deleteIndex = -1;
                for (int i = 0; i < nPoints; i++) {
                    if ((Math.abs(mppe.getUserSpaceX() - mathPainter.mathToUserX(xdata[i])) <= 5) && (Math.abs(mppe.getUserSpaceY() - mathPainter.mathToUserY(ydata[i])) <= 5)) {
                        deleteIndex = i;
                        break;
                    }
                }
                double[] newXData = new double[nPoints - 1];
                double[] newYData = new double[nPoints - 1];
                for (int i = 0; i < deleteIndex; i++) {
                    newXData[i] = xdata[i];
                    newYData[i] = ydata[i];
                }
                for (int i = deleteIndex; i < nPoints - 1; i++) {
                    newXData[i] = xdata[i + 1];
                    newYData[i] = ydata[i + 1];
                }
                xdata = newXData;
                ydata = newYData;
                nPoints--;
                mathCoords.setPoints(xdata, ydata);
                graphicsPanel.clear();
                mathPainter.setPaint(dataColorBtn.getColor());
                pointPlotter.plot();
                if (nPoints > 1) {
                    drawRegressionCurve(xdata, ydata);
                }
                graphicsPanel.update();
            }
        }
    }
",1
17445579,7,"    protected void renderNode(TreeView.Node node, PrintWriter writer, int level, int openNodeDepth, String formPrefix) {
        writer.print(""    <tr"");
        if (getSelectedNode() == node) writer.print(getSelectedNodeBackgroundColor());
        writer.println("">"");
        TreeView.Node[] taxonomy = new Node[level];
        taxonomy[level - 1] = node;
        for (int i = level - 2; i >= 0; i--) taxonomy[i] = taxonomy[i + 1].getParent();
        int colSpans = 0;
        for (int i = 1; i < taxonomy.length; i++) {
            if (i == level - 1) {
                if (colSpans > 0) {
                    writer.print(""        <td"");
                    if (getSelectedNode() == node) writer.print(getSelectedNodeBackgroundColor());
                    if (colSpans > 1) writer.print("" colspan='"" + colSpans + ""'"");
                    writer.println(""></td>"");
                    colSpans = 0;
                }
                if (node.getChildren().size() > 0) {
                    writer.print(""        <td"");
                    if (getSelectedNode() == node) writer.print(getSelectedNodeBackgroundColor());
                    writer.print("" align=center>"");
                    writer.print(""<input type='image' src='"");
                    writer.print(getImagePath());
                    if (node.isOpened()) writer.print(""open_arrow.png""); else writer.print(""closed_arrow.png"");
                    writer.print(""' name='"" + formPrefix + (node.isOpened() ? ""close"" : ""open"") + ""."" + node.resolvePath() + ""'>"");
                    writer.println(""</td>"");
                } else {
                    colSpans++;
                }
            } else colSpans++;
        }
        if (colSpans > 0) {
            writer.print(""        <td"");
            if (getSelectedNode() == node) writer.print(getSelectedNodeBackgroundColor());
            if (colSpans > 1) writer.print("" colspan='"" + colSpans + ""'"");
            writer.println(""></td>"");
            colSpans = 0;
        }
        writer.print(""        <td"");
        if (getSelectedNode() == node) writer.print(getSelectedNodeBackgroundColor());
        writer.print("">"");
        if (((Node) node).isSelectable()) writer.print(""<input type='image' name='"" + formPrefix + ""select."" + node.resolvePath() + ""' src='""); else writer.print(""<img src='"");
        writer.print(node.getIconPath());
        writer.println(""'></td>"");
        writer.print(""        <td width=100%"");
        if (getSelectedNode() == node) writer.print(getSelectedNodeBackgroundColor());
        int spanToEnd = openNodeDepth - taxonomy.length + 2;
        if (spanToEnd > 0) writer.print("" colspan='"" + String.valueOf(spanToEnd) + ""'"");
        writer.print(""><font size='-2'"");
        if (getSelectedNode() == node) writer.print("" color='#ffffff'"");
        writer.print("">&nbsp;"");
        writer.print(node.getText());
        writer.println(""&nbsp;</font></td>"");
        writer.println(""    </tr>"");
        if (node.isOpened()) for (int i = 0; i < node.getChildren().size(); i++) renderNode(node.getChildren().get(i), writer, level + 1, openNodeDepth, formPrefix);
    }
",0
19954473,7,"    public static void bsw32(byte[] ary, int offset) {
        byte t = ary[offset];
        ary[offset] = ary[offset + 3];
        ary[offset + 3] = t;
        t = ary[offset + 1];
        ary[offset + 1] = ary[offset + 2];
        ary[offset + 2] = t;
    }
",1
13952462,7,"    boolean remove(Process process) {
        readyList_.removeElement(process);
        boolean done = false;
        int i = 0;
        while (!done) if (process_[i].getProcessId() == process.getProcessId()) done = true; else i++;
        for (; i < process_.length - 1; i++) process_[i] = process_[i + 1];
        process_[i] = process;
        return readyList_.isEmpty();
    }
",1
2529436,7,"    protected void newCluster() {
        newCluster = new SimpleNode();
        newCluster.setHeight(newNodeHeight());
        newCluster.addChild(clusters[abi]);
        newCluster.addChild(clusters[abj]);
        clusters[abi] = newCluster;
        clusters[abj] = null;
        for (int k = 0; k < numClusters; k++) {
            if (k != besti && k != bestj) {
                int ak = alias[k];
                distance[ak][abi] = distance[abi][ak] = updatedDistance(besti, bestj, k);
                distance[ak][abj] = distance[abj][ak] = -1.0;
            }
        }
        distance[abi][abi] = 0.0;
        distance[abj][abj] = -1.0;
        for (int i = bestj; i < numClusters - 1; i++) {
            alias[i] = alias[i + 1];
        }
        tipCount[abi] += tipCount[abj];
        tipCount[abj] = 0;
        numClusters--;
    }
",0
14671024,7,"    public DateChooser(Calendar date) {
        DateFormatSymbols sym = new DateFormatSymbols();
        months = sym.getShortMonths();
        String[] wkd = sym.getShortWeekdays();
        for (int i = 0; i < 7; i++) {
            int l = Math.min(wkd[i + 1].length(), 2);
            labels[i] = wkd[i + 1].substring(0, l);
        }
        highlightColor = UIManager.getColor(""List.selectionBackground"");
        disabledColor = Color.red;
        setBorder(BorderFactory.createEtchedBorder());
        setLayout(new BorderLayout(5, 5));
        JPanel top = new JPanel();
        top.setLayout(new BorderLayout(0, 0));
        top.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
        JPanel p1 = new JPanel();
        p1.setLayout(new BorderLayout());
        top.add(p1, BorderLayout.CENTER);
        b_lmonth = new JButton(""<"");
        b_lmonth.addActionListener(this);
        b_lmonth.setMargin(new Insets(0, 0, 0, 0));
        p1.add(b_lmonth, BorderLayout.WEST);
        l_month = new JLabel();
        l_date = new JLabel(""Date"");
        l_date.setAlignmentX(0);
        p1.add(l_date, BorderLayout.CENTER);
        b_rmonth = new JButton("">"");
        b_rmonth.addActionListener(this);
        b_rmonth.setMargin(new Insets(0, 0, 0, 0));
        p1.add(b_rmonth, BorderLayout.EAST);
        add(""North"", top);
        calendarPane = new CalendarPane();
        calendarPane.setOpaque(false);
        add(""Center"", calendarPane);
        int fd = date.getFirstDayOfWeek();
        weekendCols[0] = (Calendar.SUNDAY - fd + 7) % 7;
        weekendCols[1] = (Calendar.SATURDAY - fd + 7) % 7;
        setSelectedDate(date);
    }
",1
1891617,7,"    @Override
    protected boolean readEphCoeff(double jultime) {
        boolean result = false;
        if ((jultime < this.startepoch) || (jultime >= this.finalepoch)) {
            return result;
        }
        if ((jultime < this.ephemerisdates[1]) || (jultime >= this.ephemerisdates[2])) {
            int i = 0;
            int records = 0;
            int j = 0;
            String filename = "" "";
            char[] cline = new char[70];
            try {
                for (i = 0; i < startfiledates.length - 1; i++) {
                    if ((jultime >= startfiledates[i]) && (jultime < startfiledates[i + 1])) {
                        ephemerisdates[1] = startfiledates[i];
                        ephemerisdates[2] = startfiledates[i + 1];
                        filename = filenames[i];
                        records = (int) (ephemerisdates[2] - ephemerisdates[1]) / intervalduration;
                    }
                }
                filename = this.patheph + filename;
                FileReader file = new FileReader(filename);
                for (j = 1; j <= records; j++) {
                    file.read(cline, 0, 13);
                    for (i = 2; i <= 244; i++) {
                        file.read(cline, 0, 70);
                        cline[19] = 'e';
                        cline[42] = 'e';
                        cline[65] = 'e';
                        if (i > 2) {
                            ephemeriscoefficients[(j - 1) * numbersperinterval + (3 * (i - 2) - 1)] = Double.parseDouble(String.valueOf(cline, 1, 22));
                        }
                        if (i > 2) {
                            ephemeriscoefficients[(j - 1) * numbersperinterval + 3 * (i - 2)] = Double.parseDouble(String.valueOf(cline, 24, 22));
                        }
                        if (i < 244) {
                            ephemeriscoefficients[(j - 1) * numbersperinterval + (3 * (i - 2) + 1)] = Double.parseDouble(String.valueOf(cline, 47, 22));
                        }
                    }
                }
                file.close();
                result = true;
            } catch (IOException e) {
                System.out.println(""Error = "" + e.toString());
            } catch (StringIndexOutOfBoundsException e) {
                System.out.println(""Error = "" + e.toString());
            }
        } else {
            result = true;
        }
        return result;
    }
",1
21039958,7,"    public Object[] getScalarFuncParams(Object[] params) {
        if (Helper.hasNulls(params, 1)) return null;
        if (!XFunction.class.isInstance(params[1])) return null;
        XFunction func = (XFunction) params[1];
        Class classRet = func.getReturnType();
        if (!isScalarType(classRet) || func.getArgTypes().length != 1) {
            return null;
        }
        Object[] ret = new Object[params.length - 1];
        for (int i = 0; i < ret.length; i++) {
            ret[i] = params[i + 1];
        }
        return ret;
    }
",0
9525629,7,"    String InputCommand() {
        int size = Shell.CMD_MAXLINE - 2;
        byte[] c = new byte[1];
        IntRef n = new IntRef(1);
        int str_len = 0;
        int str_index = 0;
        IntRef len = new IntRef(0);
        boolean current_hist = false;
        byte[] line = new byte[Shell.CMD_MAXLINE];
        int it_history = 0;
        int it_completion = 0;
        while (size != 0) {
            Dos.dos.echo = false;
            while (!Dos_files.DOS_ReadFile(input_handle, c, n)) {
                IntRef dummy = new IntRef(0);
                Dos_files.DOS_CloseFile(input_handle);
                Dos_files.DOS_OpenFile(""con"", 2, dummy);
                Log.log(LogTypes.LOG_MISC, LogSeverities.LOG_ERROR, ""Reopening the input handle.This is a bug!"");
            }
            if (n.value == 0) {
                size = 0;
                continue;
            }
            switch(c[0]) {
                case 0x00:
                    {
                        Dos_files.DOS_ReadFile(input_handle, c, n);
                        switch(c[0]) {
                            case 0x3d:
                                if (l_history.size() == 0) break;
                                it_history = 0;
                                if (l_history.size() > 0 && ((String) l_history.firstElement()).length() > str_len) {
                                    String reader = ((String) l_history.firstElement()).substring(str_len);
                                    for (int i = 0; i < reader.length(); i++) {
                                        c[0] = (byte) reader.charAt(0);
                                        line[str_index++] = (byte) reader.charAt(0);
                                        Dos_files.DOS_WriteFile(Dos_files.STDOUT, c, n);
                                    }
                                    str_len = str_index = ((String) l_history.firstElement()).length();
                                    size = Shell.CMD_MAXLINE - str_index - 2;
                                    line[str_len] = 0;
                                }
                                break;
                            case 0x4B:
                                if (str_index != 0) {
                                    outc(8);
                                    str_index--;
                                }
                                break;
                            case 0x4D:
                                if (str_index < str_len) {
                                    outc(line[str_index++]);
                                }
                                break;
                            case 0x47:
                                while (str_index != 0) {
                                    outc(8);
                                    str_index--;
                                }
                                break;
                            case 0x4F:
                                while (str_index < str_len) {
                                    outc(line[str_index++]);
                                }
                                break;
                            case 0x48:
                                if (l_history.size() == 0 || it_history == l_history.size()) break;
                                if (it_history == 0 && !current_hist) {
                                    current_hist = true;
                                    l_history.insertElementAt(new String(line, 0, str_len), 0);
                                    it_history++;
                                }
                                for (; str_index > 0; str_index--) {
                                    outc(8);
                                    outc(' ');
                                    outc(8);
                                }
                                StringHelper.strcpy(line, (String) l_history.elementAt(it_history));
                                len.value = ((String) l_history.elementAt(it_history)).length();
                                str_len = str_index = len.value;
                                size = Shell.CMD_MAXLINE - str_index - 2;
                                Dos_files.DOS_WriteFile(Dos_files.STDOUT, line, len);
                                it_history++;
                                break;
                            case 0x50:
                                if (l_history.size() == 0 || it_history == 0) break;
                                it_history--;
                                if (it_history == 0) {
                                    it_history++;
                                    if (current_hist) {
                                        current_hist = false;
                                        l_history.removeElementAt(0);
                                    }
                                    break;
                                } else it_history--;
                                for (; str_index > 0; str_index--) {
                                    outc(8);
                                    outc(' ');
                                    outc(8);
                                }
                                StringHelper.strcpy(line, (String) l_history.elementAt(it_history));
                                len.value = ((String) l_history.elementAt(it_history)).length();
                                str_len = str_index = len.value;
                                size = Shell.CMD_MAXLINE - str_index - 2;
                                Dos_files.DOS_WriteFile(Dos_files.STDOUT, line, len);
                                it_history++;
                                break;
                            case 0x53:
                                {
                                    if (str_index >= str_len) break;
                                    IntRef a = new IntRef(str_len - str_index - 1);
                                    byte[] text = new byte[a.value];
                                    System.arraycopy(line, str_index + 1, text, 0, a.value);
                                    Dos_files.DOS_WriteFile(Dos_files.STDOUT, text, a);
                                    outc(' ');
                                    outc(8);
                                    for (int i = str_index; i < str_len - 1; i++) {
                                        line[i] = line[i + 1];
                                        outc(8);
                                    }
                                    line[--str_len] = 0;
                                    size++;
                                }
                                break;
                            default:
                                break;
                        }
                    }
                    break;
                case 0x08:
                    if (str_index != 0) {
                        outc(8);
                        int str_remain = str_len - str_index;
                        size++;
                        if (str_remain != 0) {
                            for (int i = 0; i < str_remain; i++) line[str_index - 1 + i] = line[str_index + i];
                            line[--str_len] = 0;
                            str_index--;
                            for (int i = str_index; i < str_len; i++) outc(line[i]);
                        } else {
                            line[--str_index] = '\0';
                            str_len--;
                        }
                        outc(' ');
                        outc(8);
                        while (str_remain-- != 0) outc(8);
                    }
                    if (l_completion.size() != 0) l_completion.clear();
                    break;
                case 0x0a:
                    break;
                case 0x0d:
                    outc('\n');
                    size = 0;
                    break;
                case '\t':
                    {
                        if (l_completion.size() != 0) {
                            it_completion++;
                            if (it_completion == l_completion.size()) it_completion = 0;
                        } else {
                            boolean dir_only = StringHelper.toString(line).toUpperCase().startsWith(""CD "");
                            String sLine = StringHelper.toString(line);
                            int p_completion_start = sLine.lastIndexOf(' ');
                            if (p_completion_start >= 0) {
                                p_completion_start++;
                                completion_index = p_completion_start;
                            } else {
                                p_completion_start = 0;
                                completion_index = 0;
                            }
                            int path;
                            if ((path = sLine.substring(completion_index).lastIndexOf('\\')) >= 0) completion_index += path + 1;
                            if ((path = sLine.substring(completion_index).lastIndexOf('/')) >= 0) completion_index += path + 1;
                            String mask;
                            if (p_completion_start >= 0) {
                                mask = sLine.substring(p_completion_start);
                                int dot_pos = mask.lastIndexOf('.');
                                int bs_pos = mask.lastIndexOf('\\');
                                int fs_pos = mask.lastIndexOf('/');
                                int cl_pos = mask.lastIndexOf(':');
                                if ((dot_pos - bs_pos > 0) && (dot_pos - fs_pos > 0) && (dot_pos - cl_pos > 0)) mask += ""*""; else mask += ""*.*"";
                            } else {
                                mask = ""*.*"";
                            }
                            int save_dta = Dos.dos.dta();
                            Dos.dos.dta((int) Dos.dos.tables.tempdta);
                            boolean res = Dos_files.DOS_FindFirst(mask, 0xffff & ~Dos_system.DOS_ATTR_VOLUME);
                            if (!res) {
                                Dos.dos.dta((int) save_dta);
                                break;
                            }
                            Dos_DTA dta = new Dos_DTA(Dos.dos.dta());
                            StringRef name = new StringRef();
                            LongRef sz = new LongRef(0);
                            IntRef date = new IntRef(0);
                            IntRef time = new IntRef(0);
                            ShortRef att = new ShortRef(0);
                            int extIndex = 0;
                            while (res) {
                                dta.GetResult(name, sz, date, time, att);
                                if (!name.value.equals(""."") && !name.value.equals("".."")) {
                                    if (dir_only) {
                                        if ((att.value & Dos_system.DOS_ATTR_DIRECTORY) != 0) l_completion.add(name.value);
                                    } else {
                                        int pos = name.value.lastIndexOf('.');
                                        String ext = null;
                                        if (pos >= 0) ext = name.value.substring(pos + 1);
                                        if (ext != null && (ext.equalsIgnoreCase(""BAT"") || ext.equalsIgnoreCase(""COM"") || ext.equalsIgnoreCase(""EXE""))) l_completion.insertElementAt(name.value, extIndex++); else l_completion.add(name.value);
                                    }
                                }
                                res = Dos_files.DOS_FindNext();
                            }
                            it_completion = 0;
                            Dos.dos.dta((int) save_dta);
                        }
                        if (l_completion.size() != 0 && ((String) l_completion.elementAt(it_completion)).length() != 0) {
                            for (; str_index > completion_index; str_index--) {
                                outc(8);
                                outc(' ');
                                outc(8);
                            }
                            StringHelper.strcpy(line, completion_index, (String) l_completion.elementAt(it_completion));
                            len.value = ((String) l_completion.elementAt(it_completion)).length();
                            str_len = str_index = completion_index + len.value;
                            size = Shell.CMD_MAXLINE - str_index - 2;
                            Dos_files.DOS_WriteFile(Dos_files.STDOUT, ((String) l_completion.elementAt(it_completion)).getBytes(), len);
                        }
                    }
                    break;
                case 0x1b:
                    outc('\\');
                    outc('\n');
                    line[0] = 0;
                    if (l_completion.size() != 0) l_completion.clear();
                    StringHelper.strcpy(line, InputCommand());
                    size = 0;
                    str_len = 0;
                    break;
                default:
                    if (l_completion.size() != 0) l_completion.clear();
                    if (str_index < str_len && true) {
                        outc(' ');
                        IntRef a = new IntRef(str_len - str_index);
                        byte[] text = new byte[a.value];
                        System.arraycopy(line, str_index, text, 0, a.value);
                        Dos_files.DOS_WriteFile(Dos_files.STDOUT, text, a);
                        outc(8);
                        for (int i = str_len; i > str_index; i--) {
                            line[i] = line[i - 1];
                            outc(8);
                        }
                        line[++str_len] = 0;
                        size--;
                    }
                    line[str_index] = c[0];
                    str_index++;
                    if (str_index > str_len) {
                        line[str_index] = '\0';
                        str_len++;
                        size--;
                    }
                    Dos_files.DOS_WriteFile(Dos_files.STDOUT, c, n);
                    break;
            }
        }
        if (str_len == 0) return null;
        str_len++;
        if (current_hist) {
            current_hist = false;
            l_history.removeElementAt(0);
        }
        String sLine = StringHelper.toString(line);
        l_history.insertElementAt(sLine, 0);
        it_history = 0;
        if (l_completion.size() != 0) l_completion.clear();
        return sLine;
    }
",0
4360850,7,"    protected MultipleGradientPaintContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform t, RenderingHints hints, float[] fractions, Color[] colors, MultipleGradientPaint.CycleMethodEnum cycleMethod, MultipleGradientPaint.ColorSpaceEnum colorSpace) throws NoninvertibleTransformException {
        boolean fixFirst = false;
        boolean fixLast = false;
        int len = fractions.length;
        if (fractions[0] != 0f) {
            fixFirst = true;
            len++;
        }
        if (fractions[fractions.length - 1] != 1.0f) {
            fixLast = true;
            len++;
        }
        for (int i = 0; i < fractions.length - 1; i++) if (fractions[i] == fractions[i + 1]) len--;
        this.fractions = new float[len];
        Color[] loColors = new Color[len - 1];
        Color[] hiColors = new Color[len - 1];
        normalizedIntervals = new float[len - 1];
        gradientUnderflow = colors[0].getRGB();
        gradientOverflow = colors[colors.length - 1].getRGB();
        int idx = 0;
        if (fixFirst) {
            this.fractions[0] = 0;
            loColors[0] = colors[0];
            hiColors[0] = colors[0];
            normalizedIntervals[0] = fractions[0];
            idx++;
        }
        for (int i = 0; i < fractions.length - 1; i++) {
            if (fractions[i] == fractions[i + 1]) {
                if (!colors[i].equals(colors[i + 1])) {
                    hasDiscontinuity = true;
                }
                continue;
            }
            this.fractions[idx] = fractions[i];
            loColors[idx] = colors[i];
            hiColors[idx] = colors[i + 1];
            normalizedIntervals[idx] = fractions[i + 1] - fractions[i];
            idx++;
        }
        this.fractions[idx] = fractions[fractions.length - 1];
        if (fixLast) {
            loColors[idx] = hiColors[idx] = colors[colors.length - 1];
            normalizedIntervals[idx] = 1 - fractions[fractions.length - 1];
            idx++;
            this.fractions[idx] = 1;
        }
        AffineTransform tInv = t.createInverse();
        double[] m = new double[6];
        tInv.getMatrix(m);
        a00 = (float) m[0];
        a10 = (float) m[1];
        a01 = (float) m[2];
        a11 = (float) m[3];
        a02 = (float) m[4];
        a12 = (float) m[5];
        this.cycleMethod = cycleMethod;
        this.colorSpace = colorSpace;
        if (cm.getColorSpace() == lrgbmodel_A.getColorSpace()) dataModel = lrgbmodel_A; else if (cm.getColorSpace() == srgbmodel_A.getColorSpace()) dataModel = srgbmodel_A; else throw new IllegalArgumentException(""Unsupported ColorSpace for interpolation"");
        calculateGradientFractions(loColors, hiColors);
        model = GraphicsUtil.coerceColorModel(dataModel, cm.isAlphaPremultiplied());
    }
",1
20143578,7,"    private void ricompatta() {
        for (int i = 0; i < cardsPresent; i++) {
            if (cards[i] == null && cards[i + 1] != null) {
                cards[i] = cards[i + 1];
                cards[i + 1] = null;
            }
        }
    }
",1
8071936,7,"    protected void resolveMessage() {
        String[] lines = message.split(LINE_SEPARATOR);
        header = lines[0];
        if (lines.length > 1) {
            bodyEntities = new String[lines.length - 1];
            for (int i = 0; i < lines.length - 1; i++) {
                bodyEntities[i] = lines[i + 1];
            }
        }
    }
",1
16327358,7,"    public void addFile(String name) {
        int currentPosition = -1;
        for (int i = 0; i < MAX_FILES; i++) {
            if ((files[i] != null) && files[i].equals(name)) {
                currentPosition = i;
            }
        }
        if (currentPosition == 0) {
            return;
        }
        if (currentPosition > 0) {
            for (int i = currentPosition; i < MAX_FILES - 1; i++) {
                files[i] = files[i + 1];
            }
        }
        for (int j = MAX_FILES - 2; j >= 0; j--) {
            files[j + 1] = files[j];
        }
        files[0] = name;
        fileList.setListData(files);
        fileList.setSelectedIndex(0);
        pack();
        saveList();
    }
",0
9097634,7,"    public static Gsv valueOf(final String... values) {
        Validator.notNull(values, ""GSV sentences"");
        if (values.length == 0) {
            throw new IllegalArgumentException(""GSV sentences must not be empty."");
        }
        String[] parts = values[0].split("","");
        final int totalNumberOfMessages = Integer.parseInt(parts[1]);
        if (totalNumberOfMessages != values.length) {
            throw new NmeaFormatException(String.format(""Not all messages given. Expected %s but got %s: '%s' "", totalNumberOfMessages, values.length, values[0]));
        }
        final int messageNumber = Integer.parseInt(parts[2]);
        if (messageNumber != 1) {
            throw new NmeaFormatException(""Expecting message number 1, but was "" + messageNumber + ""."");
        }
        final int satellitesInView = Integer.parseInt(parts[3]);
        for (int i = 1; i < values.length; ++i) {
            Checksum.check(values[i]);
            parts = values[i].split("","");
            if (totalNumberOfMessages != Integer.parseInt(parts[1])) {
                throw new NmeaFormatException(""Different number of messages."");
            }
            if (Integer.parseInt(parts[2]) != i + 1) {
                throw new NmeaFormatException(""Expecting message number "" + (i + 1) + "", but was "" + messageNumber + ""."");
            }
            if (satellitesInView != Integer.parseInt(parts[3])) {
                throw new NmeaFormatException(""Different number of satellites in view."");
            }
        }
        final List<Info> info = new ArrayList<Info>();
        for (int i = 0; i < values.length; ++i) {
            parts = values[i].split("","");
            for (int j = 4; j < parts.length; j += 4) {
                if (info.size() < satellitesInView) {
                    String[] inf = new String[4];
                    inf[0] = parts[j + 0];
                    inf[1] = parts[j + 1];
                    inf[2] = parts[j + 2];
                    inf[3] = trim(parts[j + 3]);
                    info.add(parseInfo(inf));
                }
            }
        }
        if (info.size() != satellitesInView) {
            throw new NmeaFormatException(""Different satellite infos."");
        }
        return new Gsv(totalNumberOfMessages, satellitesInView, info.toArray(new Info[0]));
    }
",1
14966555,7,"    public void removeMidiInputListener(MidiInputListener mil) {
        for (int i = 0; i < milCount; i++) {
            if (mils[i] == mil) {
                mils[i] = mils[i + 1];
                mil = mils[i];
            }
        }
        milCount--;
    }
",1
17627330,7,"    public static final void iir_mem2(final float[] x, final int xs, final float[] den, final float[] y, final int ys, final int N, final int ord, final float[] mem) {
        int i, j;
        for (i = 0; i < N; i++) {
            y[ys + i] = x[xs + i] + mem[0];
            for (j = 0; j < ord - 1; j++) {
                mem[j] = mem[j + 1] - den[j + 1] * y[ys + i];
            }
            mem[ord - 1] = -den[ord] * y[ys + i];
        }
    }
",1
19786510,7,"    protected void renderMergedOutputModel(Map model, HttpServletRequest request, HttpServletResponse response) throws Exception {
        UtilsManager utilsManager = (UtilsManager) this.getApplicationContext().getBean(""utilsManager"");
        response.setContentType(""text/html"");
        if (request.isSecure()) {
            response.setHeader(""Pragma"", ""private"");
            response.setHeader(""Cache-Control"", ""private, must-revalidate"");
        } else {
            response.setHeader(""Cache-Control"", ""no-cache"");
        }
        PrintWriter out = response.getWriter();
        MessageSourceAccessor text = getMessageSourceAccessor();
        String mdl = (String) model.get(""mdl"");
        if (mdl.equals(""10"")) {
            Long number = (Long) model.get(""instancesNotMonitored"");
            out.println(text.getMessage(""instancesNotMonitored"", request.getLocale()) + "" "" + number);
        } else if (mdl.equals(""11"")) {
            response.setContentType(""text/html"");
            List data = (List) model.get(""data"");
            DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
            DateTime prevDet = null;
            Vector vData = new Vector();
            for (int i = 0; i < data.size(); i++) {
                OsmHistSysmark osmHistSysmark = (OsmHistSysmark) data.get(i);
                vData.add(osmHistSysmark.getId().getNumMark());
            }
            OsmSysmark osmSysmark = (OsmSysmark) model.get(""activeData"");
            if (osmSysmark != null) {
                vData.add(osmSysmark.getId().getNumMark());
                vData.add(osmSysmark.getId().getNumMark());
            }
            StringBuffer strTmp = new StringBuffer(""["");
            for (int i = 0; i < vData.size(); i++) {
                Object o = vData.elementAt(i);
                if (i > 0) strTmp.append("","").append(o); else strTmp.append(o);
            }
            strTmp.append(""]"");
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            String test = strTmp.toString();
            GlobalNote miNote = new GlobalNote(test);
            JSONObject json = JSONObject.fromObject(miNote);
            out.print(json);
        } else if (mdl.equals(""12"")) {
            response.setContentType(""text/plain"");
            Integer days = (Integer) model.get(""days"");
            List data = (List) model.get(""data"");
            String filter = (String) model.get(""filterSrv"");
            if (data.size() == 0) {
                DateTime dateIni = new DateTime(utilsManager.getActualTimestamp().getTime()).minusDays(days);
                Date dateFin = new Date(utilsManager.getActualTimestamp().getTime());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(dateIni)).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime now = new DateTime(utilsManager.getActualTimestamp().getTime());
                for (int i = 0; i < data.size(); i++) {
                    if (i == 0) {
                        Date date = ((Date) ((Object[]) data.get(i))[1]);
                        if (filter.equals(""1"")) {
                            DateMidnight todayMidnight = new DateMidnight(utilsManager.getActualTimestamp().getTime());
                            if (date.getTime() < todayMidnight.getMillis()) {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(todayMidnight.getMillis()))).append(((Object[]) data.get(i))[2]).toString());
                            } else {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(date.getTime()))).append(((Object[]) data.get(i))[2]).toString());
                            }
                        } else if (filter.equals(""7"")) {
                            DateMidnight todayMidnight = new DateMidnight(utilsManager.getActualTimestamp().getTime());
                            DateMidnight firstDayWeek = todayMidnight.minusDays(now.dayOfWeek().get() - 1);
                            if (date.getTime() < firstDayWeek.getMillis()) {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(firstDayWeek.getMillis()))).append(((Object[]) data.get(i))[2]).toString());
                            } else {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(date.getTime()))).append(((Object[]) data.get(i))[2]).toString());
                            }
                        } else if (filter.equals(""30"")) {
                            DateMidnight todayMidnight = new DateMidnight(utilsManager.getActualTimestamp().getTime());
                            DateMidnight firstDayMonth = todayMidnight.minusDays(now.dayOfMonth().get() - 1);
                            if (date.getTime() < firstDayMonth.getMillis()) {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(firstDayMonth.getMillis()))).append(((Object[]) data.get(i))[2]).toString());
                            } else {
                                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(date.getTime()))).append(((Object[]) data.get(i))[2]).toString());
                            }
                        }
                        continue;
                    }
                    if (i > 0) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(((Date) ((Object[]) data.get(i))[1]).getTime()).minusMillis(1))).append(((Object[]) data.get(i - 1))[2]).toString());
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(((Date) ((Object[]) data.get(i))[1]).getTime()))).append(((Object[]) data.get(i))[2]).toString());
                    }
                }
                if (data.size() > 0) {
                    Date date = ((Date) ((Object[]) data.get(data.size() - 1))[3]);
                    if (date.getTime() > now.getMillis()) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(utilsManager.getActualTimestamp().getTime()))).append(((Object[]) data.get(data.size() - 1))[2]).toString());
                    }
                }
            }
        } else if (mdl.equals(""15"")) {
            response.setContentType(""text/plain"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                Date dateIni = (Date) model.get(""dateIni"");
                Date dateFin = (Date) model.get(""dateFin"");
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = (Date) model.get(""dateIni"");
                for (int i = 0; i < data.size(); i++) {
                    OsmHistSysmark osmHistSysmark = (OsmHistSysmark) data.get(i);
                    dt = new DateTime(osmHistSysmark.getId().getDtiInimark().getTime());
                    if (i > 0) {
                        OsmHistSysmark prevOsmHistSysmark = (OsmHistSysmark) data.get(i - 1);
                        prevDet = new DateTime(dt.minusMillis(1));
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(prevDet)).append(prevOsmHistSysmark.getId().getNumMark()).toString());
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(osmHistSysmark.getId().getNumMark()).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(osmHistSysmark.getId().getNumMark()).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(osmHistSysmark.getId().getNumMark()).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date dateFin = (Date) model.get(""dateFin"");
                    OsmHistSysmark lastHistSysmark = (OsmHistSysmark) data.get(data.size() - 1);
                    OsmSysmark osmSysmark = (OsmSysmark) model.get(""activeData"");
                    String month = (String) model.get(""month"");
                    if (osmSysmark != null) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(osmSysmark.getId().getDtiMark().getTime()).minusMillis(1))).append(lastHistSysmark.getId().getNumMark()).toString());
                        if (osmSysmark.getId().getDtiMark().getTime() > dateFin.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(osmSysmark.getId().getNumMark()).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(osmSysmark.getId().getDtiMark()))).append(osmSysmark.getId().getNumMark()).toString());
                        }
                    }
                }
            }
        } else if (mdl.equals(""16"")) {
            response.setContentType(""text/plain"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                Date dateIni = (Date) model.get(""dateIni"");
                Date dateFin = (Date) model.get(""dateFin"");
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = (Date) model.get(""dateIni"");
                for (int i = 0; i < data.size(); i++) {
                    OsmHistSlamarks osmHistSlamark = (OsmHistSlamarks) data.get(i);
                    dt = new DateTime(osmHistSlamark.getId().getDtiInimark().getTime());
                    if (i > 0) {
                        OsmHistSlamarks prevOsmHistSlamark = (OsmHistSlamarks) data.get(i - 1);
                        prevDet = new DateTime(dt.minusMillis(1));
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(prevDet)).append(prevOsmHistSlamark.getId().getNumMark()).toString());
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(osmHistSlamark.getId().getNumMark()).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(osmHistSlamark.getId().getNumMark()).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(osmHistSlamark.getId().getNumMark()).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date dateFin = (Date) model.get(""dateFin"");
                    OsmHistSlamarks lastHistSlamark = (OsmHistSlamarks) data.get(data.size() - 1);
                    if (lastHistSlamark.getId().getDtiFinmark().getTime() > dateFin.getTime()) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(lastHistSlamark.getId().getNumMark()).toString());
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(lastHistSlamark.getId().getDtiFinmark().getTime()))).append(lastHistSlamark.getId().getNumMark()).toString());
                    }
                }
            }
        } else if (mdl.equals(""17"")) {
            response.setContentType(""text/plain"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                Date dateIni = (Date) model.get(""dateIni"");
                Date dateFin = (Date) model.get(""dateFin"");
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = (Date) model.get(""dateIni"");
                long time, prevTime;
                Integer value = null, prevValue = null;
                for (int i = 0; i < data.size(); i++) {
                    time = ((DatesValue) data.get(i)).getDateIni().getTime();
                    value = ((DatesValue) data.get(i)).getValue();
                    dt = new DateTime(time);
                    if (i > 0) {
                        prevValue = ((DatesValue) data.get(i - 1)).getValue();
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(time).minusMillis(1))).append(prevValue));
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(value).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date dateFin = (Date) model.get(""dateFin"");
                    DatesValue lastDatesValue = (DatesValue) data.get(data.size() - 1);
                    if (lastDatesValue.getDateIni().getTime() > dateFin.getTime()) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(lastDatesValue.getValue()).toString());
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(lastDatesValue.getDateFin().getTime()))).append(lastDatesValue.getValue()).toString());
                    }
                }
            }
        } else if (mdl.equals(""18"")) {
            response.setContentType(""text/plain"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                Date dateIni = (Date) model.get(""dateIni"");
                Date dateFin = (Date) model.get(""dateFin"");
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = (Date) model.get(""dateIni"");
                for (int i = 0; i < data.size(); i++) {
                    EventValue value = (EventValue) data.get(i);
                    dt = new DateTime(value.dtiInievent.getTime());
                    if (i > 0) {
                        EventValue prevEventValue = (EventValue) data.get(i - 1);
                        prevDet = new DateTime(dt.minusMillis(1));
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(prevDet)).append(prevEventValue.numValue).toString());
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(value.numValue).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value.numValue).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value.numValue).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date dateFin = (Date) model.get(""dateFin"");
                    Date now = new Date(utilsManager.getActualTimestamp().getTime());
                    EventValue lastEventValue = (EventValue) data.get(data.size() - 1);
                    if (dateFin.getTime() > now.getTime()) {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(now.getTime()))).append(lastEventValue.numValue).toString());
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(lastEventValue.numValue).toString());
                    }
                }
            }
        } else if (mdl.equals(""19"")) {
            response.setContentType(""text/plain"");
            Integer days = (Integer) model.get(""days"");
            List data = (List) model.get(""data"");
            if (data.size() == 0) {
                DateTime dateIni = new DateTime().minusDays(days);
                Date dateFin = new Date(utilsManager.getActualTimestamp().getTime());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(dateIni)).append(""-1"").toString());
                out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateFin.getTime()))).append(""-1"").toString());
            } else {
                DateTime dt = new DateTime(utilsManager.getActualTimestamp().getTime());
                DateTime prevDet = null;
                Date dateIni = new Date(new DateTime().minusDays(days).getMillis());
                for (int i = 0; i < data.size(); i++) {
                    EventValue value = (EventValue) data.get(i);
                    dt = new DateTime(value.dtiInievent.getTime());
                    if (i > 0) {
                        EventValue prevEventValue = (EventValue) data.get(i - 1);
                        prevDet = new DateTime(dt.minusMillis(1));
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(prevDet)).append(prevEventValue.numValue).toString());
                    }
                    if (i == 0) {
                        if (dt.getMillis() < dateIni.getTime()) {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(dateIni.getTime()))).append(value.numValue).toString());
                        } else {
                            out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value.numValue).toString());
                        }
                    } else {
                        out.println(new StringBuilder().append(StringUtil.formatDateTime(dt)).append(value.numValue).toString());
                    }
                }
                if (data != null && data.size() > 0) {
                    Date now = new Date(utilsManager.getActualTimestamp().getTime());
                    EventValue lastEventValue = (EventValue) data.get(data.size() - 1);
                    out.println(new StringBuilder().append(StringUtil.formatDateTime(new DateTime(now.getTime()))).append(lastEventValue.numValue).toString());
                }
            }
        } else if (mdl.equals(""20"")) {
            String id = request.getParameter(""id"");
            List data = (List) model.get(""data"");
            out.println(""<div id=\""pieChartWrapper"" + id + ""\"" class=\""pieChartWrapper\"" align=\""center\"">"");
            out.println(""</div>"");
            out.println(""<table id='mydata"" + id + ""' class=\""pieChart\"">"");
            out.println(""<tr style='height:15px'><th ></th><th></th><th></th></tr>"");
            List alarms = (List) model.get(""alarms"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            for (int i = 0; i < data.size(); i++) {
                long prcValue = (Long) ((Object[]) data.get(i))[0];
                StringBuffer tmp = new StringBuffer();
                OsmTypcriticity typCri = (OsmTypcriticity) hashOsmTypalarms.get((Integer) ((Object[]) data.get(i))[2]);
                tmp.append(""<tr><td >"").append(""<img src=\"""").append(request.getContextPath()).append(typCri.getPthLogocriticity()).append(""\""></td><td>"").append(decodeCriticity(data, i)).append(""</td><td style='width:40px' align='right'>"").append(prcValue).append("" %</td></tr>"");
                out.println(tmp.toString());
            }
            out.println(""</table>"");
            out.println(""<map id=\""mymap"" + id + ""\"" name=\""mymap"" + id + ""\"" class=\""piechartmap\"">"");
            out.println(""</map>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""pieCharts('prcCriSrv', "" + id + "");"");
            out.print(""</script>"");
        } else if (mdl.equals(""21"")) {
            String id = request.getParameter(""id"");
            Integer[] data = (Integer[]) model.get(""dataPrc"");
            int total = 0;
            out.println(""<div id=\""pieChartWrapper"" + id + ""\"" class=\""pieChartWrapper\"" align=\""center\"">"");
            out.println(""</div>"");
            out.println(""<table id='mydata"" + id + ""' class=\""pieChart\"">"");
            out.println(""<tr style='height:15px'><th ></th><th></th><th></th></tr>"");
            for (int i = 0; i < data.length; i++) {
                total += data[i];
            }
            for (int i = 0; i < data.length; i++) {
                int value = data[i];
                long prcValue = Math.round(100 * value / total);
                StringBuffer tmp = new StringBuffer();
                tmp.append(""<tr><td >"").append(""<img src=\"""").append(request.getContextPath()).append(i == 0 ? ""/images/logoalmalr.png"" : ""/images/logoalminfo.png"").append(""\""/></td><td>"").append(i == 0 ? text.getMessage(""graphs.NotAvailable"") : text.getMessage(""graphs.Available"")).append(""</td><td style='width:40px' align='right'>"").append(prcValue).append("" %</td></tr>"");
                out.println(tmp.toString());
            }
            out.println(""</table>"");
            out.println(""<map id=\""mymap"" + id + ""\"" name=\""mymap"" + id + ""\"" class=\""piechartmap\"">"");
            out.println(""</map>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""pieCharts('prcAvaIns',"" + id + "");"");
            out.print(""</script>"");
        } else if (mdl.equals(""22"")) {
            String id = request.getParameter(""id"");
            List data = (List) model.get(""data"");
            double total = 0;
            out.println(""<div id=\""pieChartWrapper"" + id + ""\"" class=\""pieChartWrapper\"" align=\""center\"">"");
            out.println(""</div>"");
            out.println(""<table id='mydata"" + id + ""' class=\""pieChart\"">"");
            out.println(""<tr style='height:15px'><th></th><th></th><th></th></tr>"");
            for (int i = 0; i < data.size(); i++) {
                total += (Long) ((Object[]) data.get(i))[0];
            }
            List alarms = (List) model.get(""alarms"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            for (int i = 0; i < data.size(); i++) {
                Long value = (Long) ((Object[]) data.get(i))[0];
                long prcValue = Math.round(100 * value / total);
                StringBuffer tmp = new StringBuffer();
                OsmTypcriticity typCri = (OsmTypcriticity) hashOsmTypalarms.get((Integer) ((Object[]) data.get(i))[2]);
                tmp.append(""<tr><td >"").append(""<img src=\"""").append(request.getContextPath()).append(typCri.getPthLogocriticity()).append(""\""/></td><td>"").append(decodeCriticity(data, i)).append(""</td><td style='width:40px' align='right'>"").append(prcValue).append("" %</td></tr>"");
                out.println(tmp.toString());
            }
            out.println(""</table>"");
            out.println(""<map id=\""mymap"" + id + ""\"" name=\""mymap"" + id + ""\"" class=\""piechartmap\"">"");
            out.println(""</map>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""pieCharts('prcCriIns', "" + id + "");"");
            out.print(""</script>"");
        } else if (mdl.equals(""23"")) {
            out.println(""<select name=\""users\"" id=\""users\"" class=\""form OsmMediumCbo\"">"");
            List users = (List) model.get(""users"");
            if (users.size() > 0) {
                out.println(""<option value='ALL'>ALL</option>"");
            }
            for (int i = 0; i < users.size(); i++) {
                OsmUser osmUser = (OsmUser) users.get(i);
                out.println(new StringBuilder().append(""<option value=\'"").append(osmUser.getIdnUser()).append(""'>"").append(osmUser.getIdnUser()).append(""</option>"").toString());
            }
            out.println(""</select>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""testUsers();"");
            out.print(""</script>"");
        } else if (mdl.equals(""24"")) {
            TypInstancesInfo[] info = (TypInstancesInfo[]) model.get(""info"");
            out.println(""<table border=\""1\"">"");
            out.print(""<tr>"");
            out.println(""<th>"");
            out.print(""Type"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""#"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""OK"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""WR"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""CR"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""ER"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""UP"");
            out.println(""</th>"");
            out.println(""<th>"");
            out.print(""DOWN"");
            out.println(""</th>"");
            out.println(""</tr>"");
            for (int i = 0; i < info.length; i++) {
                out.println(""<tr>"");
                TypInstancesInfo typInstancesInfo = info[i];
                out.print(""<td>"");
                out.print(typInstancesInfo.getTypInstance());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getTotal());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getOK());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getWR());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getCR());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getER());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getAva());
                out.print(""</td>"");
                out.print(""<td>"");
                out.print(typInstancesInfo.getNotAva());
                out.print(""</td>"");
                out.println(""</tr>"");
            }
            out.println(""</table>"");
        } else if (mdl.equals(""28"")) {
            String id = request.getParameter(""id"");
            Integer[] data = (Integer[]) model.get(""dataPrc"");
            int total = 0;
            out.println(""<div id=\""pieChartWrapper"" + id + ""\"" class=\""pieChartWrapper\"" align=\""center\"">"");
            out.println(""</div>"");
            out.println(""<table id='mydata"" + id + ""' class=\""pieChart\"">"");
            out.println(""<tr style='height:15px'><th ></th><th></th><th></th></tr>"");
            for (int i = 0; i < data.length; i++) {
                total += data[i];
            }
            for (int i = 0; i < data.length; i++) {
                int value = data[i];
                long prcValue = Math.round(100 * value / total);
                StringBuffer tmp = new StringBuffer();
                tmp.append(""<tr><td >"").append(""<img src=\"""").append(request.getContextPath()).append(i == 0 ? ""/images/logoalmalr.png"" : ""/images/logoalminfo.png"").append(""\""/></td><td>"").append(i == 0 ? text.getMessage(""graphs.NotAvailable"") : text.getMessage(""graphs.Available"")).append(""</td><td style='width:40px' align='right'>"").append(prcValue).append("" %</td></tr>"");
                out.println(tmp.toString());
            }
            out.println(""</table>"");
            out.println(""<map id=\""mymap"" + id + ""\"" name=\""mymap"" + id + ""\"" class=\""piechartmap\"">"");
            out.println(""</map>"");
            out.println(""<script type=\""text/javascript\"">"");
            out.println(""pieCharts('prcAvaSrv',"" + id + "");"");
            out.print(""</script>"");
        } else if (mdl.equals(""100"")) {
            StringBuilder json = new StringBuilder(""[{data:["");
            List data = (List) model.get(""data"");
            for (int i = 0; i < data.size(); i++) {
                EventValue value = (EventValue) data.get(i);
                if (i > 1) {
                    json.append(""["").append(((EventValue) data.get(i - 1)).dtiInievent.getTime()).append("","").append(value.numValue).append(""],"");
                }
                json.append(""["").append(value.dtiInievent.getTime()).append("","").append(value.numValue).append(""],"");
            }
            List activeData = (List) model.get(""activeData"");
            for (int i = 0; i < activeData.size(); i++) {
                OsmActiveevent osmActiveevent = (OsmActiveevent) activeData.get(i);
                json.append(""["").append(osmActiveevent.getDtiInievent().getTime()).append("","").append(osmActiveevent.getNumValue()).append(""],"");
            }
            json.deleteCharAt(json.length() - 1);
            json.append(""]}]"");
            out.print(json.toString());
        } else if (mdl.equals(""50"")) {
            Float[] data = (Float[]) model.get(""dataPrc"");
            float total = 0;
            for (int i = 0; i < data.length; i++) {
                total += data[i];
            }
            StringBuilder tmp = new StringBuilder();
            double noAva = 100 * data[0] / total;
            noAva = noAva > 0 ? Math.floor(noAva * 100) / 100.0 : Math.ceil(noAva * 100) / 100.0;
            double ava = 100 * data[1] / total;
            ava = ava > 0 ? Math.floor(ava * 100) / 100.0 : Math.ceil(ava * 100) / 100.0;
            if (ava == 100) {
                ava = 99.9;
                noAva = 0.1;
            }
            if (noAva == 100) {
                noAva = 99.9;
                ava = 0.1;
            }
            tmp.append(""[{ label: \""\"",  data:"").append(noAva).append("", color:'#f00'},{ label: \""\"",  data:"").append(ava).append("", color:'#0f0'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""51"")) {
            List data = (List) model.get(""data"");
            List alarms = (List) model.get(""alarms"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            double[] values = new double[4];
            for (int i = 0; i < data.size(); i++) {
                OsmTypcriticity typCri = (OsmTypcriticity) hashOsmTypalarms.get((Integer) ((Object[]) data.get(i))[2]);
                double prcValue = (Double) ((Object[]) data.get(i))[0];
                prcValue = prcValue > 0 ? Math.floor(prcValue * 100) / 100.0 : Math.ceil(prcValue * 100) / 100.0;
                if (typCri.getTypCriticity() == 0) values[0] = prcValue; else if (typCri.getTypCriticity() == 1) values[1] = prcValue; else if (typCri.getTypCriticity() == 2) values[2] = prcValue; else if (typCri.getTypCriticity() == 99) values[3] = prcValue;
            }
            StringBuilder tmp = new StringBuilder();
            if (values[0] == 100) {
                values[0] = 99.9;
                values[1] = 0.1;
                values[2] = 0;
                values[3] = 0;
            }
            if (values[1] == 100) {
                values[1] = 99.9;
                values[0] = 0.1;
                values[2] = 0;
                values[3] = 0;
            }
            if (values[2] == 100) {
                values[2] = 99.9;
                values[0] = 0.1;
                values[1] = 0;
                values[3] = 0;
            }
            if (values[3] == 100) {
                values[3] = 99.9;
                values[0] = 0.1;
                values[1] = 0;
                values[2] = 0;
            }
            tmp.append(""[{ label: \""\"",  data:"").append(values[0]).append("", color:'#0f0'},{ label: \""\"",  data:"").append(values[1]).append("", color:'#fd0'},{ label: \""\"",  data:"").append(values[2]).append("", color:'#f00'},{ label: \""\"",  data:"").append(values[3]).append("", color:'#00f'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""52"")) {
            String id = request.getParameter(""id"");
            Integer[] data = (Integer[]) model.get(""dataPrc"");
            int total = 0;
            for (int i = 0; i < data.length; i++) {
                total += data[i];
            }
            StringBuilder tmp = new StringBuilder();
            double noAva = 100 * data[0] / total;
            noAva = noAva > 0 ? Math.floor(noAva * 100) / 100.0 : Math.ceil(noAva * 100) / 100.0;
            double ava = 100 * data[1] / total;
            ava = ava > 0 ? Math.floor(ava * 100) / 100.0 : Math.ceil(ava * 100) / 100.0;
            if (ava == 100) {
                ava = 99.9;
                noAva = 0.1;
            }
            if (noAva == 100) {
                noAva = 99.9;
                ava = 0.1;
            }
            tmp.append(""[{ label: \""\"",  data:"").append(noAva).append("", color:'#f00'},{ label: \""\"",  data:"").append(ava).append("", color:'#0f0'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""53"")) {
            List data = (List) model.get(""data"");
            List alarms = (List) model.get(""alarms"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            double[] values = new double[4];
            for (int i = 0; i < data.size(); i++) {
                OsmTypcriticity typCri = (OsmTypcriticity) hashOsmTypalarms.get((Integer) ((Object[]) data.get(i))[2]);
                double prcValue = (Double) ((Object[]) data.get(i))[0];
                prcValue = prcValue > 0 ? Math.floor(prcValue * 100) / 100.0 : Math.ceil(prcValue * 100) / 100.0;
                if (typCri.getTypCriticity() == 0) values[0] = prcValue; else if (typCri.getTypCriticity() == 1) values[1] = prcValue; else if (typCri.getTypCriticity() == 2) values[2] = prcValue; else if (typCri.getTypCriticity() == 99) values[3] = prcValue;
            }
            StringBuilder tmp = new StringBuilder();
            if (values[0] == 100) {
                values[0] = 99.9;
                values[1] = 0.1;
                values[2] = 0;
                values[3] = 0;
            }
            if (values[1] == 100) {
                values[1] = 99.9;
                values[0] = 0.1;
                values[2] = 0;
                values[3] = 0;
            }
            if (values[2] == 100) {
                values[2] = 99.9;
                values[0] = 0.1;
                values[1] = 0;
                values[3] = 0;
            }
            if (values[3] == 100) {
                values[3] = 99.9;
                values[0] = 0.1;
                values[1] = 0;
                values[2] = 0;
            }
            tmp.append(""[{ label: \""\"",  data:"").append(values[0]).append("", color:'#0f0'},{ label: \""\"",  data:"").append(values[1]).append("", color:'#fd0'},{ label: \""\"",  data:"").append(values[2]).append("", color:'#f00'},{ label: \""\"",  data:"").append(values[3]).append("", color:'#00f'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""54"")) {
            List data = (List) model.get(""data"");
            int[] values = new int[4];
            int max = 0;
            int step = 0;
            for (int i = 0; i < data.size(); i++) {
                if (((Criticity) data.get(i)).getCriticty() == 0) {
                    values[0] = ((Criticity) data.get(i)).getValue();
                } else if (((Criticity) data.get(i)).getCriticty() == 1) {
                    values[1] = ((Criticity) data.get(i)).getValue();
                } else if (((Criticity) data.get(i)).getCriticty() == 2) {
                    values[2] = ((Criticity) data.get(i)).getValue();
                } else if (((Criticity) data.get(i)).getCriticty() == 99) {
                    values[3] = ((Criticity) data.get(i)).getValue();
                }
                if (((Criticity) data.get(i)).getValue() > max) {
                    max = ((Criticity) data.get(i)).getValue();
                }
            }
            if (max > 0) {
                step = max / 4;
            }
            int total = (step * 5) > max ? step * 5 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#0f0'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#fc7'},"").append("" {label:'', data:[[3,"").append(values[2]).append(""]], color:'#f00'},"").append("" {label:'', data:[[4,"").append(values[3]).append(""]], color:'#888'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""55"")) {
            List alarms = (List) model.get(""alarms"");
            Integer[] states = (Integer[]) model.get(""states"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            int[] values = new int[4];
            int max = 0;
            int step = 1;
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            OsmTypcriticity osmTypcriticity;
            for (int i = 0; i < states.length; i += 2) {
                osmTypcriticity = (OsmTypcriticity) hashOsmTypalarms.get(states[i]);
                if (osmTypcriticity.getTypCriticity() == 0) {
                    values[0] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 1) {
                    values[1] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 2) {
                    values[2] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 99) {
                    values[3] = states[i + 1];
                }
                if (states[i + 1] > max) {
                    max = states[i + 1];
                }
            }
            if (max > 0) {
                step = max / 4;
            }
            int total = (step * 5) > max ? step * 5 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#0f0'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#fc7'},"").append("" {label:'', data:[[3,"").append(values[2]).append(""]], color:'#f00'},"").append("" {label:'', data:[[4,"").append(values[3]).append(""]], color:'#888'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""56"")) {
            List states = (List) model.get(""states"");
            long[] values = new long[2];
            long max = 0;
            long step = 1;
            for (int i = 0; i < states.size(); i++) {
                long _value = (Long) ((Object[]) states.get(i))[0];
                if (((Integer) ((Object[]) states.get(i))[1]) == 0) {
                    values[0] = _value;
                } else {
                    values[1] = _value;
                }
                if (_value > max) {
                    max = _value;
                }
            }
            if (max > 0) {
                step = max / 2;
            }
            long total = (step * 3) > max ? step * 3 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#f00'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#0f0'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""57"")) {
            List alarms = (List) model.get(""alarms"");
            Integer[] states = (Integer[]) model.get(""states"");
            HashMap hashOsmTypalarms = new HashMap(alarms.size());
            int[] values = new int[4];
            int max = 0;
            int step = 1;
            for (int i = 0; i < alarms.size(); i++) {
                hashOsmTypalarms.put(((OsmTypcriticity) alarms.get(i)).getTypCriticity(), alarms.get(i));
            }
            OsmTypcriticity osmTypcriticity;
            for (int i = 0; i < states.length; i += 2) {
                osmTypcriticity = (OsmTypcriticity) hashOsmTypalarms.get(states[i]);
                if (osmTypcriticity.getTypCriticity() == 0) {
                    values[0] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 1) {
                    values[1] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 2) {
                    values[2] = states[i + 1];
                } else if (osmTypcriticity.getTypCriticity() == 99) {
                    values[3] = states[i + 1];
                }
                if (states[i + 1] > max) {
                    max = states[i + 1];
                }
            }
            if (max > 0) {
                step = max / 4;
            }
            int total = (step * 5) > max ? step * 5 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#0f0'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#fc7'},"").append("" {label:'', data:[[3,"").append(values[2]).append(""]], color:'#f00'},"").append("" {label:'', data:[[4,"").append(values[3]).append(""]], color:'#888'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""58"")) {
            List states = (List) model.get(""states"");
            long[] values = new long[2];
            long max = 0;
            long step = 1;
            for (int i = 0; i < states.size(); i++) {
                long _value = (Long) ((Object[]) states.get(i))[0];
                if (((Integer) ((Object[]) states.get(i))[1]) == 0) {
                    values[0] = _value;
                } else {
                    values[1] = _value;
                }
                if (_value > max) {
                    max = _value;
                }
            }
            if (max > 0) {
                step = max / 2;
            }
            long total = (step * 3) > max ? step * 3 : max;
            StringBuilder tmp = new StringBuilder();
            tmp.append(""[{label:'', data:[[1,"").append(values[0]).append(""]], color:'#f00'},"").append("" {label:'', data:[[2,"").append(values[1]).append(""]], color:'#0f0'}]"");
            out.print(tmp.toString());
        } else if (mdl.equals(""59"")) {
            String mib = (String) model.get(""mib"");
            out.print(""{\""mib\"":\"""" + (mib == null ? """" : mib) + ""\""}"");
        } else if (mdl.equals(""60"")) {
            List mibs = (List) model.get(""mibs"");
            if (mibs.size() > 0) {
                StringBuilder str = new StringBuilder(""{\""mibs\"":["");
                for (int i = 0; i < mibs.size(); i++) {
                    String data = (String) mibs.get(i);
                    if (i == 0) {
                        str.append(""{\""mib\"":\"""").append(data).append(""\""}"");
                    } else {
                        str.append("",{\""mib\"":\"""").append(data).append(""\""}"");
                    }
                }
                str.append(""]}"");
                out.print(str.toString());
            } else {
                out.print(""{\""mibs\"":[]}"");
            }
        } else if (mdl.equals(""61"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            Boolean ok = (Boolean) model.get(""ok"");
            String error = (String) model.get(""error"");
            TestGenericErrors test = new TestGenericErrors(ok, new String[] { error });
            JSONObject json = JSONObject.fromObject(test);
            out.print(json);
        } else if (mdl.equals(""62"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            Boolean exists = (Boolean) model.get(""exists"");
            TestGeneric test = new TestGeneric(exists);
            JSONObject json = JSONObject.fromObject(test);
            out.print(json);
        } else if (mdl.equals(""63"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            Boolean isHoliday = (Boolean) model.get(""isHoliday"");
            TestGeneric test = new TestGeneric(isHoliday);
            JSONObject json = JSONObject.fromObject(test);
            out.print(json);
        } else if (mdl.equals(""64"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            List typInstances = (List) model.get(""typInstances"");
            List[] instances = (List[]) model.get(""instances"");
            String id = (String) model.get(""id"");
            StringBuilder str = new StringBuilder();
            str.append(""{\""id\"":\"""").append(id).append(""_Osmius\"",\""name\"":\""Osmius\"",\""children\"":["");
            for (int i = 0; i < typInstances.size(); i++) {
                OsmTypinstance osmTypinstance = (OsmTypinstance) typInstances.get(i);
                if (i > 0) {
                    str.append("","");
                }
                str.append(""{\""id\"":\"""").append(id).append(""_typ_"").append(osmTypinstance.getTypInstance()).append(""\"","");
                str.append(""\""name\"":\"""").append(osmTypinstance.getTypInstance()).append(""\"","");
                str.append(""\""data\"":{"");
                str.append(""\""description\"":\"""").append(osmTypinstance.getDesTypinstance()).append(""\"","");
                str.append(""\""typInst\"":\"""").append(osmTypinstance.getTypInstance()).append(""\"","");
                str.append(""\""imgIndex\"":\"""").append(osmTypinstance.getTypInstance()).append(""\"","");
                str.append(""\""img\"":\"""").append(osmTypinstance.getPthLogoinstance()).append(""\"""");
                str.append(""}, \""children\"":["");
                List tmpInst = instances[i];
                for (int j = 0; j < tmpInst.size(); j++) {
                    OsmInstance osmInstance = (OsmInstance) tmpInst.get(j);
                    if (j > 0) {
                        str.append("","");
                    }
                    str.append(""{\""id\"":\"""").append(id).append(""_"").append(osmInstance.getIdnInstance()).append(""\"","");
                    str.append(""\""name\"":\"""").append(osmInstance.getIdnInstance()).append(""\"","");
                    str.append(""\""data\"":{"");
                    str.append(""\""description\"":\"""").append(osmInstance.getDesInstance()).append(""\"","");
                    str.append(""\""severity\"":\"""").append(osmInstance.getOsmTypcriticity().getTypCriticity()).append(""\"","");
                    str.append(""\""availability\"":\"""").append(osmInstance.getIndAvailability()).append(""\"""");
                    str.append(""},\""children\"":[]}"");
                }
                str.append(""]}"");
            }
            str.append(""],\""data\"":\""\""}"");
            out.print(str.toString());
        } else if (mdl.equals(""65"") || mdl.equals(""66"") || mdl.equals(""67"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            String json = (String) model.get(""json"");
            if (json != null) out.print(json);
        } else if (mdl.equals(""70"") || mdl.equals(""74"") || mdl.equals(""75"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            String json = (String) model.get(""JSONInstances"");
            if (json != null) out.print(json);
        } else if (mdl.equals(""71"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            List acte = (List) model.get(""activeevents"");
            List trape = (List) model.get(""trapactiveevents"");
            StringBuilder json = new StringBuilder(""{ \""events\"":["");
            for (int i = 0; i < acte.size(); i++) {
                OsmTypevent obj = (OsmTypevent) acte.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typEvent\"":\"""").append(obj.getId().getTypEvent()).append(""\"",\""desEvent\"":\"""").append(obj.getDesTypevent()).append(""\"",\""defGraph\"":\"""").append(obj.getDefGraph()).append(""\""}"");
            }
            json.append(""],\""traps\"":["");
            for (int i = 0; i < trape.size(); i++) {
                String[] obj = (String[]) trape.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typEvent\"":\"""").append(obj[0]).append(""\"",\""desEvent\"":\"""").append(obj[1]).append(""\""}"");
            }
            json.append(""]}"");
            out.print(json.toString());
        } else if (mdl.equals(""72"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            List typInstances = (List) model.get(""typInstances"");
            StringBuilder json = new StringBuilder();
            json.append(""["");
            for (int i = 0; i < typInstances.size(); i++) {
                OsmTypinstance osmTypinstance = (OsmTypinstance) typInstances.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typInstance\"":\"""").append(osmTypinstance.getTypInstance()).append(""\"",\""desTypinstance\"":\"""").append(osmTypinstance.getDesTypinstance()).append(""\""}"");
            }
            json.append(""]"");
            out.print(json.toString());
        } else if (mdl.equals(""73"")) {
            response.setContentType(""application/json"");
            response.setHeader(""Cache-Control"", ""no-cache"");
            List typEvents = (List) model.get(""typEvents"");
            List trapEvents = (List) model.get(""trapEvents"");
            StringBuilder json = new StringBuilder(""{ \""events\"":["");
            for (int i = 0; i < typEvents.size(); i++) {
                OsmTypevent obj = (OsmTypevent) typEvents.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typEvent\"":\"""").append(obj.getId().getTypEvent()).append(""\"",\""desEvent\"":\"""").append(obj.getDesTypevent()).append(""\""}"");
            }
            json.append(""],\""traps\"":["");
            for (int i = 0; i < trapEvents.size(); i++) {
                String[] obj = (String[]) trapEvents.get(i);
                if (i > 0) {
                    json.append("","");
                }
                json.append(""{\""typEvent\"":\"""").append(obj[0]).append(""\"",\""desEvent\"":\"""").append(obj[1]).append(""\""}"");
            }
            json.append(""]}"");
            out.print(json.toString());
        }
    }
",1
18488781,7,"    public short[] createSamples(byte[] samples) {
        short[] sampleShort = new short[samples.length / 2];
        byte[] temp = new byte[2];
        for (int i = 0, j = 0; i < samples.length; i += 2, j++) {
            temp[0] = samples[i];
            temp[1] = samples[i + 1];
            sampleShort[j] = TypeConverter.byteArrayToShort(temp);
        }
        return sampleShort;
    }
",1
19840019,7,"    public void removePoint() {
        Integer index = datapanel.getPointChosenIndex();
        if (index != null) {
            int newsize = xphase.length - 1;
            int iindex = index.intValue();
            double[] oldxphase = xphase;
            double[] oldyvalues = currentyvalues;
            double[] tempxdata = new double[newsize];
            double[] tempdata = new double[newsize];
            for (int i = 0; i < newsize; i++) {
                if (i < iindex) {
                    tempxdata[i] = oldxphase[i];
                    tempdata[i] = oldyvalues[i];
                } else {
                    tempxdata[i] = oldxphase[i + 1];
                    tempdata[i] = oldyvalues[i + 1];
                }
            }
            xphase = tempxdata;
            currentyvalues = tempdata;
            dataHasBeenFit = false;
            plotData();
        }
    }
",1
3283709,7,"    protected void deleteVertex(int index) {
        Vector3D deleted = v[index];
        for (int i = index; i < v.length - 1; i++) {
            v[i] = v[i + 1];
        }
        v[v.length - 1] = deleted;
        numVertices--;
    }
",1
16653081,7,"    public void moveEvent(ScrEvent event, int newTime) {
        int index = indexOf(event);
        int newIndex = getIndexAfter(newTime);
        if (newIndex == NO_SUCH_EVENT) newIndex = events_fill_p - 1; else if (event.getTime() <= newTime) newIndex -= 1;
        if (index == NO_SUCH_EVENT) {
            System.err.println(""no such event error"");
            for (int i = 0; i < length(); i++) {
                System.err.println(""#"" + i + "" t "" + getEventAt(i).getTime() + "" p "" + getEventAt(i).getPitch());
            }
            return;
        }
        if (index == EMPTY_COLLECTION) index = 0;
        event.setTime(newTime);
        args.clear();
        args.addInt(index);
        args.addInt(event.getTime());
        try {
            send(FtsSymbol.get(""change_time""), args);
        } catch (IOException e) {
            System.err.println(""FtsObjectWithEditor: I/O Error sending change_time Message!"");
            e.printStackTrace();
        }
        if (index < newIndex) {
            for (int i = index; i < newIndex; i++) {
                events[i] = events[i + 1];
            }
        } else {
            for (int i = index; i > newIndex; i--) {
                events[i] = events[i - 1];
            }
            events[newIndex] = event;
        }
        events[newIndex] = event;
        notifyObjectMoved(event, index, newIndex);
    }
",1
352574,7,"    public void moveToEnd(int loc) {
        card temp = new card();
        temp.m_type = m_data[loc].m_type;
        temp.m_color = m_data[loc].m_color;
        for (int r = loc; r < m_length - 1; ++r) {
            m_data[r] = m_data[r + 1];
        }
        m_data[m_data.length - 1].m_type = temp.m_type;
        m_data[m_data.length - 1].m_color = temp.m_color;
        m_data[m_data.length - 1].m_quantity = 0;
    }
",1
5017608,7,"    public synchronized Object get_event() {
        if (size == 0) return null;
        Object event = queue[0];
        size--;
        for (int i = 0; i < size; i++) queue[i] = queue[i + 1];
        queue[size] = null;
        return event;
    }
",0
7785431,7,"    private void _swapInt() {
        byte i = event[index];
        sevent[index] = event[index + 3];
        sevent[index + 3] = i;
        i = event[index + 1];
        sevent[index + 1] = event[index + 2];
        sevent[index + 2] = i;
        index += 4;
    }
",1
17771635,7,"    public void plot() {
        cat.debug(""filename to read: "" + filename);
        if (csvTable == null) csvTable = new CSVTable(filename, ""/csv"");
        if (chart == null) chart = new ServerChart();
        PropertyResourceBundle rb = (PropertyResourceBundle) PropertyResourceBundle.getBundle(props);
        Enumeration keys = rb.getKeys();
        while (keys.hasMoreElements()) {
            String prop = (String) keys.nextElement();
            String value = rb.getString(prop);
            gov.lanl.Utility.BeanProperties.setProperty(chart, prop, value);
        }
        String[] labels = csvTable.getLabels();
        if (labels.length == 0) {
            cat.warn(""NO Data read from "" + filename + ""!"");
            return;
        }
        String[] x = csvTable.getValues(labels[0]);
        double[] dat = new double[x.length];
        java.text.SimpleDateFormat df = new java.text.SimpleDateFormat(""MM/dd/yyyy"");
        java.text.SimpleDateFormat dform = new java.text.SimpleDateFormat(""MM/dd"");
        JCAxis xAxis = chart.getChartArea().getXAxis(0);
        xAxis.setTimeUnit(JCAxis.MONTHS);
        xAxis.setAnnotationMethod(JCAxis.TIME_LABELS);
        chart.getLegend().setVisible(true);
        JCAxis yAxis = chart.getChartArea().getYAxis(0);
        yAxis.getTitle().setPlacement(JCLegend.WEST);
        yAxis.getTitle().setRotation(ChartText.DEG_270);
        try {
            for (int k = 0; k < x.length; k++) {
                Date d = df.parse(x[k]);
                if (k == 0) xAxis.setTimeBase(d);
                dat[k] = xAxis.dateToValue(d);
            }
            double[][] xx = new double[1][dat.length];
            xx[0] = dat;
            String[] labs = new String[first];
            double[][] zz = new double[first][dat.length];
            for (int i = 0; i < first; i++) {
                String[] v = csvTable.getValues(labels[i + 1]);
                zz[i] = new double[v.length];
                labs[i] = labels[i + 1];
                for (int k = 0; k < v.length; k++) {
                    zz[i][k] = new Double(v[k]).doubleValue();
                }
            }
            ChartDataView dataView = chart.getDataView(0);
            dataView.setDataSource(new JCDefaultDataSource(xx, zz, null, labs, """"));
            dataView.setChartType(JCChart.BAR);
            ((JCBarChartFormat) dataView.getChartFormat()).setClusterWidth(barWidth);
            double[][] yy = new double[labels.length - first - 1][];
            labs = new String[labels.length - first - 1];
            for (int i = first + 1; i < labels.length; i++) {
                String[] v = csvTable.getValues(labels[i]);
                labs[i - first - 1] = labels[i];
                yy[i - first - 1] = new double[v.length];
                for (int k = 0; k < v.length; k++) {
                    double f = new Double(v[k]).doubleValue();
                    yy[i - first - 1][k] = f;
                }
            }
            chart.addDataView(1);
            dataView = chart.getDataView(1);
            dataView.setDataSource(new JCDefaultDataSource(xx, yy, null, labs, """"));
            if (plotType.equals(""line"")) dataView.setChartType(JCChart.PLOT); else dataView.setChartType(JCChart.STACKING_AREA);
        } catch (Exception e) {
            cat.error(""Plot failed due to :"" + e, e);
        }
    }
",0
1239924,7,"    private static String[] deriveShortCuts(int index, String[] words) {
        String base = words[index];
        int len = base.length();
        String[] res = new String[6];
        int w = 0;
        char c0 = base.charAt(0);
        if (Character.isUpperCase(c0)) {
            String s = base.toLowerCase();
            if (!Naming.isKeyword(s)) {
                res[w++] = s;
            }
        }
        if (len > 3) {
            char c1 = base.charAt(1);
            if (!isVowel(c1)) {
                String s = base.substring(0, 2).toLowerCase();
                if (!Naming.isKeyword(s)) {
                    res[w++] = s;
                }
            }
            if (!isVowel(c0)) {
                String bs = removeVowels(base);
                if (bs.length() == 2 || (bs.length() == 3 && len > 4)) {
                    String s = bs.toLowerCase();
                    if (!Naming.isKeyword(s)) {
                        res[w++] = s;
                    }
                }
            }
            if (len > 4) {
                char c2 = base.charAt(2);
                if (!isVowel(c2)) {
                    String s = base.substring(0, 3).toLowerCase();
                    if (!Naming.isKeyword(s)) {
                        res[w++] = s;
                    }
                }
            }
        }
        char lc0 = Character.toLowerCase(c0);
        if (len > 1 || Character.isUpperCase(c0)) {
            String s = """" + lc0;
            if (!Naming.isKeyword(s)) {
                res[w++] = s;
            }
        }
        for (int i = 1; i < w; i += 1) {
            String x = res[i];
            int j = i - 1;
            int xlen = x.length();
            while (j >= 0 && res[j].length() > xlen) {
                res[j + 1] = res[j];
                j -= 1;
            }
            if (j >= 0 && res[j].equals(x)) {
                for (j += 1, w -= 1, i -= 1; j < len; j += 1) {
                    res[j] = res[j + 1];
                }
            } else {
                res[j + 1] = x;
            }
        }
        String[] result = new String[w];
        for (int i = 0; i < w; i += 1) {
            result[i] = res[i];
        }
        return result;
    }
",0
23246356,7,"        private static void rotate(byte[] key) {
            byte[] x = new byte[64];
            System.arraycopy(key, 0, x, 0, x.length);
            for (int i = 0; i < 55; i++) {
                x[i] = x[i + 1];
            }
            x[27] = key[0];
            x[55] = key[28];
            System.arraycopy(x, 0, key, 0, key.length);
        }
",0
34923,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
18175273,7,"    public void setPalette(IPalette palette) {
        if (m_src_index_color_raster == null) {
            throw new IllegalStateException(""this image is not support index color model !"");
        }
        if (palette != null) {
            try {
                byte[] colors = palette.getIndexColors();
                int color_count = palette.getIndexColorCount();
                int transparent_color_index = palette.getTransparentColorIndex();
                byte[] ra = new byte[color_count];
                byte[] ga = new byte[color_count];
                byte[] ba = new byte[color_count];
                byte[] ralpha = new byte[color_count];
                for (int i = 0, j = 0; (i < colors.length) && (j < color_count); i += 3, ++j) {
                    ra[j] = colors[i];
                    ga[j] = colors[i + 1];
                    ba[j] = colors[i + 2];
                    ralpha[j] = (byte) ((j == transparent_color_index) ? 0 : 255);
                }
                IndexColorModel icm = new IndexColorModel(8, color_count, ra, ga, ba, ralpha);
                BufferedImage new_image = new BufferedImage(icm, m_src_index_color_raster, icm.isAlphaPremultiplied(), null);
                m_image = createBuffer(new_image);
            } catch (Exception exp) {
                exp.printStackTrace();
            }
        }
    }
",1
5626269,7,"    private HashMap getPhrasesForDictionary(String str) {
        String[] buffer = new String[m_MaxPhraseLength];
        HashMap hash = new HashMap();
        StringTokenizer tok = new StringTokenizer(str, ""\n"");
        while (tok.hasMoreTokens()) {
            String phrase = tok.nextToken();
            int numSeen = 0;
            StringTokenizer wordTok = new StringTokenizer(phrase, "" "");
            while (wordTok.hasMoreTokens()) {
                String word = wordTok.nextToken();
                for (int i = 0; i < m_MaxPhraseLength - 1; i++) {
                    buffer[i] = buffer[i + 1];
                }
                buffer[m_MaxPhraseLength - 1] = word;
                numSeen++;
                if (numSeen > m_MaxPhraseLength) {
                    numSeen = m_MaxPhraseLength;
                }
                if (m_Stopwords.isStopword(buffer[m_MaxPhraseLength - 1])) {
                    continue;
                }
                StringBuffer phraseBuffer = new StringBuffer();
                for (int i = 1; i <= numSeen; i++) {
                    if (i > 1) {
                        phraseBuffer.insert(0, ' ');
                    }
                    phraseBuffer.insert(0, buffer[m_MaxPhraseLength - i]);
                    if ((i > 1) && (m_Stopwords.isStopword(buffer[m_MaxPhraseLength - i]))) {
                        continue;
                    }
                    if (i >= m_MinPhraseLength) {
                        String orig = phraseBuffer.toString();
                        String internal = internalFormat(orig);
                        Counter count = (Counter) hash.get(internal);
                        if (count == null) {
                            hash.put(internal, new Counter());
                        } else {
                            count.increment();
                        }
                    }
                }
            }
        }
        return hash;
    }
",1
12767963,7,"    protected double remove(double element) {
        int index = insertionPoint(element);
        double value = getMembership(element);
        if ((index > 0 && support[index] == element) || (index <= 0 && support[0] == element)) {
            for (int i = index; i < size - 1; i++) {
                support[i] = support[i + 1];
                membership[i] = membership[i + 1];
            }
            size--;
        }
        return value;
    }
",1
14989775,7,"    public void mouseDraggedAction(MathPainterPanelEvent mppe) {
        mouseDragged = true;
        if (nPoints == 0) {
        } else if (nPoints == 1) {
            xdata[0] = mppe.getMathSpaceX();
            ydata[0] = mppe.getMathSpaceY();
            mathCoords.setPoints(xdata, ydata);
            graphicsPanel.clear();
            mathPainter.setPaint(dataColorBtn.getColor());
            pointPlotter.plot();
        } else {
            double thisX = mppe.getMathSpaceX();
            double thisY = mppe.getMathSpaceY();
            dragXdata = new double[nPoints];
            dragYdata = new double[nPoints];
            if (thisX > previousX && thisX < nextX) {
                for (int i = 0; i < dragIndex; i++) {
                    dragXdata[i] = xdata[i];
                    dragYdata[i] = ydata[i];
                }
                dragXdata[dragIndex] = thisX;
                dragYdata[dragIndex] = thisY;
                for (int i = dragIndex + 1; i < nPoints; i++) {
                    dragXdata[i] = xdata[i];
                    dragYdata[i] = ydata[i];
                }
            } else if (thisX < previousX) {
                int ii = insertIndex(xdata, thisX);
                for (int i = 0; i < ii; i++) {
                    dragXdata[i] = xdata[i];
                    dragYdata[i] = ydata[i];
                }
                dragXdata[ii] = thisX;
                dragYdata[ii] = thisY;
                for (int i = ii + 1; i < dragIndex + 1; i++) {
                    dragXdata[i] = xdata[i - 1];
                    dragYdata[i] = ydata[i - 1];
                }
                for (int i = dragIndex + 1; i < nPoints; i++) {
                    dragXdata[i] = xdata[i];
                    dragYdata[i] = ydata[i];
                }
            } else {
                int ii = insertIndex(xdata, thisX) - 1;
                for (int i = 0; i < dragIndex; i++) {
                    dragXdata[i] = xdata[i];
                    dragYdata[i] = ydata[i];
                }
                for (int i = dragIndex; i < ii; i++) {
                    dragXdata[i] = xdata[i + 1];
                    dragYdata[i] = ydata[i + 1];
                }
                dragXdata[ii] = thisX;
                dragYdata[ii] = thisY;
                for (int i = ii + 1; i < nPoints; i++) {
                    dragXdata[i] = xdata[i];
                    dragYdata[i] = ydata[i];
                }
            }
            mathCoords.setPoints(dragXdata, dragYdata);
            graphicsPanel.clear();
            mathPainter.setPaint(dataColorBtn.getColor());
            pointPlotter.plot();
            drawInterpolants(dragXdata, dragYdata);
        }
        graphicsPanel.update();
    }
",0
6514936,7,"    public static void rotateArray(Object[] array) {
        Object top = array[0];
        for (int i = 0, len = array.length - 1; i < len; i++) {
            array[i] = array[i + 1];
        }
        array[array.length - 1] = top;
    }
",1
18724913,7,"    public static void novo_dia(double p, double dias[]) {
        p = pvt(p);
        for (int i = 0; i < PERIODO - 1; i++) dias[i] = dias[i + 1];
        dias[PERIODO - 1] = p;
    }
",1
919235,7,"    private void compileBootImage(String args[]) {
        String bi_args[] = new String[args.length - 1];
        String bi_name = args[args.length - 1];
        Class pub_cl;
        Object pub_obj;
        java.lang.reflect.Method pub_methods[];
        jdp_console.writeOutput(""Compiling Boot Image for "" + bi_name + "" . . . "");
        for (int i = 0; i < bi_args.length; i++) {
            bi_args[i] = args[i + 1];
        }
        try {
            pub_cl = Class.forName(args[0]);
            pub_obj = pub_cl.newInstance();
            pub_methods = pub_cl.getMethods();
            for (int n = 0; n < pub_methods.length; n++) {
                if (pub_methods[n].getName().equals(""main"")) {
                    Object invoke_args[] = { bi_args };
                    pub_methods[n].invoke(pub_obj, invoke_args);
                    return;
                }
            }
        } catch (ClassNotFoundException e) {
            jdp_console.writeOutput(""cannot compile, publicizing class loader not found: "" + args[0]);
            System.exit(1);
        } catch (InstantiationException e1) {
            jdp_console.writeOutput(""cannot compile, problem instantiating class"");
            System.exit(1);
        } catch (IllegalAccessException e2) {
            jdp_console.writeOutput(""cannot compile, illegal access to class"");
            System.exit(1);
        } catch (InvocationTargetException e3) {
            jdp_console.writeOutput(""cannot compile, Invocation Target Exception:"");
            jdp_console.writeOutput(e3.getMessage());
            System.exit(1);
        }
    }
",1
6230158,7,"    boolean toggleSelection(TreeItem item, boolean isCtrlKeyHold, boolean isShiftKeyHold) {
        if (item == null) {
            return false;
        }
        if ((style & SWT.MULTI) != 0 && (isCtrlKeyHold || isShiftKeyHold)) {
            if (isCtrlKeyHold) {
                for (int i = 0; i < selections.length; i++) {
                    if (item == selections[i]) {
                        TreeItem[] newSelections = new TreeItem[selections.length];
                        for (int j = 0; j < i; j++) {
                            newSelections[j] = selections[j];
                        }
                        for (int j = i; j < selections.length - 1; j++) {
                            newSelections[j] = selections[j + 1];
                        }
                        selections = newSelections;
                        item.showSelection(false);
                        lastSelection = item;
                        return false;
                    }
                }
                selections[selections.length] = item;
                lastSelection = item;
                item.showSelection(true);
            } else {
                for (int i = 0; i < selections.length; i++) {
                    if (selections[i] != null) {
                        selections[i].showSelection(false);
                    }
                }
                if (lastSelection != null) {
                    int idx1 = Math.min(lastSelection.index, item.index);
                    int idx2 = Math.max(lastSelection.index, item.index);
                    selections = new TreeItem[0];
                    for (int i = idx1; i <= idx2; i++) {
                        TreeItem ti = items[i];
                        if (ti.handle.style.display != ""none"") {
                            selections[selections.length] = ti;
                            ti.showSelection(true);
                        }
                    }
                    return true;
                } else {
                    if (selections.length != 1) {
                        selections = new TreeItem[1];
                    }
                    selections[0] = item;
                }
            }
        } else {
            item.showSelection(true);
            for (int i = 0; i < selections.length; i++) {
                if (selections[i] != null && selections[i] != item) {
                    selections[i].showSelection(false);
                }
            }
            if (selections.length != 1) {
                selections = new TreeItem[1];
            }
            selections[0] = item;
        }
        lastSelection = item;
        return true;
    }
",1
379353,7,"    public void run() {
        VM_Callbacks.notifyStartup();
        VM_Controller.boot();
        String[] mainArgs = null;
        INSTRUCTION[] mainCode = null;
        synchronized (VM_ClassLoader.lock) {
            VM_Class cls = null;
            try {
                cls = VM_Class.forName(args[0]);
            } catch (VM_ResolutionException e) {
                VM.sysWrite(e.getException() + ""\n"");
                return;
            }
            mainMethod = cls.findMainMethod();
            if (mainMethod == null) {
                VM.sysWrite(cls.getName() + "" doesn't have a \""public static void main(String[])\"" method to execute\n"");
                return;
            }
            mainArgs = new String[args.length - 1];
            for (int i = 0, n = mainArgs.length; i < n; ++i) mainArgs[i] = args[i + 1];
            mainCode = mainMethod.compile();
        }
        VM.debugBreakpoint();
        VM_Magic.invokeMain(mainArgs, mainCode);
    }
",0
16063642,7,"    public static final void iir_mem2(final float[] x, final int xs, final float[] den, final float[] y, final int ys, final int N, final int ord, final float[] mem) {
        int i, j;
        for (i = 0; i < N; i++) {
            y[ys + i] = x[xs + i] + mem[0];
            for (j = 0; j < ord - 1; j++) {
                mem[j] = mem[j + 1] - den[j + 1] * y[ys + i];
            }
            mem[ord - 1] = -den[ord] * y[ys + i];
        }
    }
",1
5408177,7,"    private void MouseActions(Point p) {
        if (Editor.drawMode == Editor.DRAW && Editor.selectedObject != null) {
            if (mouseClickListener.getButton() == 1) {
                Point p16 = new Point(p.x / 16, p.y / 16);
                if (!Editor.selectedObject.name.equals(""WorldTile"")) {
                    object[getObjectNumberAt(p16)] = new EditorObject(Editor.selectedObject, p16);
                } else {
                    object[getObjectNumberAt(p16)] = new EditorObject(Editor.selectedObject, p16, Integer.parseInt("""" + Editor.selectedObject.objectChar));
                }
            }
        }
        if (Toolbox.ToolboxTab.getSelectedIndex() == 0 && Editor.drawMode == Editor.SELECT) {
            if (mouseClickListener.getButtonState(1) == true) {
                if (object[getObjectNumberAt(new Point(p.x / 16, p.y / 16))] != null) {
                    if (object[getObjectNumberAt(new Point(p.x / 16, p.y / 16))].selected == true) {
                        clickingSelection = true;
                    }
                }
                if (clickingSelection == false) {
                    if (mouseClickListener.initialClick.x >= p.x && mouseClickListener.initialClick.y >= p.y) selectionRect = new Rectangle(p.x, p.y, mouseClickListener.initialClick.x - p.x, Math.abs(mouseClickListener.initialClick.y - p.y));
                    if (mouseClickListener.initialClick.x >= p.x && mouseClickListener.initialClick.y < p.y) selectionRect = new Rectangle(p.x, mouseClickListener.initialClick.y, mouseClickListener.initialClick.x - p.x, Math.abs(p.y - mouseClickListener.initialClick.y));
                    if (mouseClickListener.initialClick.x < p.x && mouseClickListener.initialClick.y >= p.y) selectionRect = new Rectangle(mouseClickListener.initialClick.x, p.y, p.x - mouseClickListener.initialClick.x, Math.abs(mouseClickListener.initialClick.y - p.y));
                    if (mouseClickListener.initialClick.x < p.x && mouseClickListener.initialClick.y < p.y) selectionRect = new Rectangle(mouseClickListener.initialClick.x, mouseClickListener.initialClick.y, p.x - mouseClickListener.initialClick.x, Math.abs(p.y - mouseClickListener.initialClick.y));
                } else {
                    moving = true;
                    int a = 0;
                    while (object[a] != null) {
                        if (object[a].selected) {
                            object[a].position = new Point(objectTemp[a].position.x + p.x / 16 - mouseClickListener.initialClick.x / 16, objectTemp[a].position.y - mouseClickListener.initialClick.y / 16 + p.y / 16);
                        }
                        a++;
                    }
                }
            } else {
                if (selectionRect != null) {
                    selectedPoint = new Point(selectionRect.x / 16, selectionRect.y / 16);
                    selectionObjects = new EditorObject[99999];
                    int a = 0;
                    while (object[a] != null) {
                        object[a].selected = false;
                        a++;
                    }
                    a = 0;
                    for (int x = selectionRect.x / 16; x < selectionRect.x / 16 + selectionRect.width / 16 + 1; x++) {
                        for (int y = selectionRect.y / 16; y < selectionRect.y / 16 + selectionRect.height / 16 + 1; y++) {
                            int n = getObjectNumberAt(new Point(x, y));
                            if (object[n] != null) {
                                selectionObjects[a] = object[n];
                                object[n].selected = true;
                                a++;
                            }
                        }
                    }
                }
                objectTemp = new EditorObject[99999];
                int a = 0;
                while (object[a] != null) {
                    objectTemp[a] = new EditorObject(new GameObject(object[a].name, object[a].objectChar), object[a].position);
                    a++;
                }
                selectionRect = null;
                clickingSelection = false;
            }
        }
        if (Toolbox.ToolboxTab.getSelectedIndex() == 1 && Editor.drawMode == Editor.SELECT) {
            if (mouseClickListener.getButtonState(1) == true) {
                if (new Rectangle(0, Editor.cameraPrefHeight - Editor.cameraTolerance / 2, maxWidth, Editor.cameraTolerance).contains(p)) {
                    Editor.cameraPrefHeight = Integer.parseInt(Toolbox.camPrefHeightSpinner.getValue().toString()) + p.y - mouseClickListener.initialClick.y;
                    update = true;
                }
            } else {
                if (update == true) {
                    Toolbox.camPrefHeightSpinner.setValue(Editor.cameraPrefHeight);
                    update = false;
                }
            }
        }
        if (Editor.drawMode == Editor.ERASE) {
            if (mouseClickListener.getButton() == 1) {
                Point p16 = new Point(p.x / 16, p.y / 16);
                int objectNumber = getNumberOfObjects();
                for (int i = getObjectNumberAt(p16); i < objectNumber; i++) {
                    object[i] = object[i + 1];
                }
                object[objectNumber] = null;
            }
        }
    }
",1
21872530,7,"    public DependencyInstance parseSentence(DependencyInstance instance) {
        String[] forms = instance.forms;
        FeatureVector[][][] fvs = new FeatureVector[forms.length][forms.length][2];
        double[][][] probs = new double[forms.length][forms.length][2];
        FeatureVector[][][][] nt_fvs = new FeatureVector[forms.length][pipe.types.length][2][2];
        double[][][][] nt_probs = new double[forms.length][pipe.types.length][2][2];
        pipe.fillFeatureVectors(instance, fvs, probs, nt_fvs, nt_probs, params);
        int K = 1;
        Object[][] d = null;
        d = decoder.decodeNonProjective(instance, fvs, probs, nt_fvs, nt_probs, K);
        String[] res = ((String) d[0][1]).split("" "");
        String[] pos = instance.cpostags;
        String[] formsNoRoot = new String[forms.length - 1];
        String[] posNoRoot = new String[formsNoRoot.length];
        String[] labels = new String[formsNoRoot.length];
        int[] heads = new int[formsNoRoot.length];
        for (int j = 0; j < formsNoRoot.length; j++) {
            formsNoRoot[j] = forms[j + 1];
            posNoRoot[j] = pos[j + 1];
            String[] trip = res[j].split(""[\\|:]"");
            labels[j] = pipe.types[Integer.parseInt(trip[2])];
            heads[j] = Integer.parseInt(trip[0]);
        }
        DependencyInstance di = new DependencyInstance(formsNoRoot, posNoRoot, labels, heads);
        return di;
    }
",1
9059010,7,"    public static void main(String[] args) throws Exception {
        if (args.length < 1) {
            System.out.println(""\nBoot (1999-11-27) David Wallace Croft (croft@orbs.com)"");
            System.out.println(""Updates available from \""http://www.orbs.com/\"".\n"");
            System.out.println(""Bootstraps the main(args) method of a class available "" + ""from a web site."");
            System.out.println(""Arguments:  URL [other...]"");
            System.out.println(""Example:  java -jar boot.jar "" + ""http://www.orbs.com/lib/Main.class username password"");
            return;
        }
        byte[] data = downloadBytes(new URL(args[0]));
        if (data == null) {
            System.out.println(""Unable to download \"""" + args[0] + ""\""."");
            return;
        }
        String[] shiftedArgs = new String[args.length - 1];
        for (int i = 0; i < shiftedArgs.length; i++) {
            shiftedArgs[i] = args[i + 1];
        }
        new Boot().bootstrap(data, shiftedArgs);
    }
",1
11351198,7,"    protected void analyzePixels() {
        int len = pixels.length;
        int nPix = len / 3;
        indexedPixels = new byte[nPix];
        NeuQuant nq = new NeuQuant(pixels, len, sample);
        colorTab = nq.process();
        for (int i = 0; i < colorTab.length; i += 3) {
            byte temp = colorTab[i];
            colorTab[i] = colorTab[i + 2];
            colorTab[i + 2] = temp;
            usedEntry[i / 3] = false;
        }
        int k = 0;
        for (int i = 0; i < nPix; i++) {
            int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[i] = (byte) index;
        }
        pixels = null;
        colorDepth = 8;
        palSize = 7;
        if (transparent != null) {
            transIndex = findClosest(transparent);
        }
    }
",0
1470511,7,"    private static double[] maketable(double[] x, double[] y, int n) {
        double[] a = new double[n];
        double[] h = new double[n];
        double[] d = new double[n];
        int n_1 = n - 1;
        int n_2 = n - 2;
        a[0] = 0;
        a[n_1] = 0;
        for (int i = 0; i < n_1; i++) {
            h[i] = x[i + 1] - x[i];
            d[i + 1] = (y[i + 1] - y[i]) / h[i];
        }
        a[1] = d[2] - d[1] - h[0] * a[0];
        d[1] = 2 * (x[2] - x[0]);
        for (int i = 1; i < n_2; i++) {
            double t = h[i] / d[i];
            a[i + 1] = d[i + 2] - d[i + 1] - a[i] * t;
            d[i + 1] = 2 * (x[i + 2] - x[i]) - h[i] * t;
        }
        a[n_2] -= h[n_2] * a[n_1];
        for (int i = n_2; i > 0; i--) {
            a[i] = (a[i] - h[i] * a[i + 1]) / d[i];
        }
        return a;
    }
",1
7644199,7,"    public void remove(final int index) {
        for (int x = index; x < length - 1; x++) {
            data[x] = data[x + 1];
        }
        data[length - 1] = null;
        length--;
    }
",1
18253626,7,"    public FTPFile[] parse(String[] lines) throws FTPListParseException {
        int size = lines.length;
        if (size == 0) {
            return new FTPFile[0];
        }
        if (lines[0].startsWith(""total"")) {
            size--;
            String[] lines2 = new String[size];
            for (int i = 0; i < size; i++) {
                lines2[i] = lines[i + 1];
            }
            lines = lines2;
        }
        Calendar now = Calendar.getInstance();
        int currentYear = now.get(Calendar.YEAR);
        FTPFile[] ret = new FTPFile[size];
        for (int i = 0; i < size; i++) {
            Matcher m = PATTERN.matcher(lines[i]);
            if (m.matches()) {
                ret[i] = new FTPFile();
                String typeString = m.group(1);
                String sizeString = m.group(2);
                String monthString = m.group(3);
                String dayString = m.group(4);
                String yearString = m.group(5);
                String hourString = m.group(6);
                String minuteString = m.group(7);
                String nameString = m.group(8);
                String linkedString = m.group(9);
                if (typeString.equals(""-"")) {
                    ret[i].setType(FTPFile.TYPE_FILE);
                } else if (typeString.equals(""d"")) {
                    ret[i].setType(FTPFile.TYPE_DIRECTORY);
                } else if (typeString.equals(""l"")) {
                    ret[i].setType(FTPFile.TYPE_LINK);
                    ret[i].setLink(linkedString);
                } else {
                    throw new FTPListParseException();
                }
                long fileSize;
                try {
                    fileSize = Long.parseLong(sizeString);
                } catch (Throwable t) {
                    throw new FTPListParseException();
                }
                ret[i].setSize(fileSize);
                if (dayString.length() == 1) {
                    dayString = ""0"" + dayString;
                }
                StringBuffer mdString = new StringBuffer();
                mdString.append(monthString);
                mdString.append(' ');
                mdString.append(dayString);
                mdString.append(' ');
                boolean checkYear = false;
                if (yearString == null) {
                    mdString.append(currentYear);
                    checkYear = true;
                } else {
                    mdString.append(yearString);
                    checkYear = false;
                }
                mdString.append(' ');
                if (hourString != null && minuteString != null) {
                    if (hourString.length() == 1) {
                        hourString = ""0"" + hourString;
                    }
                    if (minuteString.length() == 1) {
                        minuteString = ""0"" + minuteString;
                    }
                    mdString.append(hourString);
                    mdString.append(':');
                    mdString.append(minuteString);
                } else {
                    mdString.append(""00:00"");
                }
                Date md;
                try {
                    synchronized (DATE_FORMAT) {
                        md = DATE_FORMAT.parse(mdString.toString());
                    }
                } catch (ParseException e) {
                    throw new FTPListParseException();
                }
                if (checkYear) {
                    Calendar mc = Calendar.getInstance();
                    mc.setTime(md);
                    if (mc.after(now) && mc.getTimeInMillis() - now.getTimeInMillis() > 24L * 60L * 60L * 1000L) {
                        mc.set(Calendar.YEAR, currentYear - 1);
                        md = mc.getTime();
                    }
                }
                ret[i].setModifiedDate(md);
                ret[i].setName(nameString);
            } else {
                throw new FTPListParseException();
            }
        }
        return ret;
    }
",1
2062008,7,"        private void mouseDragged(MouseDraggedEvent ev) {
            if (clickPoint == null) return;
            Point pos = ev.getPoint();
            handlePos[selected].x = pos.x;
            double newx = ((double) pos.x - graphBounds.x) / (graphBounds.width - 1.0);
            double newy = ((double) (graphBounds.height - pos.y + graphBounds.y)) / (graphBounds.height - 1.0);
            newy = newy * (maxy - miny) + miny;
            if (newx < 0.0) newx = 0.0;
            if (newx > 1.0) newx = 1.0;
            if (newy < miny) newy = miny;
            if (newy > maxy) newy = maxy;
            y[selected] = 0.001 * ((int) (1000.0 * newy));
            if (selected == 0 || selected == x.length - 1) {
                editModule.calcCoefficients();
                adjustComponents();
                canvas.repaint();
                return;
            }
            x[selected] = 0.001 * ((int) (1000.0 * newx));
            while (x[selected] < x[selected - 1]) {
                double temp = x[selected];
                x[selected] = x[selected - 1];
                x[selected - 1] = temp;
                temp = y[selected];
                y[selected] = y[selected - 1];
                y[selected - 1] = temp;
                Point tempPos = handlePos[selected];
                handlePos[selected] = handlePos[selected - 1];
                handlePos[selected - 1] = tempPos;
                selected--;
            }
            while (x[selected] > x[selected + 1]) {
                double temp = x[selected];
                x[selected] = x[selected + 1];
                x[selected + 1] = temp;
                temp = y[selected];
                y[selected] = y[selected + 1];
                y[selected + 1] = temp;
                Point tempPos = handlePos[selected];
                handlePos[selected] = handlePos[selected + 1];
                handlePos[selected + 1] = tempPos;
                selected++;
            }
            editModule.calcCoefficients();
            adjustComponents();
            canvas.repaint();
        }
",0
11249438,7,"    public static final void changeWordEndianess(byte[] b, int offset, int length) {
        byte tmp;
        for (int i = offset; i < offset + length; i += 4) {
            tmp = b[i];
            b[i] = b[i + 3];
            b[i + 3] = tmp;
            tmp = b[i + 1];
            b[i + 1] = b[i + 2];
            b[i + 2] = tmp;
        }
    }
",0
5818876,7,"    private int[] push(int[] ind, int sub) {
        int[] new_ind = new int[ind.length - 1];
        if (sub == 0) {
            for (int i = 0; i < ind.length - 1; i++) new_ind[i] = ind[i + 1];
        } else if (sub == ind.length) {
            for (int i = 0; i < ind.length - 1; i++) new_ind[i] = ind[i];
        } else {
            for (int i = 0; i < sub; i++) new_ind[i] = ind[i];
            for (int i = sub; i < ind.length - 1; i++) new_ind[i] = ind[i + 1];
        }
        return new_ind;
    }
",1
7930609,7,"    boolean moveDelta(int index, int dx, int dy) {
        if (dx == 0 && dy == 0) return false;
        boolean needResize = false;
        boolean needLayout = false;
        if (dy == 0) {
            int[] ws = new int[items.length];
            for (int i = 0; i < ws.length; i++) {
                ws[i] = items[i].idealWidth;
            }
            boolean needCalculate = false;
            CoolItem item = items[index];
            if (item.wrap && (dx < 0 || isLastItemOfRow(index))) {
                return false;
            }
            if ((index == 0 && items.length > 1) || (item.wrap && !isLastItemOfRow(index))) {
                if (dx >= item.lastCachedWidth) {
                    CoolItem next = items[index + 1];
                    items[index] = next;
                    items[index + 1] = item;
                    if (item.wrap) {
                        next.wrap = true;
                        item.wrap = false;
                    }
                    int width = next.idealWidth;
                    next.idealWidth = item.idealWidth;
                    item.idealWidth = width;
                    dx = dx - item.lastCachedWidth;
                    index++;
                    needLayout = true;
                }
            }
            if (dx != 0 && index > 0 && !(item.wrap && !isLastItemOfRow(index))) {
                CoolItem cur = item;
                CoolItem prev = items[index - 1];
                int idx = index - 1;
                while (dx < 0) {
                    if (prev.lastCachedWidth + dx < minWidth(prev)) {
                        int ddx = prev.lastCachedWidth - minWidth(prev);
                        prev.idealWidth -= ddx;
                        item.idealWidth += ddx;
                        needCalculate = true;
                        dx += ddx;
                        if (dx < 0) {
                            if (idx - 1 >= 0 && !items[idx].wrap) {
                                idx--;
                                prev = items[idx];
                            } else {
                                if (dx + 11 <= 0) {
                                    CoolItem swpItem = prev;
                                    int swpIndex = index;
                                    while (dx + minWidth(swpItem) <= 0) {
                                        dx += minWidth(swpItem);
                                        swpItem = items[swpIndex - 1];
                                        items[swpIndex - 1] = items[swpIndex];
                                        items[swpIndex] = swpItem;
                                        if (swpItem.wrap) {
                                            items[swpIndex - 1].wrap = true;
                                            swpItem.wrap = false;
                                        }
                                        needLayout = true;
                                        swpIndex--;
                                        if (swpIndex == 0 || swpItem.wrap) {
                                            break;
                                        }
                                    }
                                }
                                dx = 0;
                                break;
                            }
                        }
                    } else {
                        break;
                    }
                }
                CoolItem next = null;
                idx = index;
                while (dx > 0 && cur.lastCachedWidth - dx < minWidth(cur)) {
                    int dxx = cur.lastCachedWidth - minWidth(cur);
                    prev.idealWidth += dxx;
                    cur.idealWidth -= dxx;
                    needCalculate = true;
                    dx -= dxx;
                    if (dx > 0) {
                        if (idx + 1 < items.length && !isLastItemOfRow(idx)) {
                            idx++;
                            cur = items[idx];
                            if (next == null) {
                                next = cur;
                            }
                        } else {
                            if (dx >= 11 && next != null) {
                                CoolItem swpItem = next;
                                int swpIndex = index;
                                while (dx >= minWidth(swpItem)) {
                                    items[swpIndex + 1] = items[swpIndex];
                                    items[swpIndex] = swpItem;
                                    if (swpItem.wrap) {
                                        items[swpIndex].wrap = true;
                                        swpItem.wrap = false;
                                    }
                                    swpItem = items[swpIndex + 1];
                                    needLayout = true;
                                    dx -= minWidth(swpItem);
                                    swpIndex++;
                                    if (swpIndex >= items.length || isLastItemOfRow(swpIndex)) {
                                        break;
                                    }
                                }
                            }
                            dx = 0;
                            break;
                        }
                    }
                }
                prev.idealWidth += dx;
                if (dx != 0) {
                    needCalculate = true;
                }
                if (item != cur) {
                    if (cur.idealWidth - dx < 0) {
                        if (cur.idealWidth != 0) {
                            needCalculate = true;
                        }
                        cur.idealWidth = 0;
                    } else {
                        cur.idealWidth -= dx;
                    }
                } else {
                    item.idealWidth -= dx;
                }
            }
            if (needCalculate && !needLayout) {
                for (int i = 0; i < ws.length; i++) {
                    if (ws[i] != items[i].idealWidth) {
                        needLayout = true;
                        break;
                    }
                }
            }
        } else {
            int line = verticalLine(index);
            if (line + dy < 0) {
                if (index == 0 && isLastItemOfRow(index)) {
                } else {
                    CoolItem ci = items[index];
                    if ((index == 0 && items.length > 1) || (ci.wrap && index < items.length - 1)) {
                        items[index + 1].wrap = true;
                    }
                    for (int i = index; i > 0; i--) {
                        items[i] = items[i - 1];
                    }
                    items[0] = ci;
                    items[1].wrap = true;
                    ci.wrap = false;
                    needLayout = true;
                    needResize = true;
                }
            } else if (line + dy < getVerticalLines()) {
                int lineNumber = line + dy;
                int i = 0;
                for (i = 0; i < items.length; i++) {
                    if (lineNumber == 0) {
                        break;
                    }
                    if (items[i].wrap) {
                        lineNumber--;
                    }
                }
                if (i > 0) i--;
                CoolItem ci = items[index];
                if (index == 0 && isLastItemOfRow(index)) {
                    needResize = true;
                }
                if (ci.wrap) {
                    if (isLastItemOfRow(index)) {
                        needResize = true;
                    }
                    if (index < items.length - 1) {
                        items[index + 1].wrap = true;
                    }
                }
                int x = ci.getPosition().x + dx;
                if (x <= 0) {
                    if (i == 0) {
                        ci.wrap = false;
                    } else {
                        if (index == 0 && i == 1) {
                        } else {
                            ci.wrap = true;
                        }
                        if (i < items.length - 1) {
                            items[i + 1].wrap = false;
                        }
                    }
                } else {
                    int rowWidth = 0;
                    int separator = 2;
                    for (; i < items.length; i++) {
                        CoolItem item = items[i];
                        int minimum = item.minimumWidth + (item.minimumWidth != 0 ? 2 : 0);
                        rowWidth += 7 + 2 + Math.max(item.idealWidth, minimum) + separator;
                        int xx = item.getPosition().x;
                        if (xx < x && (x <= rowWidth || isLastItemOfRow(i))) {
                            item.idealWidth = Math.max(0, x - xx - (7 + 2 + minimum + separator));
                            minimum = ci.minimumWidth + (ci.minimumWidth != 0 ? 2 : 0);
                            int mw = 7 + 2 + minimum + separator;
                            ci.idealWidth = Math.max(item.minimumWidth, Math.max(ci.idealWidth, rowWidth - x - mw));
                            if (rowWidth - x - mw < ci.idealWidth) {
                                needResize = true;
                            }
                            break;
                        }
                    }
                    ci.wrap = false;
                }
                if (dy < 0 && x > 0 && i < items.length - 1) {
                    i++;
                }
                if (dy > 0) {
                    for (int j = index; j < i; j++) {
                        items[j] = items[j + 1];
                    }
                } else {
                    for (int j = index; j > i; j--) {
                        items[j] = items[j - 1];
                    }
                }
                items[i] = ci;
                items[0].wrap = false;
                needLayout = true;
            } else {
                if ((items[index].wrap || index == 0) && isLastItemOfRow(index)) {
                } else {
                    CoolItem ci = items[index];
                    if (index > 0 && ci.wrap) {
                        items[index + 1].wrap = true;
                    }
                    for (int i = index; i < items.length - 1; i++) {
                        items[i] = items[i + 1];
                    }
                    items[items.length - 1] = ci;
                    ci.wrap = true;
                    needLayout = true;
                    needResize = true;
                }
            }
        }
        int w = width;
        int h = height;
        if (needResize) {
            Point computeSize = computeSize(-1, -1, false);
            w = computeSize.x;
            h = computeSize.y;
        }
        if (needLayout) {
            SetWindowPos(null, null, 0, 0, width, h, -1);
        }
        if (w > width) {
            for (int i = index + 1; i < items.length; i++) {
                if (isLastItemOfRow(i)) {
                    moveDelta(i, width - height, 0);
                    break;
                }
            }
        }
        return needLayout;
    }
",0
1538985,7,"    RetVal RPSpos(int nr, double Tr[], double Xr[], double Yr[], double Zr[], double Vs, double Xt, double Yt, double Zt) {
        int i, j, jmax, k, ns, nss, nxx, nox, tov, S, cmax;
        int[] ce = new int[NMAX];
        double Rq;
        double[] Rs = new double[NMAX];
        double[] Xs = new double[NMAX];
        double[] Ys = new double[NMAX];
        double[] Zs = new double[NMAX];
        double x, y, z, Rmax;
        double Ww, Xw, Yw, Zw, w, q;
        double err, emax, thr, var, vmax, vmin, vold;
        j = k = jmax = nox = 0;
        w = 0;
        var = 0;
        vmax = SMAX * SMAX * Vs * Vs;
        vmin = 1.0 * Vs * Vs;
        ns = 0;
        Rmax = Vs * TMAX;
        Rs[NMAX - 1] = TMAX;
        for (i = 0; i < nr; i++) {
            if (Tr[i] == 0.0) continue;
            Rq = Vs * (Tr[i] + offset);
            if ((Rq >= Rmax) || (Rq < Vs * TMIN)) continue;
            if (ns == 0) {
                Rs[0] = Rq;
                Xs[0] = Xr[i];
                Ys[0] = Yr[i];
                Zs[0] = Zr[i];
                ns = 1;
            } else {
                j = ((ns == NMAX) ? (ns - 1) : (ns++));
                for (; ; j--) {
                    if ((j > 0) && (Rq < Rs[j - 1])) {
                        Rs[j] = Rs[j - 1];
                        Xs[j] = Xs[j - 1];
                        Ys[j] = Ys[j - 1];
                        Zs[j] = Zs[j - 1];
                    } else {
                        if ((j < NMAX - 1) || (Rq < Rs[j])) {
                            Rs[j] = Rq;
                            Xs[j] = Xr[i];
                            Ys[j] = Yr[i];
                            Zs[j] = Zr[i];
                        }
                        break;
                    }
                }
            }
        }
        for (i = 0; i < ns; i++) ce[i] = 0;
        for (i = 0; i < ns - 1; i++) {
            for (j = i + 1; j < ns; j++) {
                q = Math.sqrt((Xs[i] - Xs[j]) * (Xs[i] - Xs[j]) + (Ys[i] - Ys[j]) * (Ys[i] - Ys[j]) + (Zs[i] - Zs[j]) * (Zs[i] - Zs[j]));
                if ((Rs[i] + Rs[j] < q) || (Rs[i] - Rs[j] > q) || (Rs[j] - Rs[i] > q)) {
                    ++ce[i];
                    ++ce[j];
                }
            }
        }
        cmax = 1;
        nxx = 0;
        while (cmax != 0) {
            cmax = 0;
            for (i = 0; i < ns; i++) {
                if (ce[i] >= cmax) {
                    if (ce[i] > 0) nxx = ((ce[i] == cmax) ? nxx + 1 : 1);
                    cmax = ce[i];
                    j = i;
                }
            }
            if (cmax > 0) {
                for (i = 0; i < ns; i++) {
                    if (i == j) continue;
                    q = Math.sqrt((Xs[i] - Xs[j]) * (Xs[i] - Xs[j]) + (Ys[i] - Ys[j]) * (Ys[i] - Ys[j]) + (Zs[i] - Zs[j]) * (Zs[i] - Zs[j]));
                    if ((Rs[i] + Rs[j] < q) || (Rs[i] - Rs[j] > q) || (Rs[j] - Rs[i] > q)) {
                        --ce[i];
                    }
                }
                for (i = j; i < ns - 1; i++) {
                    Rs[i] = Rs[i + 1];
                    Xs[i] = Xs[i + 1];
                    Ys[i] = Ys[i + 1];
                    Zs[i] = Zs[i + 1];
                    ce[i] = ce[i + 1];
                }
                --ns;
            }
        }
        nss = ns;
        if (ns < 3) {
            Xt = Yt = Zt = 9.9999999e99;
            return new RetVal(0, Xt, Yt, Zt, Vs);
        }
        S = i = tov = 0;
        x = y = 0.0;
        z = -100000.0;
        while (S < 4) {
            if (S == 0) {
                j = k = i % ns;
                w = 1.0;
            } else if (S == 1) {
                while ((j = (int) Math.floor((ns) * Math.random())) == k) {
                }
                k = j;
                w = 1.0;
            } else if (S == 2) {
                --k;
                j = k % ns;
                w = 1.0 - Rs[j] / Rmax;
                w = w * w;
                w *= 0.01 * (k + 1);
            } else if (S == 3) {
            }
            if (S < 3) {
                q = Math.sqrt((Xs[j] - x) * (Xs[j] - x) + (Ys[j] - y) * (Ys[j] - y) + (Zs[j] - z) * (Zs[j] - z));
                q = w * (1.0 - Rs[j] / q);
                x += q * (Xs[j] - x);
                y += q * (Ys[j] - y);
                z += q * (Zs[j] - z);
                ++i;
            }
            if (((S == 1) && (i % 50 == 0)) || ((S == 2) && (k == 0)) || (S == 3)) {
                Ww = Xw = Yw = Zw = emax = 0.0;
                vold = var;
                var = 0.0;
                for (j = 0; j < ns; j++) {
                    q = Math.sqrt((Xs[j] - x) * (Xs[j] - x) + (Ys[j] - y) * (Ys[j] - y) + (Zs[j] - z) * (Zs[j] - z));
                    err = q - Rs[j];
                    err = err * err;
                    q = 1.0 - Rs[j] / q;
                    if (S >= 2) {
                        w = 1.0 - Rs[j] / Rmax;
                        w = w * w;
                    } else w = 1.0;
                    Xw += w * (x + q * (Xs[j] - x));
                    Yw += w * (y + q * (Ys[j] - y));
                    Zw += w * (z + q * (Zs[j] - z));
                    Ww += w;
                    var += w * err;
                    if (w * err > emax) {
                        emax = w * err;
                        jmax = j;
                    }
                }
                x = Xw / Ww;
                y = Yw / Ww;
                z = Zw / Ww;
                var = var / Ww;
                i += ns;
                thr = (10.0 - 30.0 / ns) * Ww / ns;
                if ((S >= 2) && (ns > 3) && (((ns > 4) && (emax > var * thr)) || (var > 3 * vmax))) {
                    tov = ((emax > var * thr) ? 0 : 1);
                    --ns;
                    nox = 0;
                    Rs[jmax] = Rs[ns];
                    Xs[jmax] = Xs[ns];
                    Ys[jmax] = Ys[ns];
                    Zs[jmax] = Zs[ns];
                } else ++nox;
                if ((S == 1) && (((var > 0.999 * vold) && (var < 3 * vmax)) || (var < vmin) || (i >= 750))) {
                    k = 200;
                    nox = 0;
                    ++S;
                }
                if ((S == 2) && (k == 0)) {
                    k = 200;
                    if (((nox >= 2) && (var > 0.999 * vold)) || (var < vmin) || (i >= 2000)) {
                        nox = 0;
                        ++S;
                    }
                }
                if ((S == 3) && (((nox >= 1 + 110 / (ns + 5)) && (var > 0.999 * vold)) || (var < 0.1 * vmin) || (i >= 2500 - ns))) {
                    ++S;
                }
            }
            if ((S == 0) && (i >= 50)) {
                k = j;
                var = 9e9;
                ++S;
            }
        }
        Xt = x;
        Yt = y;
        Zt = z;
        if ((var > vmax) || ((ns == 3) && (var > vmin))) {
            return new RetVal(-ns, Xt, Yt, Zt, Vs);
        }
        if ((ns == 3) && ((nss > 4) || (nxx > 1) || (tov != 0))) {
            return new RetVal(1, Xt, Yt, Zt, Vs);
        }
        if ((ns == 4) && ((nss > 5) || ((nss == 5) && (nxx == 1) && (tov == 1)))) {
            return new RetVal(2, Xt, Yt, Zt, Vs);
        }
        if ((ns >= 5) && (nss > (3 * ns - 3) / 2)) return new RetVal(2, Xt, Yt, Zt, Vs);
        return new RetVal(ns, Xt, Yt, Zt, Vs);
    }
",1
8513087,7,"    public Spline(float[] xx, float[] yy) {
        int N = xx.length;
        if (N <= 0) {
            return;
        }
        if ((u == null) || (u.length < N + 1)) {
            x = new float[N + 1];
            y = new float[N + 1];
            u = new float[N + 1];
            d = new float[N + 1];
            p = new float[N + 1];
            w = new float[N + 1];
        }
        x[0] = xx[0];
        y[0] = yy[0];
        for (int i = 0; i < xx.length; i++) {
            x[i + 1] = xx[i];
            y[i + 1] = yy[i];
        }
        for (int i = 2; i < N; i++) {
            d[i] = 2 * (x[i + 1] - x[i - 1]);
        }
        for (int i = 1; i < N; i++) {
            u[i] = x[i + 1] - x[i];
        }
        for (int i = 2; i < N; i++) {
            w[i] = 6 * ((y[i + 1] - y[i]) / u[i] - (y[i] - y[i - 1]) / u[i - 1]);
        }
        p[1] = 0;
        p[N] = 0;
        for (int i = 2; i < N - 1; i++) {
            w[i + 1] -= w[i] * u[i] / d[i];
            d[i + 1] -= u[i] * u[i] / d[i];
        }
        for (int i = N - 1; i > 1; i--) {
            p[i] = (w[i] - u[i] * p[i + 1]) / d[i];
        }
    }
",1
416525,7,"    private void compileBootImage(String args[]) {
        String bi_args[] = new String[args.length - 1];
        String bi_name = args[args.length - 1];
        Class pub_cl;
        Object pub_obj;
        java.lang.reflect.Method pub_methods[];
        jdp_console.writeOutput(""Compiling Boot Image for "" + bi_name + "" . . . "");
        for (int i = 0; i < bi_args.length; i++) {
            bi_args[i] = args[i + 1];
        }
        try {
            pub_cl = Class.forName(args[0]);
            pub_obj = pub_cl.newInstance();
            pub_methods = pub_cl.getMethods();
            for (int n = 0; n < pub_methods.length; n++) {
                if (pub_methods[n].getName().equals(""main"")) {
                    Object invoke_args[] = { bi_args };
                    pub_methods[n].invoke(pub_obj, invoke_args);
                    return;
                }
            }
        } catch (ClassNotFoundException e) {
            jdp_console.writeOutput(""cannot compile, publicizing class loader not found: "" + args[0]);
            System.exit(1);
        } catch (InstantiationException e1) {
            jdp_console.writeOutput(""cannot compile, problem instantiating class"");
            System.exit(1);
        } catch (IllegalAccessException e2) {
            jdp_console.writeOutput(""cannot compile, illegal access to class"");
            System.exit(1);
        } catch (InvocationTargetException e3) {
            jdp_console.writeOutput(""cannot compile, Invocation Target Exception:"");
            jdp_console.writeOutput(e3.getMessage());
            System.exit(1);
        }
    }
",0
1800281,7,"    public void randomize(Individual<T> c, int min, int max) {
        IntegerChromosome chrom = (IntegerChromosome) c.getChromosome();
        int len = max - min + 1;
        int[] base = new int[len];
        for (int i = 0; i < len; i++) base[i] = chrom.getValue(min + i);
        int i = 0;
        while (len != 0) {
            int pos = Random.getInstance().nextInt(0, len);
            chrom.setValue(min + i, base[pos]);
            for (int j = pos; j < (len - 1); j++) {
                base[j] = base[j + 1];
            }
            len--;
            i++;
        }
    }
",1
16653059,7,"    private final void deleteRoomAt(int index) {
        for (int i = index; i < events_fill_p; i++) events[i] = events[i + 1];
        events_fill_p--;
    }
",1
20707231,7,"    public FrequencyNode(ProbabilityFunction func) {
        DiscreteVariable[] vars = func.get_variables();
        id = vars[0].get_index();
        int maxK = vars[0].number_values();
        if (vars.length > 1) {
            parents = new int[vars.length - 1];
            int maxJ = 1;
            for (int p = 0; p < parents.length; ++p) {
                parents[p] = vars[p + 1].get_index();
                maxJ *= vars[p + 1].number_values();
            }
            parentMult = new int[vars.length - 1];
            nJ = new int[maxJ];
            nJK = new int[maxJ][maxK];
            for (int p = 0; p < parentMult.length; ++p) {
                maxJ /= vars[p + 1].number_values();
                parentMult[p] = maxJ;
            }
        } else {
            parents = null;
            parentMult = null;
            nJ = new int[1];
            nJK = new int[1][maxK];
        }
    }
",1
796292,7,"    public void readCommand(OsProcess proc) {
        String str;
        user = proc;
        if (rawTTY) str = readFromRawTTY(); else str = readFromCookedTTY();
        String[] words = toArgs(str);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
",0
10062075,7,"    private void shiftArray(byte[] array) {
        for (int i = 0; i < (array.length - 1); i++) array[i] = array[i + 1];
        array[array.length - 1] = 0;
    }
",1
389372,7,"    public void run() {
        VM_Callbacks.notifyStartup();
        VM_Controller.boot();
        String[] mainArgs = null;
        INSTRUCTION[] mainCode = null;
        synchronized (VM_ClassLoader.lock) {
            VM_Class cls = null;
            try {
                cls = VM_Class.forName(args[0]);
            } catch (VM_ResolutionException e) {
                VM.sysWrite(e.getException() + ""\n"");
                return;
            }
            mainMethod = cls.findMainMethod();
            if (mainMethod == null) {
                VM.sysWrite(cls.getName() + "" doesn't have a \""public static void main(String[])\"" method to execute\n"");
                return;
            }
            mainArgs = new String[args.length - 1];
            for (int i = 0, n = mainArgs.length; i < n; ++i) mainArgs[i] = args[i + 1];
            mainCode = mainMethod.compile();
        }
        VM.debugBreakpoint();
        VM_Magic.invokeMain(mainArgs, mainCode);
    }
",1
15348039,7,"    protected void calculate(double[][] database) {
        int SP_NUM = getPointCount() - 1;
        if (SP_NUM < 0) {
            koef = null;
            return;
        }
        koef = new double[SP_NUM][4];
        double[] h = new double[SP_NUM];
        for (int i = 0; i < SP_NUM; i++) {
            h[i] = database[i + 1][0] - database[i][0];
            koef[i][0] = database[i][1];
        }
        double[] sub = new double[SP_NUM];
        double[] diag = new double[SP_NUM];
        double[] sup = new double[SP_NUM];
        double[] f = new double[SP_NUM];
        for (int i = 1; i < SP_NUM - 1; i++) {
            sub[i] = h[i] / 3;
            sup[i] = h[i - 1] / 3;
            diag[i] = 2 * h[i] / 3 + 2 * h[i - 1] / 3;
            f[i] = (database[i + 1][1] + database[i][1]) / h[i] - (database[i][1] + database[i - 1][1]) / h[i - 1];
        }
        sub[0] = h[0] / 3;
        sup[SP_NUM - 1] = h[SP_NUM - 1] / 3;
        diag[0] = 2 * h[0] / 3;
        diag[SP_NUM - 1] = 2 * h[SP_NUM - 1] / 3;
        f[0] = (database[1][1] + database[0][1]) / h[0] - getBorderLeft();
        f[SP_NUM - 1] = -(database[SP_NUM][1] + database[SP_NUM - 1][1]) / h[SP_NUM - 1] + getBorderRight();
        solveTridiag(sub, diag, sup, f, SP_NUM);
        koef[0][1] = getBorderLeft();
        koef[SP_NUM - 1][1] = getBorderRight();
        for (int i = 1; i < SP_NUM - 1; i++) {
            koef[i][2] = f[i];
            koef[i][3] = (f[i + 1] - f[i]) / 3 / h[i];
            koef[i][1] = (f[i] + f[i - 1]) * h[i - 1] + koef[i - 1][1];
        }
        koef[0][2] = f[0];
        koef[SP_NUM - 1][2] = f[SP_NUM - 1];
        koef[0][3] = (f[1] - f[0]) / 3 / h[0];
        koef[SP_NUM - 1][3] = (database[SP_NUM][1] - database[SP_NUM][1]) / h[SP_NUM - 1] / h[SP_NUM - 1] / h[SP_NUM - 1] - f[SP_NUM - 1] / h[SP_NUM - 1] - koef[SP_NUM - 1][1] / h[SP_NUM - 1] / h[SP_NUM - 1];
    }
",1
2486884,7,"    public void novo_dia(double p, double dias[]) {
        for (int i = 0; i < PERIODO - 1; i++) dias[i] = dias[i + 1];
        dias[PERIODO - 1] = p;
    }
",1
3823290,7,"    private final void update_box(ImageConsumer cons, int y, int x, int w, byte buf[]) {
        int si = y * W + x;
        int p = 0;
        x <<= 3;
        y <<= 3;
        int h, s;
        if (scale == 1) {
            s = w * 8;
            for (int n = 0; n < 8; n++) {
                for (int k = 0; k < w; k++) {
                    int m = screen[si++];
                    byte c0 = (byte) (m >>> 8 & 0xF);
                    byte c1 = (byte) (m >>> 12);
                    m &= 0xFF;
                    do buf[p++] = (m & 1) == 0 ? c0 : c1; while ((m >>>= 1) != 0);
                }
                si += (W / 8) - w;
            }
            h = 8;
        } else {
            h = scale << 3;
            s = w * h;
            for (int n = 0; n < 8; n++) {
                for (int k = 0; k < w; k++) {
                    int m = screen[si++];
                    byte c0 = (byte) (m >>> 8 & 0xF);
                    byte c1 = (byte) (m >>> 12);
                    m &= 0xFF;
                    do {
                        buf[p] = buf[p + 1] = buf[p + s] = buf[p + s + 1] = (m & 1) == 0 ? c0 : c1;
                        p += 2;
                    } while ((m >>>= 1) != 0);
                }
                p += s;
                si += (W / 8) - w;
            }
            x *= scale;
            y *= scale;
        }
        cons.setPixels(x, y, s, h, cm, buf, 0, s);
    }
",1
17012902,7,"    public static void swapOrder32(byte[] buffer, int byteOffset, int sampleCount) {
        int byteMax = sampleCount * 4 + byteOffset - 3;
        int i = byteOffset;
        while (i < byteMax) {
            byte h = buffer[i];
            buffer[i] = buffer[i + 3];
            buffer[i + 3] = h;
            i++;
            h = buffer[i];
            buffer[i] = buffer[++i];
            buffer[i++] = h;
            i++;
        }
    }
",1
17866017,7,"    public RatPoly differentiate() {
        if (deg == 0) return ZERO;
        RatPoly deriv = new RatPoly(BigRational.ZERO, deg - 1);
        for (int i = 0; i < deg; i++) deriv.coef[i] = coef[i + 1].times(new BigRational(i + 1));
        deriv.deg = deriv.degree();
        return deriv;
    }
",1
8452230,7,"    public static String evalCmdDef(String[] words, int depth) {
        if ((words == null) || (words.length <= 1)) throw new RuntimeException(""<def> needs at least 2 arguments"");
        if (isBuiltinCommand(words[0])) throw new RuntimeException(""Cannot define function : "" + words[0]);
        String[] params = new String[words.length - 2];
        for (int i = 0; i < (words.length - 2); i++) params[i] = words[i + 1];
        ScriptFunction func = new ScriptFunction(words[0], params, words[words.length - 1], depth);
        ScriptParser.getFunctionsStore().put(func);
        return ""1"";
    }
",1
21039957,7,"    public Object[] getBooleanFuncParams(Object[] params, int nScalarInd) {
        if (Helper.hasNulls(params, 1)) return null;
        if (!XFunction.class.isInstance(params[1])) return null;
        XFunction func = (XFunction) params[1];
        if (!func.getReturnType().equals(Boolean.class)) return null;
        Object[] ret = new Object[params.length - 1];
        for (int i = 0; i < ret.length; i++) {
            ret[i] = params[i + 1];
        }
        if (nScalarInd != -1 && nScalarInd != 0 && Vector.class.isInstance(params[nScalarInd])) {
            Vector cv = (Vector) params[nScalarInd];
            if (cv.size() == 0 || cv.elementAt(0) == null) return null;
            ret[nScalarInd - 1] = cv.elementAt(0);
        }
        return ret;
    }
",0
16246095,7,"    public String betterHand(Card[] myCards, Card[] opCards, Card[] boardCards) {
        int myHand = -1;
        int opHand = -1;
        Card tempCard;
        String result = """";
        myCombined = new Card[myCards.length + boardCards.length];
        opCombined = new Card[opCards.length + boardCards.length];
        for (int i = 0; i < myCards.length; i++) {
            myCombined[i] = myCards[i];
            opCombined[i] = opCards[i];
        }
        for (int i = 0; i < boardCards.length; i++) {
            myCombined[i + myCards.length] = boardCards[i];
            opCombined[i + opCards.length] = boardCards[i];
        }
        for (int i = 0; i < myCombined.length; i++) {
            for (int j = 0; j < myCombined.length - 1 - i; j++) {
                if (cardValueToInt(myCombined[j + 1].getValue()) > cardValueToInt(myCombined[j].getValue())) {
                    tempCard = myCombined[j];
                    myCombined[j] = myCombined[j + 1];
                    myCombined[j + 1] = tempCard;
                }
                if (cardValueToInt(opCombined[j + 1].getValue()) > cardValueToInt(opCombined[j].getValue())) {
                    tempCard = opCombined[j];
                    opCombined[j] = opCombined[j + 1];
                    opCombined[j + 1] = tempCard;
                }
            }
        }
        myHand = getHand(myCombined);
        opHand = getHand(opCombined);
        System.out.println(""MyHand= "" + myHand + "" OpHand= "" + opHand);
        if (myHand < opHand) {
            result = ""You Win!"";
        } else if (myHand > opHand) {
            result = ""You Lose!"";
        } else if (myHand == opHand) {
            if (myHand == HIGHCARD && (getHighCard(myCombined) > getHighCard(opCombined))) result = ""You Win!""; else if (myHand == HIGHCARD && (getHighCard(myCombined) < getHighCard(opCombined))) result = ""You Lose!""; else if (myHand == HIGHCARD && (getHighCard(myCombined) == getHighCard(opCombined))) {
                if (myHand == HIGHCARD && (get2ndHighCard(myCombined) > get2ndHighCard(opCombined))) result = ""You Win!""; else if (myHand == HIGHCARD && (get2ndHighCard(myCombined) < get2ndHighCard(opCombined))) result = ""You Lose!""; else if (myHand == HIGHCARD && (get2ndHighCard(myCombined) == get2ndHighCard(opCombined))) {
                    if (myHand == HIGHCARD && (get3rdHighCard(myCombined) > get3rdHighCard(opCombined))) result = ""You Win!""; else if (myHand == HIGHCARD && (get3rdHighCard(myCombined) < get3rdHighCard(opCombined))) result = ""You Lose!""; else if (myHand == HIGHCARD && (get3rdHighCard(myCombined) == get3rdHighCard(opCombined))) {
                        if (myHand == HIGHCARD && (get4thHighCard(myCombined) > get4thHighCard(opCombined))) result = ""You Win!""; else if (myHand == HIGHCARD && (get4thHighCard(myCombined) < get4thHighCard(opCombined))) result = ""You Lose!""; else if (myHand == HIGHCARD && (get4thHighCard(myCombined) == get4thHighCard(opCombined))) {
                            if (myHand == HIGHCARD && (get5thHighCard(myCombined) > get5thHighCard(opCombined))) result = ""You Win!""; else if (myHand == HIGHCARD && (get5thHighCard(myCombined) < get5thHighCard(opCombined))) result = ""You Lose!""; else if (myHand == HIGHCARD && (get5thHighCard(myCombined) == get5thHighCard(opCombined))) result = ""Push!"";
                        }
                    }
                }
            } else if (myHand == ONEPAIR && (getTopPair(myCombined) > getTopPair(opCombined))) result = ""You Win!""; else if (myHand == ONEPAIR && (getTopPair(myCombined) < getTopPair(opCombined))) result = ""You Lose!""; else if (myHand == ONEPAIR && (getTopPair(myCombined) == getTopPair(opCombined))) {
                if (getHighCard(myCombined) > getHighCard(opCombined)) result = ""You Win!""; else if (getHighCard(myCombined) < getHighCard(opCombined)) result = ""You Lose!""; else if (getHighCard(myCombined) == getHighCard(opCombined)) {
                    if (get2ndHighCard(myCombined) > get2ndHighCard(opCombined)) result = ""You Win!""; else if (get2ndHighCard(myCombined) < get2ndHighCard(opCombined)) result = ""You Lose!""; else {
                        if (get3rdHighCard(myCombined) > get3rdHighCard(opCombined)) result = ""You Win!""; else if (get3rdHighCard(myCombined) < get3rdHighCard(opCombined)) result = ""You Lose!""; else if (get3rdHighCard(myCombined) == get3rdHighCard(opCombined)) result = ""Push!"";
                    }
                }
            } else if (myHand == TWOPAIR && (getTopPair(myCombined) > getTopPair(opCombined))) result = ""You Win!""; else if (myHand == TWOPAIR && (getTopPair(myCombined) < getTopPair(opCombined))) result = ""You Lose!""; else if (myHand == TWOPAIR && (getBottomPair(myCombined) > getBottomPair(opCombined))) result = ""You Lose!""; else if (myHand == TWOPAIR && (getBottomPair(myCombined) < getBottomPair(opCombined))) result = ""You Lose!""; else if (myHand == TWOPAIR && (getHighCard(myCombined) > getHighCard(opCombined))) result = ""You Win!""; else if (myHand == TWOPAIR && (getHighCard(myCombined) < getHighCard(opCombined))) result = ""You Lose!""; else if (myHand == TWOPAIR && (getHighCard(myCombined) == getHighCard(opCombined))) result = ""Push!""; else if (myHand == THREEOFAKIND && (getTopThree(myCombined) > getTopThree(opCombined))) result = ""You Win!""; else if (myHand == THREEOFAKIND && (getTopThree(myCombined) < getTopThree(opCombined))) result = ""You Lose!""; else if (myHand == FULLHOUSE && (getTopThree(myCombined) > getTopThree(opCombined))) result = ""You Win!""; else if (myHand == FULLHOUSE && (getTopThree(myCombined) < getTopThree(opCombined))) result = ""You Lose!""; else if (myHand == STRAIGHT && (getHighStraight(myCombined) > getHighStraight(opCombined))) result = ""You Win!""; else if (myHand == STRAIGHT && (getHighStraight(myCombined) < getHighStraight(opCombined))) result = ""You Lose!""; else if (myHand == STRAIGHT && (getHighStraight(myCombined) == getHighStraight(opCombined))) result = ""Push!"";
        }
        return result;
    }
",1
924690,7,"    void removePoint(int index) {
        int npoints = x.length;
        int[] temp_x = new int[npoints - 1];
        int[] temp_y = new int[npoints - 1];
        for (int i = 0; i < index; i++) {
            temp_x[i] = x[i];
            temp_y[i] = y[i];
        }
        for (int j = index; j < npoints - 1; j++) {
            temp_x[j] = x[j + 1];
            temp_y[j] = y[j + 1];
        }
        x = temp_x;
        y = temp_y;
    }
",1
13380040,7,"    public void addFile(String name, String type) {
        int currentPosition = -1;
        for (int i = 0; i < MAX_FILES; i++) {
            if (files[i] != null && files[i].equals(name)) {
                currentPosition = i;
            }
        }
        if (currentPosition == 0) {
            return;
        }
        if (currentPosition > 0) {
            for (int i = currentPosition; i < MAX_FILES - 1; i++) {
                files[i] = files[i + 1];
                fileTypes[i + 1] = fileTypes[i];
            }
        }
        for (int j = MAX_FILES - 2; j >= 0; j--) {
            files[j + 1] = files[j];
            fileTypes[j + 1] = fileTypes[j];
        }
        files[0] = name;
        fileTypes[0] = type;
        fileList.setListData(files);
        fileList.setSelectedIndex(0);
        pack();
        saveList();
    }
",1
18224016,7,"        private Object transTypedArray(String[] array) {
            String type = array[0].substring(TYPED_ARRAY_SYMBOL.length());
            monitor.debug("" Transformed typed array: "" + type);
            if (type.equals(TA_INT1) || type.equals(TA_INT1J)) {
                byte[] ret = new byte[array.length - 1];
                for (int i = 0; i < ret.length; i++) {
                    ret[i] = Byte.parseByte(array[i + 1]);
                }
                return ret;
            } else if (type.equals(TA_INT2) || type.equals(TA_INT2J)) {
                short[] ret = new short[array.length - 1];
                for (int i = 0; i < ret.length; i++) {
                    ret[i] = Short.parseShort(array[i + 1]);
                }
                return ret;
            } else if (type.equals(TA_INT4) || type.equals(TA_INT4J)) {
                int[] ret = new int[array.length - 1];
                for (int i = 0; i < ret.length; i++) {
                    ret[i] = Integer.parseInt(array[i + 1]);
                }
                return ret;
            } else if (type.equals(TA_INT8) || type.equals(TA_INT8J)) {
                long[] ret = new long[array.length - 1];
                for (int i = 0; i < ret.length; i++) {
                    ret[i] = Long.parseLong(array[i + 1]);
                }
                return ret;
            } else if (type.equals(TA_FLOAT)) {
                float[] ret = new float[array.length - 1];
                for (int i = 0; i < ret.length; i++) {
                    ret[i] = Float.parseFloat(array[i + 1]);
                }
                return ret;
            } else if (type.equals(TA_DOUBLE)) {
                double[] ret = new double[array.length - 1];
                for (int i = 0; i < ret.length; i++) {
                    ret[i] = Double.parseDouble(array[i + 1]);
                }
                return ret;
            } else if (type.equals(TA_DECIMAL)) {
                BigDecimal[] ret = new BigDecimal[array.length - 1];
                for (int i = 0; i < ret.length; i++) {
                    ret[i] = new BigDecimal(array[i + 1]);
                }
                return ret;
            } else if (type.equals(TA_STRING)) {
                String[] ret = new String[array.length - 1];
                for (int i = 0; i < ret.length; i++) {
                    ret[i] = array[i + 1];
                }
                return ret;
            } else if (type.equals(TA_BOOLEAN)) {
                boolean[] ret = new boolean[array.length - 1];
                for (int i = 0; i < ret.length; i++) {
                    String a = array[i + 1];
                    ret[i] = (a != null || a.equalsIgnoreCase(""true""));
                }
                return ret;
            } else {
                throw new RuntimeException(""Wrong array type symbol:"" + type);
            }
        }
",1
3411096,7,"    public DoubleSquareMatrix[] singularValueDecompose() {
        int i, j, k;
        final int N = numRows;
        final int Nm1 = N - 1;
        final double array[][] = new double[N][N];
        final double arrayU[][] = new double[N][N];
        final double arrayS[] = new double[N];
        final double arrayV[][] = new double[N][N];
        final double e[] = new double[N];
        final double work[] = new double[N];
        array[0][0] = diag[0];
        array[0][1] = udiag[0];
        for (i = 1; i < Nm1; i++) {
            array[i][i - 1] = ldiag[i];
            array[i][i] = diag[i];
            array[i][i + 1] = udiag[i];
        }
        array[Nm1][Nm1 - 1] = ldiag[Nm1];
        array[Nm1][Nm1] = diag[Nm1];
        for (k = 0; k < Nm1; k++) {
            arrayS[k] = array[k][k];
            for (i = k + 1; i < N; i++) arrayS[k] = ExtraMath.hypot(arrayS[k], array[i][k]);
            if (arrayS[k] != 0.0) {
                if (array[k][k] < 0.0) arrayS[k] = -arrayS[k];
                for (i = k; i < N; i++) array[i][k] /= arrayS[k];
                array[k][k] += 1.0;
            }
            arrayS[k] = -arrayS[k];
            for (j = k + 1; j < N; j++) {
                if (arrayS[k] != 0.0) {
                    double t = 0.0;
                    for (i = k; i < N; i++) t += array[i][k] * array[i][j];
                    t /= -array[k][k];
                    for (i = k; i < N; i++) array[i][j] += t * array[i][k];
                }
                e[j] = array[k][j];
            }
            for (i = k; i < N; i++) arrayU[i][k] = array[i][k];
            if (k < N - 2) {
                e[k] = e[k + 1];
                for (i = k + 2; i < N; i++) e[k] = ExtraMath.hypot(e[k], e[i]);
                if (e[k] != 0.0) {
                    if (e[k + 1] < 0.0) e[k] = -e[k];
                    for (i = k + 1; i < N; i++) e[i] /= e[k];
                    e[k + 1] += 1.0;
                }
                e[k] = -e[k];
                if (e[k] != 0.0) {
                    for (i = k + 1; i < N; i++) {
                        work[i] = 0.0;
                        for (j = k + 1; j < N; j++) work[i] += e[j] * array[i][j];
                    }
                    for (j = k + 1; j < N; j++) {
                        double t = -e[j] / e[k + 1];
                        for (i = k + 1; i < N; i++) array[i][j] += t * work[i];
                    }
                }
                for (i = k + 1; i < N; i++) arrayV[i][k] = e[i];
            }
        }
        int p = N;
        arrayS[Nm1] = array[Nm1][Nm1];
        e[N - 2] = array[N - 2][Nm1];
        e[Nm1] = 0.0;
        for (i = 0; i < N; i++) arrayU[i][Nm1] = 0.0;
        arrayU[Nm1][Nm1] = 1.0;
        for (k = N - 2; k >= 0; k--) {
            if (arrayS[k] != 0.0) {
                for (j = k + 1; j < N; j++) {
                    double t = arrayU[k][k] * arrayU[k][j];
                    for (i = k + 1; i < N; i++) t += arrayU[i][k] * arrayU[i][j];
                    t /= -arrayU[k][k];
                    for (i = k; i < N; i++) arrayU[i][j] += t * arrayU[i][k];
                }
                for (i = k; i < N; i++) arrayU[i][k] = -arrayU[i][k];
                arrayU[k][k] += 1.0;
                for (i = 0; i < k - 1; i++) arrayU[i][k] = 0.0;
            } else {
                for (i = 0; i < N; i++) arrayU[i][k] = 0.0;
                arrayU[k][k] = 1.0;
            }
        }
        for (k = Nm1; k >= 0; k--) {
            if (k < N - 2 && e[k] != 0.0) {
                for (j = k + 1; j < N; j++) {
                    double t = arrayV[k + 1][k] * arrayV[k + 1][j];
                    for (i = k + 2; i < N; i++) t += arrayV[i][k] * arrayV[i][j];
                    t /= -arrayV[k + 1][k];
                    for (i = k + 1; i < N; i++) arrayV[i][j] += t * arrayV[i][k];
                }
            }
            for (i = 0; i < N; i++) arrayV[i][k] = 0.0;
            arrayV[k][k] = 1.0;
        }
        final double eps = Math.pow(2.0, -52.0);
        int iter = 0;
        while (p > 0) {
            int action;
            for (k = p - 2; k >= -1; k--) {
                if (k == -1) break;
                if (Math.abs(e[k]) <= eps * (Math.abs(arrayS[k]) + Math.abs(arrayS[k + 1]))) {
                    e[k] = 0.0;
                    break;
                }
            }
            if (k == p - 2) {
                action = 4;
            } else {
                int ks;
                for (ks = p - 1; ks >= k; ks--) {
                    if (ks == k) break;
                    double t = (ks != p ? Math.abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.abs(e[ks - 1]) : 0.0);
                    if (Math.abs(arrayS[ks]) <= eps * t) {
                        arrayS[ks] = 0.0;
                        break;
                    }
                }
                if (ks == k) {
                    action = 3;
                } else if (ks == p - 1) {
                    action = 1;
                } else {
                    action = 2;
                    k = ks;
                }
            }
            k++;
            switch(action) {
                case 1:
                    {
                        double f = e[p - 2];
                        e[p - 2] = 0.0;
                        for (j = p - 2; j >= k; j--) {
                            double t = ExtraMath.hypot(arrayS[j], f);
                            final double cs = arrayS[j] / t;
                            final double sn = f / t;
                            arrayS[j] = t;
                            if (j != k) {
                                f = -sn * e[j - 1];
                                e[j - 1] *= cs;
                            }
                            for (i = 0; i < N; i++) {
                                t = cs * arrayV[i][j] + sn * arrayV[i][p - 1];
                                arrayV[i][p - 1] = -sn * arrayV[i][j] + cs * arrayV[i][p - 1];
                                arrayV[i][j] = t;
                            }
                        }
                    }
                    break;
                case 2:
                    {
                        double f = e[k - 1];
                        e[k - 1] = 0.0;
                        for (j = k; j < p; j++) {
                            double t = ExtraMath.hypot(arrayS[j], f);
                            final double cs = arrayS[j] / t;
                            final double sn = f / t;
                            arrayS[j] = t;
                            f = -sn * e[j];
                            e[j] *= cs;
                            for (i = 0; i < N; i++) {
                                t = cs * arrayU[i][j] + sn * arrayU[i][k - 1];
                                arrayU[i][k - 1] = -sn * arrayU[i][j] + cs * arrayU[i][k - 1];
                                arrayU[i][j] = t;
                            }
                        }
                    }
                    break;
                case 3:
                    {
                        final double scale = Math.max(Math.max(Math.max(Math.max(Math.abs(arrayS[p - 1]), Math.abs(arrayS[p - 2])), Math.abs(e[p - 2])), Math.abs(arrayS[k])), Math.abs(e[k]));
                        double sp = arrayS[p - 1] / scale;
                        double spm1 = arrayS[p - 2] / scale;
                        double epm1 = e[p - 2] / scale;
                        double sk = arrayS[k] / scale;
                        double ek = e[k] / scale;
                        double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
                        double c = (sp * epm1) * (sp * epm1);
                        double shift = 0.0;
                        if (b != 0.0 || c != 0.0) {
                            shift = Math.sqrt(b * b + c);
                            if (b < 0.0) shift = -shift;
                            shift = c / (b + shift);
                        }
                        double f = (sk + sp) * (sk - sp) + shift;
                        double g = sk * ek;
                        for (j = k; j < p - 1; j++) {
                            double t = ExtraMath.hypot(f, g);
                            double cs = f / t;
                            double sn = g / t;
                            if (j != k) e[j - 1] = t;
                            f = cs * arrayS[j] + sn * e[j];
                            e[j] = cs * e[j] - sn * arrayS[j];
                            g = sn * arrayS[j + 1];
                            arrayS[j + 1] *= cs;
                            for (i = 0; i < N; i++) {
                                t = cs * arrayV[i][j] + sn * arrayV[i][j + 1];
                                arrayV[i][j + 1] = -sn * arrayV[i][j] + cs * arrayV[i][j + 1];
                                arrayV[i][j] = t;
                            }
                            t = ExtraMath.hypot(f, g);
                            cs = f / t;
                            sn = g / t;
                            arrayS[j] = t;
                            f = cs * e[j] + sn * arrayS[j + 1];
                            arrayS[j + 1] = -sn * e[j] + cs * arrayS[j + 1];
                            g = sn * e[j + 1];
                            e[j + 1] *= cs;
                            if (j < Nm1) {
                                for (i = 0; i < N; i++) {
                                    t = cs * arrayU[i][j] + sn * arrayU[i][j + 1];
                                    arrayU[i][j + 1] = -sn * arrayU[i][j] + cs * arrayU[i][j + 1];
                                    arrayU[i][j] = t;
                                }
                            }
                        }
                        e[p - 2] = f;
                        iter++;
                    }
                    break;
                case 4:
                    {
                        if (arrayS[k] <= 0.0) {
                            arrayS[k] = -arrayS[k];
                            for (i = 0; i < p; i++) arrayV[i][k] = -arrayV[i][k];
                        }
                        while (k < p - 1) {
                            if (arrayS[k] >= arrayS[k + 1]) break;
                            double tmp = arrayS[k];
                            arrayS[k] = arrayS[k + 1];
                            arrayS[k + 1] = tmp;
                            if (k < Nm1) {
                                for (i = 0; i < N; i++) {
                                    tmp = arrayU[i][k + 1];
                                    arrayU[i][k + 1] = arrayU[i][k];
                                    arrayU[i][k] = tmp;
                                    tmp = arrayV[i][k + 1];
                                    arrayV[i][k + 1] = arrayV[i][k];
                                    arrayV[i][k] = tmp;
                                }
                            }
                            k++;
                        }
                        iter = 0;
                        p--;
                    }
                    break;
            }
        }
        final DoubleSquareMatrix svd[] = new DoubleSquareMatrix[3];
        svd[0] = new DoubleSquareMatrix(arrayU);
        svd[1] = new DoubleDiagonalMatrix(arrayS);
        svd[2] = new DoubleSquareMatrix(arrayV);
        return svd;
    }
",1
15502175,7,"            public void actionPerformed(ActionEvent e) {
                defaultOut = System.out;
                OutputStream out = new OutputStream() {

                    private StringBuilder sb = new StringBuilder();

                    private String endLineMark = System.getProperty(""line.separator"");

                    private int endLineMarkLength = endLineMark.length();

                    private char[] buff = new char[endLineMarkLength];

                    @Override
                    public void write(int b) throws IOException {
                        sb.append((char) b);
                        for (int i = 0; i < buff.length - 1; i++) {
                            buff[i] = buff[i + 1];
                        }
                        buff[buff.length - 1] = (char) b;
                        String tmp = String.valueOf(buff);
                        if (tmp.equals(endLineMark)) {
                            textPane.setText(sb.toString());
                        }
                    }
                };
                PrintStream newOut = new PrintStream(out);
                System.setOut(newOut);
            }
",0
18585843,7,"    protected void transform() {
        if (transformed || nvert <= 0) return;
        if (tvert == null || tvert.length < nvert * 3) tvert = new int[nvert * 3];
        float temp[] = new float[4];
        for (int i = nvert * 3; (i -= 3) >= 0; ) {
            temp[0] = vert[i];
            temp[1] = vert[i + 1];
            temp[2] = vert[i + 2];
            temp[3] = 1.0f;
            float[] newVert = mat.mult(temp);
            tvert[i] = (int) newVert[0];
            tvert[i + 1] = (int) newVert[1];
            tvert[i + 2] = (int) newVert[2];
            transformed = true;
        }
    }
",1
13629862,7,"    public static double[] interpolate(double[] x, double[] y, double[] xi) throws IllegalArgumentException {
        if (x.length != y.length) {
            throw new IllegalArgumentException(""X and Y must be the same length"");
        }
        if (x.length == 1) {
            throw new IllegalArgumentException(""X must contain more than one value"");
        }
        double[] dx = new double[x.length - 1];
        double[] dy = new double[x.length - 1];
        double[] slope = new double[x.length - 1];
        double[] intercept = new double[x.length - 1];
        for (int i = 0; i < x.length - 1; i++) {
            dx[i] = x[i + 1] - x[i];
            if (dx[i] == 0) {
                throw new IllegalArgumentException(""X must be montotonic. A duplicate "" + ""x-value was found"");
            }
            if (dx[i] < 0) {
                throw new IllegalArgumentException(""X must be sorted"");
            }
            dy[i] = y[i + 1] - y[i];
            slope[i] = dy[i] / dx[i];
            intercept[i] = y[i] - x[i] * slope[i];
        }
        double[] yi = new double[xi.length];
        for (int i = 0; i < xi.length; i++) {
            if ((xi[i] > x[x.length - 1]) || (xi[i] < x[0])) {
                yi[i] = Double.NaN;
            } else {
                int loc = Arrays.binarySearch(x, xi[i]);
                if (loc < -1) {
                    loc = -loc - 2;
                    yi[i] = slope[loc] * xi[i] + intercept[loc];
                } else {
                    yi[i] = y[loc];
                }
            }
        }
        return yi;
    }
",1
2571940,7,"    public void changeFolder(FolderItemListLayout folder, String tag) {
        List<AICFile> files = new ArrayList<AICFile>();
        if (tag.startsWith(""@"")) {
            List<JsonObject> file2 = new ArrayList<JsonObject>();
            try {
                file2.addAll(CloudFileManagementService.get_contents_by_tag(model.getSessionId(), tag));
            } catch (Exception e) {
                e.printStackTrace();
            }
            for (int i = 0; i < file2.size(); i++) {
                AICFile file = new AICFile();
                JsonObject jfile = file2.get(i);
                file.setName(jfile.getValue(""name"").toString());
                file.setKey(jfile.getValue(""key"").toString());
                file.setContent_type(jfile.getValue(""content_type"").toString());
                file.setLast_modified(jfile.getValue(""last_modified"").toString());
                file.setIs_shared(jfile.getValue(""is_shared"").toString());
                try {
                    file.setFile_type(jfile.getValue(""file_type"").toString());
                } catch (NullPointerException e) {
                    Log.d(""CLOUD_DEBUG"", ""No_type"");
                }
                Log.d(""CLOUD_DEBUG_jfile"", jfile.toString());
                files.add(file);
            }
        } else if (tag.startsWith(""#"")) {
            String ttag = tag.substring(1);
            List<JsonObject> file2 = new ArrayList<JsonObject>();
            String filePath = ""/"" + ttag;
            try {
                file2.addAll(LocalPhoneFileManagementService.get_contents_by_tag_local(filePath));
            } catch (Exception e) {
                e.printStackTrace();
            }
            for (int i = 0; i < file2.size(); i++) {
                AICFile file = new AICFile();
                JsonObject jfile = file2.get(i);
                file.setName(jfile.getValue(""name"").toString());
                file.setKey(""wei jiang key"");
                file.setContent_type(jfile.getValue(""content_type"").toString());
                Log.d(""content_type"", jfile.getValue(""content_type"").toString());
                file.setLast_modified(""wei jiang last modified"");
                file.setIs_shared(""wei jiang is shared"");
                Log.d(""PHONE_DEBUG"", jfile.toString());
                files.add(file);
            }
        }
        folder.getModel().setFiles(files);
        folder.getModel().setFolderTag(tag);
        String[] recent = model.getRecent();
        boolean full = true;
        for (int i = 0; i < recent.length; i++) {
            if (recent[i].equals(tag)) {
                full = false;
                break;
            }
            if (recent[i].equals("""")) {
                recent[i] = tag;
                full = false;
                break;
            }
        }
        if (full) {
            for (int i = 0; i < recent.length - 1; i++) {
                recent[i] = recent[i + 1];
            }
            recent[recent.length - 1] = tag;
        }
        activity.refresh();
        folder.refresh();
    }
",0
74585,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
9105957,7,"    public double[] runWithoutAnnealing(boolean tuneScalingFactor, double startScale, double temperature) {
        double[] weights = runLBFGSSolver(tuneScalingFactor, startScale, temperature);
        if (tuneScalingFactor) {
            System.out.println(""optimal scaling factor is "" + weights[0]);
            double[] res = new double[numParameters];
            for (int i = 0; i < numParameters; i++) res[i] = weights[i + 1];
            return res;
        } else {
            return weights;
        }
    }
",1
1627415,7,"    public static String getSimpleTableHtmlString(String[] headings, String[] values) {
        String table = ""<table class=\""details\"" border=\""0\"" cellpadding=\""5\"" cellspacing=\""2\"" width=\""95%\"">\n"";
        String row = """";
        if (headings.length > 0) {
            row = ""<tr valign=\""top\"">\n"";
            String key = headings[0];
            String[] tmpHeadings = new String[headings.length - 1];
            for (int i = 0; i < tmpHeadings.length; i++) {
                tmpHeadings[i] = headings[i + 1];
            }
            table = table + getSimpleNormalHeadingHtml(key, tmpHeadings) + ""\n"";
            row = row + ""<td  rowspan=\""1\"" valign=\""top\""> "" + values[0] + "" </td>\n"";
            for (int i = 1; i < headings.length; i++) {
                row = row + ""<td>"" + values[i] + ""  </td>\n"";
            }
            row = row + ""</tr>\n"";
        }
        table = table + row + ""</table> \n"";
        return table;
    }
",1
5180407,7,"    }

    /**
   * Sets the default offset amount
   * @param offsetAmount Default offset amount for each parmater in the list
   */
    public void setOffset(float offsetAmount) {
",1
22584709,7,"    public static int[] src(int[] op, int lr, int al, int count) {
        int len = op.length;
        int[] res = new int[len];
        if (lr == 0) {
            if (al == 0) {
                for (int i = 0; i < count; i++) {
                    for (int j = len - 1; j > 1; j--) {
                        res[j - 1] = op[j];
                    }
                    res[1] = 0;
                }
            } else {
                for (int i = 0; i < count; i++) {
                    for (int j = len - 1; j > 0; j--) {
                        res[j - 1] = op[j];
                    }
                    res[0] = 0;
                }
            }
        } else {
            if (al == 0) {
                for (int i = 0; i < count; i++) {
                    for (int j = 1; j < len - 1; j++) {
                        res[j] = op[j + 1];
                    }
                    res[len - 1] = 0;
                }
            } else {
                for (int i = 0; i < count; i++) {
                    for (int j = 0; j < len - 1; j++) {
                        res[j] = op[j + 1];
                    }
                    res[len - 1] = 0;
                }
            }
        }
        return res;
    }
",1
944603,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
17956330,7,"		void rollFw(String aLine, int aNewPosition) {
			synchronized(this) {
				for (int i=0; i<content.length-1; i++) {
					content[i] = content[i + 1];
					positions[i] = positions[i + 1];
				}
				positions[content.length - 1] = positions[content.length];
				content[content.length - 1] = aLine;
				positions[positions.length - 1] = aNewPosition;
			}
		}
",1
15495141,7,"    public boolean removeValueAt(int index) {
        if (index >= size) return false;
        for (int i = index; i < size; i++) {
            list[i] = list[i + 1];
        }
        size--;
        return true;
    }
",0
626857,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
3172481,7,"    public void removeIntArrayColumn(int[][] cons2, int start) {
        int length = getWidth();
        int cons2leng = cons2.length;
        for (int k = start; k < (cons2leng - 1); k++) {
            cons2[k] = cons2[k + 1];
        }
    }
",0
921066,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
20452135,7,"        @Override
        protected String[] searchForWordsInFields(String[] words, String adapter, String specificColumnID, String generalColumnID, String columnLast, String columnFirst, String table) {
            String whereClause = """";
            for (@SuppressWarnings(""unused"") String word : words) {
                if (!whereClause.equals("""")) {
                    whereClause += "" OR "";
                }
                whereClause += ""(to_tsvector('"" + regconfig + ""', lower("" + columnLast + "")) @@ to_tsquery( lower(?) )) OR "" + ""(to_tsvector('"" + regconfig + ""', lower("" + columnFirst + "")) @@ to_tsquery( lower(?) ))"";
            }
            String[] result;
            if (words.length > 0) {
                result = new String[2 * words.length + 1];
                result[0] = ""SELECT "" + COLUMN_DOCUMENT_ID + "" FROM (SELECT "" + generalColumnID + "" FROM "" + table + "" WHERE "" + whereClause + "") AS alias0 JOIN "" + adapter + "" ON("" + specificColumnID + ""="" + generalColumnID + "")"";
                for (int i = 1; i < result.length; i = i + 2) {
                    result[i] = result[i + 1] = words[(i - 1) / 2];
                }
            } else {
                result = new String[0];
            }
            return result;
        }
",0
7998950,7,"    public Vset checkValue(Environment env, Context ctx, Vset vset, Hashtable exp) {
        ClassDeclaration c = null;
        boolean isArray = false;
        boolean staticRef = false;
        MemberDefinition implMethod = null;
        ClassDefinition ctxClass = ctx.field.getClassDefinition();
        Expression args[] = this.args;
        if (id.equals(idInit)) {
            ClassDefinition conCls = ctxClass;
            try {
                Expression conOuter = null;
                if (right instanceof SuperExpression) {
                    conCls = conCls.getSuperClass().getClassDefinition(env);
                    conOuter = ((SuperExpression) right).outerArg;
                } else if (right instanceof ThisExpression) {
                    conOuter = ((ThisExpression) right).outerArg;
                }
                args = NewInstanceExpression.insertOuterLink(env, ctx, where, conCls, conOuter, args);
            } catch (ClassNotFound ee) {
            }
        }
        Type argTypes[] = new Type[args.length];
        ClassDefinition sourceClass = ctxClass;
        try {
            if (right == null) {
                staticRef = ctx.field.isStatic();
                ClassDefinition cdef = ctxClass;
                MemberDefinition m = null;
                for (; cdef != null; cdef = cdef.getOuterClass()) {
                    m = cdef.findAnyMethod(env, id);
                    if (m != null) {
                        break;
                    }
                }
                if (m == null) {
                    c = ctx.field.getClassDeclaration();
                } else {
                    c = cdef.getClassDeclaration();
                    if (m.getClassDefinition() != cdef) {
                        ClassDefinition cdef2 = cdef;
                        while ((cdef2 = cdef2.getOuterClass()) != null) {
                            MemberDefinition m2 = cdef2.findAnyMethod(env, id);
                            if (m2 != null && m2.getClassDefinition() == cdef2) {
                                env.error(where, ""inherited.hides.method"", id, cdef.getClassDeclaration(), cdef2.getClassDeclaration());
                                break;
                            }
                        }
                    }
                }
            } else {
                if (id.equals(idInit)) {
                    int thisN = ctx.getThisNumber();
                    if (!ctx.field.isConstructor()) {
                        env.error(where, ""invalid.constr.invoke"");
                        return vset.addVar(thisN);
                    }
                    if (!vset.isReallyDeadEnd() && vset.testVar(thisN)) {
                        env.error(where, ""constr.invoke.not.first"");
                        return vset;
                    }
                    vset = vset.addVar(thisN);
                    if (right instanceof SuperExpression) {
                        vset = right.checkAmbigName(env, ctx, vset, exp, this);
                    } else {
                        vset = right.checkValue(env, ctx, vset, exp);
                    }
                } else {
                    vset = right.checkAmbigName(env, ctx, vset, exp, this);
                    if (right.type == Type.tPackage) {
                        FieldExpression.reportFailedPackagePrefix(env, right);
                        return vset;
                    }
                    if (right instanceof TypeExpression) {
                        staticRef = true;
                    }
                }
                if (right.type.isType(TC_CLASS)) {
                    c = env.getClassDeclaration(right.type);
                } else if (right.type.isType(TC_ARRAY)) {
                    isArray = true;
                    c = env.getClassDeclaration(Type.tObject);
                } else {
                    if (!right.type.isType(TC_ERROR)) {
                        env.error(where, ""invalid.method.invoke"", right.type);
                    }
                    return vset;
                }
                if (right instanceof FieldExpression) {
                    Identifier id = ((FieldExpression) right).id;
                    if (id == idThis) {
                        sourceClass = ((FieldExpression) right).clazz;
                    } else if (id == idSuper) {
                        isSuper = true;
                        sourceClass = ((FieldExpression) right).clazz;
                    }
                } else if (right instanceof SuperExpression) {
                    isSuper = true;
                }
                if (id != idInit) {
                    if (!FieldExpression.isTypeAccessible(where, env, right.type, sourceClass)) {
                        ClassDeclaration cdecl = sourceClass.getClassDeclaration();
                        if (staticRef) {
                            env.error(where, ""no.type.access"", id, right.type.toString(), cdecl);
                        } else {
                            env.error(where, ""cant.access.member.type"", id, right.type.toString(), cdecl);
                        }
                    }
                }
            }
            boolean hasErrors = false;
            if (id.equals(idInit)) {
                vset = vset.clearVar(ctx.getThisNumber());
            }
            for (int i = 0; i < args.length; i++) {
                vset = args[i].checkValue(env, ctx, vset, exp);
                argTypes[i] = args[i].type;
                hasErrors = hasErrors || argTypes[i].isType(TC_ERROR);
            }
            if (id.equals(idInit)) {
                vset = vset.addVar(ctx.getThisNumber());
            }
            if (hasErrors) {
                return vset;
            }
            clazz = c.getClassDefinition(env);
            if (field == null) {
                field = clazz.matchMethod(env, sourceClass, id, argTypes);
                if (field == null) {
                    if (id.equals(idInit)) {
                        if (diagnoseMismatch(env, args, argTypes)) return vset;
                        String sig = clazz.getName().getName().toString();
                        sig = Type.tMethod(Type.tError, argTypes).typeString(sig, false, false);
                        env.error(where, ""unmatched.constr"", sig, c);
                        return vset;
                    }
                    String sig = id.toString();
                    sig = Type.tMethod(Type.tError, argTypes).typeString(sig, false, false);
                    if (clazz.findAnyMethod(env, id) == null) {
                        if (ctx.getField(env, id) != null) {
                            env.error(where, ""invalid.method"", id, c);
                        } else {
                            env.error(where, ""undef.meth"", sig, c);
                        }
                    } else if (diagnoseMismatch(env, args, argTypes)) {
                    } else {
                        env.error(where, ""unmatched.meth"", sig, c);
                    }
                    return vset;
                }
            }
            type = field.getType().getReturnType();
            if (staticRef && !field.isStatic()) {
                env.error(where, ""no.static.meth.access"", field, field.getClassDeclaration());
                return vset;
            }
            if (field.isProtected() && !(right == null) && !(right instanceof SuperExpression || (right instanceof FieldExpression && ((FieldExpression) right).id == idSuper)) && !sourceClass.protectedAccess(env, field, right.type)) {
                env.error(where, ""invalid.protected.method.use"", field.getName(), field.getClassDeclaration(), right.type);
                return vset;
            }
            if (right instanceof FieldExpression && ((FieldExpression) right).id == idSuper) {
                if (!field.isPrivate()) {
                    if (sourceClass != ctxClass) {
                        implMethod = sourceClass.getAccessMember(env, ctx, field, true);
                    }
                }
            }
            if (implMethod == null && field.isPrivate()) {
                ClassDefinition cdef = field.getClassDefinition();
                if (cdef != ctxClass) {
                    implMethod = cdef.getAccessMember(env, ctx, field, false);
                }
            }
            if (field.isAbstract() && (right != null) && (right.op == SUPER)) {
                env.error(where, ""invoke.abstract"", field, field.getClassDeclaration());
                return vset;
            }
            if (field.reportDeprecated(env)) {
                if (field.isConstructor()) {
                    env.error(where, ""warn.constr.is.deprecated"", field);
                } else {
                    env.error(where, ""warn.meth.is.deprecated"", field, field.getClassDefinition());
                }
            }
            if (field.isConstructor() && ctx.field.equals(field)) {
                env.error(where, ""recursive.constr"", field);
            }
            if (sourceClass == ctxClass) {
                ClassDefinition declarer = field.getClassDefinition();
                if (!field.isConstructor() && declarer.isPackagePrivate() && !declarer.getName().getQualifier().equals(sourceClass.getName().getQualifier())) {
                    field = MemberDefinition.makeProxyMember(field, clazz, env);
                }
            }
            sourceClass.addDependency(field.getClassDeclaration());
            if (sourceClass != ctxClass) {
                ctxClass.addDependency(field.getClassDeclaration());
            }
        } catch (ClassNotFound ee) {
            env.error(where, ""class.not.found"", ee.name, ctx.field);
            return vset;
        } catch (AmbiguousMember ee) {
            env.error(where, ""ambig.field"", id, ee.field1, ee.field2);
            return vset;
        }
        if ((right == null) && !field.isStatic()) {
            right = ctx.findOuterLink(env, where, field);
            vset = right.checkValue(env, ctx, vset, exp);
        }
        argTypes = field.getType().getArgumentTypes();
        for (int i = 0; i < args.length; i++) {
            args[i] = convert(env, ctx, argTypes[i], args[i]);
        }
        if (field.isConstructor()) {
            MemberDefinition m = field;
            if (implMethod != null) {
                m = implMethod;
            }
            int nargs = args.length;
            Expression[] newargs = args;
            if (nargs > this.args.length) {
                Expression rightI;
                if (right instanceof SuperExpression) {
                    rightI = new SuperExpression(right.where, ctx);
                    ((SuperExpression) right).outerArg = args[0];
                } else if (right instanceof ThisExpression) {
                    rightI = new ThisExpression(right.where, ctx);
                } else {
                    throw new CompilerError(""this.init"");
                }
                if (implMethod != null) {
                    newargs = new Expression[nargs + 1];
                    this.args = new Expression[nargs];
                    newargs[0] = args[0];
                    this.args[0] = newargs[1] = new NullExpression(where);
                    for (int i = 1; i < nargs; i++) {
                        this.args[i] = newargs[i + 1] = args[i];
                    }
                } else {
                    for (int i = 1; i < nargs; i++) {
                        this.args[i - 1] = args[i];
                    }
                }
                implementation = new MethodExpression(where, rightI, m, newargs);
                implementation.type = type;
            } else {
                if (implMethod != null) {
                    newargs = new Expression[nargs + 1];
                    newargs[0] = new NullExpression(where);
                    for (int i = 0; i < nargs; i++) {
                        newargs[i + 1] = args[i];
                    }
                }
                implementation = new MethodExpression(where, right, m, newargs);
            }
        } else {
            if (args.length > this.args.length) {
                throw new CompilerError(""method arg"");
            }
            if (implMethod != null) {
                Expression oldargs[] = this.args;
                if (field.isStatic()) {
                    Expression call = new MethodExpression(where, null, implMethod, oldargs);
                    implementation = new CommaExpression(where, right, call);
                } else {
                    int nargs = oldargs.length;
                    Expression newargs[] = new Expression[nargs + 1];
                    newargs[0] = right;
                    for (int i = 0; i < nargs; i++) {
                        newargs[i + 1] = oldargs[i];
                    }
                    implementation = new MethodExpression(where, null, implMethod, newargs);
                }
            }
        }
        if (ctx.field.isConstructor() && field.isConstructor() && (right != null) && (right.op == SUPER)) {
            Expression e = makeVarInits(env, ctx);
            if (e != null) {
                if (implementation == null) implementation = (Expression) this.clone();
                implementation = new CommaExpression(where, implementation, e);
            }
        }
        ClassDeclaration exceptions[] = field.getExceptions(env);
        if (isArray && (field.getName() == idClone) && (field.getType().getArgumentTypes().length == 0)) {
            exceptions = new ClassDeclaration[0];
            for (Context p = ctx; p != null; p = p.prev) {
                if (p.node != null && p.node.op == TRY) {
                    ((TryStatement) p.node).arrayCloneWhere = where;
                }
            }
        }
        for (int i = 0; i < exceptions.length; i++) {
            if (exp.get(exceptions[i]) == null) {
                exp.put(exceptions[i], this);
            }
        }
        if (ctx.field.isConstructor() && field.isConstructor() && (right != null) && (right.op == THIS)) {
            ClassDefinition cls = field.getClassDefinition();
            for (MemberDefinition f = cls.getFirstMember(); f != null; f = f.getNextMember()) {
                if (f.isVariable() && f.isBlankFinal() && !f.isStatic()) {
                    vset = vset.addVar(ctx.getFieldNumber(f));
                }
            }
        }
        return vset;
    }
",1
17627331,7,"    public static final void fir_mem2(final float[] x, final int xs, final float[] num, final float[] y, final int ys, final int N, final int ord, final float[] mem) {
        int i, j;
        float xi;
        for (i = 0; i < N; i++) {
            xi = x[xs + i];
            y[ys + i] = num[0] * xi + mem[0];
            for (j = 0; j < ord - 1; j++) {
                mem[j] = mem[j + 1] + num[j + 1] * xi;
            }
            mem[ord - 1] = num[ord] * xi;
        }
    }
",1
14626324,7,"    public double[] getClosestPoint(double x, double y) {
        double point[] = { 0.0, 0.0, 0.0 };
        int i;
        double xdiff, ydiff, dist2;
        xdiff = data[0] - x;
        ydiff = data[1] - y;
        point[0] = data[0];
        point[1] = data[1];
        point[2] = xdiff * xdiff + ydiff * ydiff;
        for (i = stride; i < length - 1; i += stride) {
            xdiff = data[i] - x;
            ydiff = data[i + 1] - y;
            dist2 = xdiff * xdiff + ydiff * ydiff;
            if (dist2 < point[2]) {
                point[0] = data[i];
                point[1] = data[i + 1];
                point[2] = dist2;
            }
        }
        return point;
    }
",1
1094717,7,"    public static void main(String[] args) {
        String[] args1;
        if (args == null || args.length == 0) {
            System.out.println(""Error No class to run"");
            return;
        } else if (args.length < 2) {
            args1 = new String[0];
        } else {
            args1 = new String[args.length - 1];
            for (int i = 0; i < args.length - 1; i++) {
                args1[i] = args[i + 1];
            }
        }
        new Run(Run.SYSTEM_JARS_FILENAME, JARS, args[0], args1);
    }
",1
661927,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
420195,7,"    public boolean delete(long value) {
        int j = find(value);
        if (j == nElems) return false; else {
            for (int k = j; k < nElems; k++) a[k] = a[k + 1];
            nElems--;
            return true;
        }
    }
",1
15095879,7,"    public void setAttributes(Attribute[] attrs) {
        for (int i = 0; i < attrs.length; i++) {
            if (attrs[i].getName().contains("".csv"")) {
                Attribute[] attrs2 = new Attribute[attrs.length - 1];
                for (int j = 0; j < i; j++) {
                    attrs2[j] = attrs[j];
                }
                for (int j = i; j < attrs2.length; j++) {
                    attrs2[j] = attrs[j + 1];
                }
                attrs = attrs2;
                i = -1;
            }
        }
        super.setAttributes(attrs);
        allAttributes = null;
    }
",1
13451846,7,"    private void statistiken() {
        historyswitch++;
        if (historyswitch == 3) {
            if (historycountereinmaldurch == false) {
                geldhistory[historycounter] = (int) getGeld();
                firmenwerthistory[historycounter] = (int) getFirmenwert();
                if (geldhistory[historycounter] == 0) {
                    geldhistory[historycounter] = -1;
                }
                if (firmenwerthistory[historycounter] == 0) {
                    firmenwerthistory[historycounter] = -1;
                }
                historycounter++;
                if (historycounter == Master.OPTIONEN.getMaximumDiagramm()) {
                    historycountereinmaldurch = true;
                }
            } else {
                for (int i = 0; i < Master.OPTIONEN.getMaximumDiagramm() - 1; i++) {
                    geldhistory[i] = geldhistory[i + 1];
                    firmenwerthistory[i] = firmenwerthistory[i + 1];
                }
                geldhistory[Master.OPTIONEN.getMaximumDiagramm() - 1] = (int) getGeld();
                firmenwerthistory[Master.OPTIONEN.getMaximumDiagramm() - 1] = (int) getFirmenwert();
                if (geldhistory[Master.OPTIONEN.getMaximumDiagramm() - 1] == 0) {
                    geldhistory[Master.OPTIONEN.getMaximumDiagramm() - 1] = -1;
                }
                if (firmenwerthistory[Master.OPTIONEN.getMaximumDiagramm() - 1] == 0) {
                    firmenwerthistory[Master.OPTIONEN.getMaximumDiagramm() - 1] = -1;
                }
            }
            historyswitch = 0;
        }
    }
",1
20700367,7,"    private GeoShape readPolyline(boolean isClosed, char ptType) throws IOException {
        readDouble(shpStream);
        readDouble(shpStream);
        readDouble(shpStream);
        readDouble(shpStream);
        int nParts = readInt(shpStream);
        int nPoints = readInt(shpStream);
        int parts[] = new int[nParts];
        for (int i = 0; i < nParts; i++) {
            parts[i] = readInt(shpStream);
        }
        int nums[] = new int[nParts];
        for (int i = 0; i < nParts; i++) {
            if (i != nParts - 1) {
                nums[i] = parts[i + 1] - parts[i];
            } else {
                nums[i] = nPoints - parts[i];
            }
        }
        GeoCoord[] coords = new GeoCoord[nPoints];
        for (int i = 0; i < nPoints; i++) {
            double lon = readDouble(shpStream);
            double lat = readDouble(shpStream);
            coords[i] = new GeoCoord(lat, lon);
        }
        if (ptType == 'Z') {
            double[] alts = readDoubleRange(nPoints);
            for (int i = 0; i < nPoints; i++) {
                coords[i].setAltitude(alts[i]);
            }
        }
        if (ptType == 'M' || ptType == 'Z') {
            readDoubleRange(nPoints);
        }
        GeoMultiShape multi = new GeoMultiShape();
        for (int i = 0; i < nParts; i++) {
            int partPts = nums[i];
            GeoCoord[] polyCoords = new GeoCoord[partPts];
            for (int j = 0; j < partPts; j++) {
                polyCoords[j] = coords[parts[i] + j];
            }
            if (isClosed) {
                multi.add(new GeoPolygon(polyCoords));
            } else {
                multi.add(new GeoPolyline(polyCoords));
            }
        }
        return (multi.size() == 1) ? multi.get(0) : multi;
    }
",0
8112205,7,"    private void loadLM(File arpa) throws NumberFormatException, IOException {
        if (!arpa.exists()) {
            return;
        }
        BufferedReader rd = new BufferedReader(new FileReader(arpa.getAbsolutePath()));
        String str;
        int order = 100;
        String[] typeBuffer = null;
        while ((str = rd.readLine()) != null) {
            if (str.length() == 0) {
                continue;
            }
            if (str.charAt(0) == '\\') {
                String p = str.substring(1, 2);
                try {
                    order = Integer.parseInt(p);
                } catch (Throwable e) {
                    continue;
                }
                if (order == 0) continue;
                typeBuffer = new String[order];
                continue;
            }
            String[] slots = str.split(""\\s+"");
            if (slots.length > order) {
                double prob = Double.parseDouble(slots[0]);
                for (int i = 0; i < order; i++) {
                    typeBuffer[i] = slots[i + 1];
                }
                double bow = 0;
                if (slots.length > order + 1) {
                    bow = Double.parseDouble(slots[order + 1]);
                }
                insertNgram(typeBuffer, prob / log10e, bow / log10e);
            }
        }
        maxOrder = order;
    }
",0
13335719,7,"                public void remove() {
                    if (-1 == currentIndex) {
                        throw new IllegalStateException();
                    }
                    for (int i = currentIndex; i < size - 1; i++) {
                        elements[i] = elements[i + 1];
                    }
                    size--;
                }
",1
12584465,7,"        public E poll() {
            if (isEmpty()) {
                return null;
            }
            E e = (E) elements[0];
            for (int i = 0; i < size - 1; i++) {
                elements[i] = elements[i + 1];
            }
            size--;
            return e;
        }
",1
4735528,7,"    public void renderCsvDescriptor(String label, String csv, final JPanel destination) {
        String[] rows = csv.split(""\n"");
        String[] columnNames = rows[0].split("";"");
        String[][] tableData = new String[rows.length - 1][];
        for (int i = 0; i < rows.length - 1; ++i) {
            tableData[i] = rows[i + 1].split("";"");
        }
        JTable csvTable = new JTable();
        DefaultTableModel csvModel = new DefaultTableModel(tableData, columnNames) {

            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        csvTable.setModel(csvModel);
        final JScrollPane scrollTable = new JScrollPane(csvTable);
        scrollTable.setBorder(BorderFactory.createTitledBorder(label));
        SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                destination.add(scrollTable);
                destination.validate();
                destination.repaint();
            }
        });
    }
",1
13358170,7,"    public void put(GML gmlNew, int cursor) {
        if (intPointer < CAPACITY - 1) {
            intPointer++;
            vctGMLs.add(intPointer, gmlNew.clone());
            cursors[intPointer] = cursor;
            if ((vctGMLs.lastElement() != null) && (!vctGMLs.lastElement().equals(gmlNew))) {
                while (vctGMLs.size() > intPointer + 1) vctGMLs.removeElementAt(intPointer + 1);
                for (int i = intPointer + 1; i < cursors.length; i++) cursors[i] = -1;
            }
        } else {
            vctGMLs.remove(0);
            for (int i = 0; i < cursors.length - 1; i++) {
                cursors[i] = cursors[i + 1];
            }
            vctGMLs.add(gmlNew.clone());
            cursors[intPointer] = cursor;
        }
    }
",1
15162377,7,"    private void shiftFrame(byte b) {
        for (int i = 0; i < m_frame.length - 1; i++) {
            m_frame[i] = m_frame[i + 1];
        }
        m_frame[m_frame.length - 1] = b;
    }
",1
2748906,7,"    private void _mindex() {
        int k = pop();
        int e = stack[stackIndex - k];
        for (int i = stackIndex - k; i < stackIndex - 1; i++) {
            stack[i] = stack[i + 1];
        }
        stack[stackIndex - 1] = e;
    }
",1
22544014,7,"    public void deleteValue(long value) throws InvalidValueException {
        int index = findValue(value);
        for (int i = index; i < numElements - 1; i++) {
            array[i] = array[i + 1];
        }
        numElements--;
    }
",1
9097762,7,"    public void petitRoque(int i) {
        board[i + 1] = board[i] % 100;
        board[i] = 0;
        if (!ischeck()) {
            board[i] = board[i + 1];
            board[i + 1] = board[i + 3] % 100;
            board[i + 3] = 0;
            simulize(i, i + 2);
            board[i + 3] = board[i + 1] + 100;
            board[i + 1] = board[i];
        }
        board[i] = board[i + 1] + 100;
        board[i + 1] = 0;
    }
",0
127080,7,"    public void readCommand(OsProcess proc) {
        String input = null;
        try {
            while ((input = in.readLine()) == null) ;
        } catch (IOException e) {
            System.err.println(""readCommand failed."");
            System.exit(1);
        }
        String[] words = toArgs(input);
        if (words != null) {
            if (words.length != 0) {
                cmd = words[0];
                args = new String[words.length - 1];
                for (int i = 0; i < args.length; ++i) args[i] = words[i + 1];
            }
        }
    }
",1
9237493,7,"    byte[] getRGBA(byte[] data, int size) throws IOException {
        byte[] rgba = data;
        byte temp;
        int i;
        int numOfBytes = size * 4;
        for (i = 0; i < numOfBytes; i += 4) {
            temp = rgba[i];
            rgba[i] = rgba[i + 2];
            rgba[i + 2] = temp;
        }
        return rgba;
    }
",1
4254073,7,"    public static void toggleIntEndian(byte[] b, int off, int len) {
        if (b == null || len == 0) return;
        int end = off + len;
        if (off < 0 || len < 0 || end > b.length) throw new IndexOutOfBoundsException(""b.length = "" + b.length + "", off = "" + off + "", len = "" + len);
        if ((len & 3) != 0) throw new IllegalArgumentException(""len = "" + len);
        byte tmp;
        for (int i = off; i < end; i++, i++, i++, i++) {
            tmp = b[i];
            b[i] = b[i + 3];
            b[i + 3] = tmp;
            tmp = b[i + 1];
            b[i + 1] = b[i + 2];
            b[i + 2] = tmp;
        }
    }
",1
5917726,7,"    private long procedure_Aa(long x0, long c, BigInteger[] pq, int size) {
        while (x0 < 0 || x0 > 4294967296L) {
            x0 = init_random.nextInt() * 2;
        }
        while ((c < 0 || c > 4294967296L) || (c / 2 == 0)) {
            c = init_random.nextInt() * 2 + 1;
        }
        BigInteger C = new BigInteger(Long.toString(c));
        BigInteger constA32 = new BigInteger(""97781173"");
        BigInteger[] y = new BigInteger[1];
        y[0] = new BigInteger(Long.toString(x0));
        int[] t = new int[1];
        t[0] = size;
        int s = 0;
        for (int i = 0; t[i] >= 33; i++) {
            int tmp_t[] = new int[t.length + 1];
            System.arraycopy(t, 0, tmp_t, 0, t.length);
            t = new int[tmp_t.length];
            System.arraycopy(tmp_t, 0, t, 0, tmp_t.length);
            t[i + 1] = t[i] / 2;
            s = i + 1;
        }
        BigInteger p[] = new BigInteger[s + 1];
        p[s] = new BigInteger(""8000000B"", 16);
        int m = s - 1;
        for (int i = 0; i < s; i++) {
            int rm = t[m] / 32;
            step6: for (; ; ) {
                BigInteger tmp_y[] = new BigInteger[y.length];
                System.arraycopy(y, 0, tmp_y, 0, y.length);
                y = new BigInteger[rm + 1];
                System.arraycopy(tmp_y, 0, y, 0, tmp_y.length);
                for (int j = 0; j < rm; j++) {
                    y[j + 1] = (y[j].multiply(constA32).add(C)).mod(TWO.pow(32));
                }
                BigInteger Ym = new BigInteger(""0"");
                for (int j = 0; j < rm; j++) {
                    Ym = Ym.add(y[j].multiply(TWO.pow(32 * j)));
                }
                y[0] = y[rm];
                BigInteger N = TWO.pow(t[m] - 1).divide(p[m + 1]).add((TWO.pow(t[m] - 1).multiply(Ym)).divide(p[m + 1].multiply(TWO.pow(32 * rm))));
                if (N.mod(TWO).compareTo(ONE) == 0) {
                    N = N.add(ONE);
                }
                int k = 0;
                step11: for (; ; ) {
                    p[m] = p[m + 1].multiply(N.add(BigInteger.valueOf(k))).add(ONE);
                    if (p[m].compareTo(TWO.pow(t[m])) == 1) {
                        continue step6;
                    }
                    if ((TWO.modPow(p[m + 1].multiply(N.add(BigInteger.valueOf(k))), p[m]).compareTo(ONE) == 0) && (TWO.modPow(N.add(BigInteger.valueOf(k)), p[m]).compareTo(ONE) != 0)) {
                        m -= 1;
                        break;
                    } else {
                        k += 2;
                        continue step11;
                    }
                }
                if (m >= 0) {
                    break;
                } else {
                    pq[0] = p[0];
                    pq[1] = p[1];
                    return y[0].longValue();
                }
            }
        }
        return y[0].longValue();
    }
",1
4948726,7,"    @Override
    public void reload() {
        final TridiagonalOperator L = new TridiagonalOperator(n);
        Array tmp = new Array(n);
        final double[] dx = new double[n];
        final double[] S = new double[n];
        int i = 0;
        dx[i] = vx[i + 1] - vx[i];
        S[i] = (vy[i + 1] - vy[i]) / dx[i];
        for (i = 1; i < n - 1; i++) {
            dx[i] = vx[i + 1] - vx[i];
            S[i] = (vy[i + 1] - vy[i]) / dx[i];
            L.setMidRow(i, dx[i], 2.0 * (dx[i] + dx[i - 1]), dx[i - 1]);
            tmp.set(i, 3.0 * (dx[i] * S[i - 1] + dx[i - 1] * S[i]));
        }
        switch(leftType) {
            case NotAKnot:
                L.setFirstRow(dx[1] * (dx[1] + dx[0]), (dx[0] + dx[1]) * (dx[0] + dx[1]));
                tmp.set(0, S[0] * dx[1] * (2.0 * dx[1] + 3.0 * dx[0]) + S[1] * dx[0] * dx[0]);
                break;
            case FirstDerivative:
                L.setFirstRow(1.0, 0.0);
                tmp.set(0, leftValue);
                break;
            case SecondDerivative:
                L.setFirstRow(2.0, 1.0);
                tmp.set(0, 3.0 * S[0] - leftValue * dx[0] / 2.0);
                break;
            case Periodic:
            case Lagrange:
                throw new UnsupportedOperationException(""this end condition is not implemented yet"");
            default:
                throw new UnsupportedOperationException(""unknown end condition"");
        }
        switch(rightType) {
            case NotAKnot:
                L.setLastRow(-(dx[n - 2] + dx[n - 3]) * (dx[n - 2] + dx[n - 3]), -dx[n - 3] * (dx[n - 3] + dx[n - 2]));
                tmp.set(n - 1, -S[n - 3] * dx[n - 2] * dx[n - 2] - S[n - 2] * dx[n - 3] * (3.0 * dx[n - 2] + 2.0 * dx[n - 3]));
                break;
            case FirstDerivative:
                L.setLastRow(0.0, 1.0);
                tmp.set(n - 1, rightValue);
                break;
            case SecondDerivative:
                L.setLastRow(1.0, 2.0);
                tmp.set(n - 1, 3.0 * S[n - 2] + rightValue * dx[n - 2] / 2.0);
                break;
            case Periodic:
            case Lagrange:
                throw new UnsupportedOperationException(""this end condition is not implemented yet"");
            default:
                throw new UnsupportedOperationException(""unknown end condition"");
        }
        tmp = L.solveFor(tmp);
        if (constrained) {
            double correction;
            double pm, pu, pd, M;
            for (i = 0; i < n; i++) {
                if (i == 0) {
                    if (tmp.get(i) * S[0] > 0.0) {
                        correction = tmp.get(i) / Math.abs(tmp.get(i)) * Math.min(Math.abs(tmp.get(i)), Math.abs(3.0 * S[0]));
                    } else {
                        correction = 0.0;
                    }
                    if (!Closeness.isClose(correction, tmp.get(i))) {
                        tmp.set(i, correction);
                        monotone = true;
                    }
                } else if (i == n - 1) {
                    if (tmp.get(i) * S[n - 2] > 0.0) {
                        correction = tmp.get(i) / Math.abs(tmp.get(i)) * Math.min(Math.abs(tmp.get(i)), Math.abs(3.0 * S[n - 2]));
                    } else {
                        correction = 0.0;
                    }
                    if (!Closeness.isClose(correction, tmp.get(i))) {
                        tmp.set(i, correction);
                        monotone = true;
                    }
                } else {
                    pm = (S[i - 1] * dx[i] + S[i] * dx[i - 1]) / (dx[i - 1] + dx[i]);
                    M = 3.0 * Math.min(Math.min(Math.abs(S[i - 1]), Math.abs(S[i])), Math.abs(pm));
                    if (i > 1) {
                        if ((S[i - 1] - S[i - 2]) * (S[i] - S[i - 1]) > 0.0) {
                            pd = (S[i - 1] * (2.0 * dx[i - 1] + dx[i - 2]) - S[i - 2] * dx[i - 1]) / (dx[i - 2] + dx[i - 1]);
                            if (pm * pd > 0.0 && pm * (S[i - 1] - S[i - 2]) > 0.0) {
                                M = Math.max(M, 1.5 * Math.min(Math.abs(pm), Math.abs(pd)));
                            }
                        }
                    }
                    if (i < n - 2) {
                        if ((S[i] - S[i - 1]) * (S[i + 1] - S[i]) > 0.0) {
                            pu = (S[i] * (2.0 * dx[i] + dx[i + 1]) - S[i + 1] * dx[i]) / (dx[i] + dx[i + 1]);
                            if (pm * pu > 0.0 && -pm * (S[i] - S[i - 1]) > 0.0) {
                                M = Math.max(M, 1.5 * Math.min(Math.abs(pm), Math.abs(pu)));
                            }
                        }
                    }
                    if (tmp.get(i) * pm > 0.0) {
                        correction = tmp.get(i) / Math.abs(tmp.get(i)) * Math.min(Math.abs(tmp.get(i)), M);
                    } else {
                        correction = 0.0;
                    }
                    if (!Closeness.isClose(correction, tmp.get(i))) {
                        tmp.set(i, correction);
                        monotone = true;
                    }
                }
            }
        }
        for (i = 0; i < n - 1; i++) {
            va[i] = tmp.get(i);
            vb[i] = (3.0 * S[i] - tmp.get(i + 1) - 2.0 * tmp.get(i)) / dx[i];
            vc[i] = (tmp.get(i + 1) + tmp.get(i) - 2.0 * S[i]) / (dx[i] * dx[i]);
        }
        vp[0] = 0.0;
        for (i = 1; i < n - 1; i++) {
            vp[i] = vp[i - 1] + dx[i - 1] * (vy[i - 1] + dx[i - 1] * (va[i - 1] / 2.0 + dx[i - 1] * (vb[i - 1] / 3.0 + dx[i - 1] * vc[i - 1] / 4.0)));
        }
    }
",1
13491945,7,"    public void deleteSympthom(int sympthomIndex) {
        for (int i = sympthomIndex; i < names.length - 1; i++) {
            names[i] = names[i + 1];
        }
        names[names.length - 1] = """";
        values.remove(sympthomIndex);
        values.add(new Vector<String>());
        fireModifiedListeners();
    }
",1
8986732,7,"    public Metadata readMetadata(InputStream inStream) throws MetadataFileException {
        Metadata meta = null;
        CsvReader reader = null;
        try {
            reader = new CsvReader(inStream);
            columnHeaders = readColumnHeaders(reader);
            meta = new Metadata(columnHeaders);
            while (true) {
                String[] items = reader.getNextValidLine();
                if (items == null) {
                    break;
                }
                if (items.length > columnHeaders.length + 1) {
                    throw new MetadataFileException(""Number of metadata items exceeds number of columns declared"", reader.getLineNumber());
                }
                if (items.length < 1) {
                    throw new MetadataFileException(""No columns could be retrieved, id missing"", reader.getLineNumber());
                }
                if (items.length < columnHeaders.length + 1) {
                    String[] newItems = new String[columnHeaders.length + 1];
                    for (int i = 0; i < items.length; i++) {
                        newItems[i] = items[i];
                    }
                    for (int i = items.length; i < newItems.length; i++) {
                        newItems[i] = """";
                    }
                    items = newItems;
                }
                String id = items[0].trim();
                String[] values = new String[columnHeaders.length];
                for (int i = 0; i < columnHeaders.length; i++) {
                    values[i] = items[i + 1].trim();
                }
                meta.addSequenceMetadata(id, values);
            }
        } catch (MetadataFileException e) {
            throw e;
        } catch (Exception e) {
            int lineNum = (reader == null) ? -1 : reader.getLineNumber();
            throw new MetadataFileException(""Error reading metadata file"", e, lineNum);
        } finally {
            try {
                reader.close();
            } catch (Exception e) {
                int lineNum = (reader == null) ? -1 : reader.getLineNumber();
                throw new MetadataFileException(""Error closing metadata file"", e, lineNum);
            }
        }
        return meta;
    }
",1
3517394,7,"        @Override
        public void update() {
            final double[] dx = new double[n - 1];
            final double[] S = new double[n - 1];
            double[] tmp = new double[n];
            for (int i = 0; i < n - 1; ++i) {
                dx[i] = vx_[i + 1] - vx_[i];
                S[i] = (vy_[i + 1] - vy_[i]) / dx[i];
            }
            if (da == CubicInterpolation.DerivativeApprox.Spline) {
                final TridiagonalOperator L = new TridiagonalOperator(n);
                for (int i = 1; i < n - 1; ++i) {
                    L.setMidRow(i, dx[i], 2.0 * (dx[i] + dx[i - 1]), dx[i - 1]);
                    tmp[i] = 3.0 * (dx[i] * S[i - 1] + dx[i - 1] * S[i]);
                }
                switch(leftType) {
                    case NotAKnot:
                        L.setFirstRow(dx[1] * (dx[1] + dx[0]), (dx[0] + dx[1]) * (dx[0] + dx[1]));
                        tmp[0] = S[0] * dx[1] * (2.0 * dx[1] + 3.0 * dx[0]) + S[1] * dx[0] * dx[0];
                        break;
                    case FirstDerivative:
                        L.setFirstRow(1.0, 0.0);
                        tmp[0] = leftValue;
                        break;
                    case SecondDerivative:
                        L.setFirstRow(2.0, 1.0);
                        tmp[0] = 3.0 * S[0] - leftValue * dx[0] / 2.0;
                        break;
                    case Periodic:
                    case Lagrange:
                        throw new LibraryException(""this end condition is not implemented yet"");
                    default:
                        throw new LibraryException(""unknown end condition"");
                }
                switch(rightType) {
                    case NotAKnot:
                        L.setLastRow(-(dx[n - 2] + dx[n - 3]) * (dx[n - 2] + dx[n - 3]), -dx[n - 3] * (dx[n - 3] + dx[n - 2]));
                        tmp[n - 1] = -S[n - 3] * dx[n - 2] * dx[n - 2] - S[n - 2] * dx[n - 3] * (3.0 * dx[n - 2] + 2.0 * dx[n - 3]);
                        break;
                    case FirstDerivative:
                        L.setLastRow(0.0, 1.0);
                        tmp[n - 1] = rightValue;
                        break;
                    case SecondDerivative:
                        L.setLastRow(1.0, 2.0);
                        tmp[n - 1] = 3.0 * S[n - 2] + rightValue * dx[n - 2] / 2.0;
                        break;
                    case Periodic:
                    case Lagrange:
                        throw new LibraryException(""this end condition is not implemented yet"");
                    default:
                        throw new LibraryException(""unknown end condition"");
                }
                tmp = L.solveFor(tmp);
            } else {
                if (n == 2) {
                    tmp[0] = tmp[1] = S[0];
                } else {
                    switch(da) {
                        case FourthOrder:
                            throw new LibraryException(""FourthOrder not implemented yet"");
                        case Parabolic:
                            throw new LibraryException(""Parabolic not implemented yet"");
                        case ModifiedParabolic:
                            throw new LibraryException(""ModifiedParabolic not implemented yet"");
                        case FritschButland:
                            throw new LibraryException(""FritschButland not implemented yet"");
                        case Akima:
                            throw new LibraryException(""Akima not implemented yet"");
                        case Kruger:
                            for (int i = 1; i < n - 1; ++i) {
                                if (S[i - 1] * S[i] < 0.0) {
                                    tmp[i] = 0.0;
                                } else {
                                    tmp[i] = 2.0 / (1.0 / S[i - 1] + 1.0 / S[i]);
                                }
                            }
                            tmp[0] = (3.0 * S[0] - tmp[1]) / 2.0;
                            tmp[n - 1] = (3.0 * S[n - 2] - tmp[n - 2]) / 2.0;
                            break;
                        default:
                            throw new LibraryException(""unknown scheme"");
                    }
                }
            }
            Arrays.fill(ma_, false);
            if (monotonic) {
                double correction;
                double pm, pu, pd, M;
                for (int i = 0; i < n; ++i) {
                    if (i == 0) {
                        if (tmp[i] * S[0] > 0.0) {
                            correction = tmp[i] / Math.abs(tmp[i]) * Math.min(Math.abs(tmp[i]), Math.abs(3.0 * S[0]));
                        } else {
                            correction = 0.0;
                        }
                        if (!Closeness.isClose(correction, tmp[i])) {
                            tmp[i] = correction;
                            ma_[i] = true;
                        }
                    } else if (i == n - 1) {
                        if (tmp[i] * S[n - 2] > 0.0) {
                            correction = tmp[i] / Math.abs(tmp[i]) * Math.min(Math.abs(tmp[i]), Math.abs(3.0 * S[n - 2]));
                        } else {
                            correction = 0.0;
                        }
                        if (!Closeness.isClose(correction, tmp[i])) {
                            tmp[i] = correction;
                            ma_[i] = true;
                        }
                    } else {
                        pm = (S[i - 1] * dx[i] + S[i] * dx[i - 1]) / (dx[i - 1] + dx[i]);
                        M = 3.0 * Math.min(Math.min(Math.abs(S[i - 1]), Math.abs(S[i])), Math.abs(pm));
                        if (i > 1) {
                            if ((S[i - 1] - S[i - 2]) * (S[i] - S[i - 1]) > 0.0) {
                                pd = (S[i - 1] * (2.0 * dx[i - 1] + dx[i - 2]) - S[i - 2] * dx[i - 1]) / (dx[i - 2] + dx[i - 1]);
                                if (pm * pd > 0.0 && pm * (S[i - 1] - S[i - 2]) > 0.0) {
                                    M = Math.max(M, 1.5 * Math.min(Math.abs(pm), Math.abs(pd)));
                                }
                            }
                        }
                        if (i < n - 2) {
                            if ((S[i] - S[i - 1]) * (S[i + 1] - S[i]) > 0.0) {
                                pu = (S[i] * (2.0 * dx[i] + dx[i + 1]) - S[i + 1] * dx[i]) / (dx[i] + dx[i + 1]);
                                if (pm * pu > 0.0 && -pm * (S[i] - S[i - 1]) > 0.0) {
                                    M = Math.max(M, 1.5 * Math.min(Math.abs(pm), Math.abs(pu)));
                                }
                            }
                        }
                        if (tmp[i] * pm > 0.0) {
                            correction = tmp[i] / Math.abs(tmp[i]) * Math.min(Math.abs(tmp[i]), M);
                        } else {
                            correction = 0.0;
                        }
                        if (!Closeness.isClose(correction, tmp[i])) {
                            tmp[i] = correction;
                            ma_[i] = true;
                        }
                    }
                }
            }
            for (int i = 0; i < n - 1; ++i) {
                va_[i] = tmp[i];
                vb_[i] = (3.0 * S[i] - tmp[i + 1] - 2.0 * tmp[i]) / dx[i];
                vc_[i] = (tmp[i + 1] + tmp[i] - 2.0 * S[i]) / (dx[i] * dx[i]);
            }
            vp_[0] = 0.0;
            for (int i = 1; i < n - 1; ++i) {
                vp_[i] = vp_[i - 1] + dx[i - 1] * (vy_[i - 1] + dx[i - 1] * (va_[i - 1] / 2.0 + dx[i - 1] * (vb_[i - 1] / 3.0 + dx[i - 1] * vc_[i - 1] / 4.0)));
            }
        }
",0
4911258,7,"    public void up(IStructuredSelection selection) {
        Set libraries = getSelectedLibraries(selection);
        for (int i = 0; i < fLibraries.length - 1; i++) {
            if (libraries.contains(fLibraries[i + 1])) {
                LibraryStandin temp = fLibraries[i];
                fLibraries[i] = fLibraries[i + 1];
                fLibraries[i + 1] = temp;
            }
        }
        fViewer.refresh();
        fViewer.setSelection(selection);
    }
",1
2874111,7,"    public static Object newMsg(Object[] _p) {
        FooLib.checkClassArgument(Class.class, _p[0], 0);
        Class c = (Class) _p[0];
        if (c.isArray()) {
            int l = _p.length - 1;
            int[] d = new int[l];
            for (int i = 0; i < l; i++) {
                c = c.getComponentType();
                d[i] = FooLib.toInteger(_p[i + 1]).intValue();
            }
            return Array.newInstance(c, d);
        }
        Constructor m = FooLib.getConstructor(c, c.getName(), _p.length - 1);
        if (m == null) {
            StringBuffer s = new StringBuffer(c.getName() + ""("");
            for (int j = 0; j < _p.length; j++) {
                if (j > 0) s.append(',');
                s.append(FooLib.getClassName(_p[j]));
            }
            s.append(')');
            throw new RuntimeException(""constructor not found:"" + s);
        }
        Object[] q = new Object[_p.length - 1];
        for (int i = 0; i < q.length; i++) q[i] = _p[i + 1];
        return FooLib.invokeConstructor(m, q);
    }
",1
252999,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
3126012,7,"    public void leave() {
        for (int i = 1; i < Config.NUMAKKUS - 1; ++i) accu[i] = accu[i + 1];
    }
",0
13734686,7,"        public MyPolygon(double[] xpoints, double[] ypoints, int n) {
            x = xpoints;
            y = ypoints;
            npoints = n;
            x_normal = new double[x.length];
            y_normal = new double[y.length];
            for (int i = 0; i < n - 1; i++) {
                x_normal[i] = x[i + 1] - x[i];
                y_normal[i] = y[i + 1] - y[i];
            }
            x_normal[n - 1] = x[0] - x[n - 1];
            y_normal[n - 1] = y[0] - y[n - 1];
        }
",1
21122722,7,"    public static BigInteger[] encrypt(FHEParams fheparams, GHKeyPair key, int[] b) {
        int i, num = b.length;
        long n = 1 << (fheparams.logn);
        double p = ((double) fheparams.noise) / n;
        if (p > 0.5) p = 0.5;
        BigInteger[] vals = evalRandPoly(num, n, p, key.root, key.det);
        BigInteger[] out = new BigInteger[num];
        for (i = 0; i < num; i++) {
            out[i] = vals[i + 1];
        }
        for (i = 0; i < num; i++) {
            out[i] = out[i].shiftLeft(1);
            out[i] = out[i].add(new BigInteger(Integer.toString(b[i])));
            if (out[i].compareTo(key.det) >= 0) out[i] = out[i].subtract(key.det);
        }
        return out;
    }
",1
588851,7,"        private float[] makeKernel(double radius) {
            radius += 1;
            int size = (int) radius * 2 + 1;
            float[] kernel = new float[size];
            double v;
            for (int i = 0; i < size; i++) kernel[i] = (float) Math.exp(-0.5 * (sqr((i - radius) / (radius * 2))) / sqr(0.2));
            float[] kernel2 = new float[size - 2];
            for (int i = 0; i < size - 2; i++) kernel2[i] = kernel[i + 1];
            if (kernel2.length == 1) kernel2[0] = 1f;
            return kernel2;
        }
",1
621702,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
5929314,7,"    void delete(int i) {
        s.assertt(optioni > 0);
        optioni--;
        for (int j = i; j < optioni; j++) option[j] = option[j + 1];
    }
",0
5236991,7,"        private ArrayList<Face> emitPolygon(Obj parent, Vertex[] v) {
            ArrayList<Face> triangles = new ArrayList<Face>();
            int n = v.length;
            int prev, cur, next;
            int[] vp;
            int count;
            int min_vert;
            int i;
            double dist;
            double min_dist;
            boolean poly_orientation;
            boolean beenHere = false;
            vp = new int[n];
            poly_orientation = this.orientation(v);
            for (i = 0; i < n; i++) vp[i] = i;
            count = n;
            while (count > 3) {
                min_dist = Double.MAX_VALUE;
                min_vert = 0;
                for (cur = 0; cur < count; cur++) {
                    prev = cur - 1;
                    next = cur + 1;
                    if (cur == 0) prev = count - 1; else if (next == count) next = 0;
                    if ((determinant(vp[prev], vp[cur], vp[next], v) == poly_orientation) && no_interior(vp[prev], vp[cur], vp[next], v, vp, count, poly_orientation) && ((dist = distance2(v[vp[prev]].getX(), v[vp[prev]].getY(), v[vp[next]].getX(), v[vp[next]].getY())) < min_dist)) {
                        min_dist = dist;
                        min_vert = cur;
                    }
                }
                if (min_dist == Double.MAX_VALUE) {
                    if (beenHere) return null;
                    poly_orientation = !poly_orientation;
                    beenHere = true;
                } else {
                    beenHere = false;
                    prev = min_vert - 1;
                    next = min_vert + 1;
                    if (min_vert == 0) prev = count - 1; else if (next == count) next = 0;
                    triangles.add(new Face(parent, v[vp[prev]], v[vp[min_vert]], v[vp[next]]));
                    count--;
                    for (i = min_vert; i < count; i++) vp[i] = vp[i + 1];
                }
            }
            triangles.add(new Face(parent, v[vp[0]], v[vp[1]], v[vp[2]]));
            return triangles;
        }
",0
5533628,7,"    public Object next(int index) {
        if (index >= N - 2) next(); else {
            int m = Al[index];
            sort(index + 1, N - 1);
            if (m > Al[N - 1]) {
                if (index > 0) return next(index - 1);
                first();
            } else {
                int o;
                for (o = N - 2; Al[o] > m; o--) ;
                Al[index] = Al[o + 1];
                Al[o + 1] = m;
            }
        }
        return this;
    }
",1
7762106,7,"    @Override
    public void unpack(ByteBuffer b) throws IOException {
        b.position(0);
        b.order(ByteOrder.LITTLE_ENDIAN);
        this.width = b.getShort();
        this.height = b.getShort();
        this.leftoffset = b.getShort();
        this.topoffset = b.getShort();
        this.columnofs = new int[this.width];
        this.columns = new column_t[this.width];
        C2JUtils.initArrayOfObjects(this.columns, column_t.class);
        int[] actualsizes = new int[columns.length];
        for (int i = 0; i < actualsizes.length - 1; i++) {
            actualsizes[i] = columnofs[i + 1] - columnofs[i];
        }
        DoomBuffer.readIntArray(b, this.columnofs, this.columnofs.length);
        for (int i = 0; i < this.width; i++) {
            b.position(this.columnofs[i]);
            try {
                this.columns[i].unpack(b);
            } catch (Exception e) {
                if (i == 0) this.columns[i] = getBadColumn(this.height); else this.columns[i] = this.columns[i - 1];
            }
        }
    }
",0
18550006,7,"    @Override
    public void model() {
        System.out.println(""Creating model for solution with "" + numberInnerMoves + "" intermediate steps"");
        store = new Store();
        vars = new ArrayList<Var>();
        IntVar left = new IntVar(store, ""left"", 0, 0);
        IntVar right = new IntVar(store, ""right"", 2, 2);
        IntVar[] wolf = new IntVar[2 + numberInnerMoves];
        IntVar[] goat = new IntVar[2 + numberInnerMoves];
        IntVar[] cabbage = new IntVar[2 + numberInnerMoves];
        wolf[0] = goat[0] = cabbage[0] = left;
        wolf[numberInnerMoves + 1] = goat[numberInnerMoves + 1] = cabbage[numberInnerMoves + 1] = right;
        for (int i = 1; i < numberInnerMoves + 1; i++) {
            wolf[i] = new IntVar(store, ""wolfStateInMove"" + i, 0, 2);
            goat[i] = new IntVar(store, ""goatStateInMove"" + i, 0, 2);
            cabbage[i] = new IntVar(store, ""cabbageStateInMove"" + i, 0, 2);
            vars.add(wolf[i]);
            vars.add(goat[i]);
            vars.add(cabbage[i]);
        }
        int[][] allowedTransitions = { { 0, 1, 0 }, { 1, 0, 0 }, { 2, 1, 2 }, { 1, 2, 2 }, { 0, 0, 0 }, { 0, 0, 2 }, { 2, 2, 0 }, { 2, 2, 2 } };
        for (int i = 0; i < numberInnerMoves + 1; i++) {
            IntVar[] temp = { wolf[i], wolf[i + 1], null };
            if (i % 2 == 0) temp[2] = left; else temp[2] = right;
            store.impose(new ExtensionalSupportVA(temp, allowedTransitions));
            temp[0] = goat[i];
            temp[1] = goat[i + 1];
            store.impose(new ExtensionalSupportVA(temp, allowedTransitions));
            temp[0] = cabbage[i];
            temp[1] = cabbage[i + 1];
            store.impose(new ExtensionalSupportVA(temp, allowedTransitions));
        }
        IntVar[] bw = new IntVar[numberInnerMoves];
        IntVar[] bg = new IntVar[numberInnerMoves];
        IntVar[] bc = new IntVar[numberInnerMoves];
        for (int i = 1; i < numberInnerMoves + 1; i++) {
            bw[i - 1] = new IntVar(store, ""wolfOnBoatInMove"" + i, 0, 1);
            bg[i - 1] = new IntVar(store, ""goatOnBoatInMove"" + i, 0, 1);
            bc[i - 1] = new IntVar(store, ""cabbageOnBoatInMove"" + i, 0, 1);
            store.impose(new Reified(new XeqC(wolf[i], 1), bw[i - 1]));
            store.impose(new Reified(new XeqC(goat[i], 1), bg[i - 1]));
            store.impose(new Reified(new XeqC(cabbage[i], 1), bc[i - 1]));
            IntVar[] b = { bw[i - 1], bg[i - 1], bc[i - 1] };
            IntVar numberOnBoat = new IntVar(store, ""numberOnBoatInMove"" + i, 0, 1);
            store.impose(new Sum(b, numberOnBoat));
            store.impose(new XneqY(wolf[i], goat[i]));
            store.impose(new XneqY(goat[i], cabbage[i]));
        }
    }
",0
10514803,7,"    public void push(Object number) {
        for (int i = 0; i < size - 1; i++) {
            queue[i] = queue[i + 1];
        }
        queue[size - 1] = number;
    }
",0
6352528,7,"    private String[] xLiner(int number) {
        if (number <= 2) {
            number = 2;
        } else {
            number = 3;
        }
        String[] result = new String[number];
        String[] lastSegs = new String[number - 1];
        String lastWord = """";
        String tempWord = """";
        int[] tempSyls = new int[number];
        int tempSyl = 0;
        boolean match;
        bcWordList lst = null;
        bcWord current = null;
        for (int l = 0; l <= number - 2; l++) {
            do {
                match = true;
                if (l == 0) {
                    currentSyllables = 0;
                    result[0] = fill(parseGrammar(GRAMMAR_START));
                    lastWord = getLastWord(result[0]);
                    tempSyls[0] = currentSyllables;
                    currentSyllables = 0;
                } else {
                    lastWord = getLastWord(result[1]);
                }
                result[l + 1] = parseGrammar(GRAMMAR_START);
                if (result[l + 1].indexOf(""@"") == -1) {
                    lastSegs[l] = result[l + 1];
                    result[l + 1] = """";
                    tempSyls[l + 1] = currentSyllables = 0;
                } else {
                    for (int j = result[l + 1].length() - 1; j >= 0; j--) {
                        if (result[l + 1].charAt(j) == '@') {
                            lastSegs[l] = result[l + 1].substring(j + 1);
                            result[l + 1] = fill(result[l + 1].substring(0, j));
                            tempSyls[l + 1] = currentSyllables;
                            currentSyllables = 0;
                            break;
                        }
                    }
                }
                if (lastSegs[l].startsWith(""'"") && lastSegs[l].endsWith(""'"")) {
                    tempWord = lastSegs[l].substring(1, lastSegs[l].length() - 1);
                    tempSyl = getWordFromLists(tempWord).getSyllables();
                    if ((rhyming(tempWord, lastWord) < 1) || !(tempSyl + tempSyls[l + 1] <= tempSyls[0] + module.getSyllableTolerance()) || !(tempSyl + tempSyls[l + 1] >= tempSyls[0] - module.getSyllableTolerance())) {
                        match = false;
                    } else {
                        result[l + 1] += "" "" + tempWord;
                        tempSyls[l + 1] += tempSyl;
                    }
                } else {
                    lst = module.getWordList(lastSegs[l]);
                    List possibleMatches = new LinkedList();
                    for (int j = 0; j < lst.getNumberOfWords(); j++) {
                        current = lst.getItem(j);
                        tempWord = current.getWord();
                        if ((rhyming(tempWord, lastWord) == 1) && (current.getSyllables() + tempSyls[l + 1] <= tempSyls[0] + module.getSyllableTolerance()) && (current.getSyllables() + tempSyls[l + 1] >= tempSyls[0] - module.getSyllableTolerance())) {
                            possibleMatches.add(current);
                        }
                    }
                    if (possibleMatches.size() == 0) {
                        match = false;
                    } else {
                        current = (bcWord) possibleMatches.get(r.nextInt(possibleMatches.size()));
                        tempWord = current.getWord();
                        result[l + 1] += "" "" + tempWord;
                        tempSyls[l + 1] += current.getSyllables();
                    }
                }
                if ((module.getSyllableTolerance() == 0) && (!result[l + 1].equals("""")) && (!metricMatch(result[0], result[l + 1]))) {
                    match = false;
                }
            } while (!match);
        }
        return result;
    }
",1
12803195,7,"    public FuzzyNumber calc(FuzzyNumber af, FuzzyNumber bf) {
        double b[] = bf.data(), a[] = af.data();
        double c[] = new double[b.length];
        double atmp[] = new double[2], btmp[] = new double[2];
        for (int i = 0; i < b.length; i += 3) {
            atmp[0] = a[i];
            atmp[1] = a[i + 1];
            btmp[0] = b[i];
            btmp[1] = b[i + 1];
            double res[] = minus(atmp, btmp);
            c[i] = res[0];
            c[i + 1] = res[1];
            c[i + 2] = a[i + 2];
        }
        return new DiscreteNumber(c);
    }
",0
5693688,7,"    protected void drawPrimaryLineAsPath(XYItemRendererState state, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea) {
        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
        double x1 = dataset.getXValue(series, item);
        double y1 = dataset.getYValue(series, item);
        double transX1 = domainAxis.valueToJava2D(x1, dataArea, xAxisLocation);
        double transY1 = rangeAxis.valueToJava2D(y1, dataArea, yAxisLocation);
        if (!Double.isNaN(transX1) && !Double.isNaN(transY1)) {
            ControlPoint p = new ControlPoint(plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transY1 : (float) transX1, plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transX1 : (float) transY1);
            if (!this.points.contains(p)) {
                this.points.add(p);
            }
        }
        if (item == dataset.getItemCount(series) - 1) {
            State s = (State) state;
            if (this.points.size() > 1) {
                ControlPoint cp0 = (ControlPoint) this.points.get(0);
                s.seriesPath.moveTo(cp0.x, cp0.y);
                if (this.points.size() == 2) {
                    ControlPoint cp1 = (ControlPoint) this.points.get(1);
                    s.seriesPath.lineTo(cp1.x, cp1.y);
                } else {
                    int np = this.points.size();
                    float[] d = new float[np];
                    float[] x = new float[np];
                    float y;
                    float t;
                    float oldy = 0;
                    float oldt = 0;
                    float[] a = new float[np];
                    float t1;
                    float t2;
                    float[] h = new float[np];
                    for (int i = 0; i < np; i++) {
                        ControlPoint cpi = (ControlPoint) this.points.get(i);
                        x[i] = cpi.x;
                        d[i] = cpi.y;
                    }
                    for (int i = 1; i <= np - 1; i++) {
                        h[i] = x[i] - x[i - 1];
                    }
                    float[] sub = new float[np - 1];
                    float[] diag = new float[np - 1];
                    float[] sup = new float[np - 1];
                    for (int i = 1; i <= np - 2; i++) {
                        diag[i] = (h[i] + h[i + 1]) / 3;
                        sup[i] = h[i + 1] / 6;
                        sub[i] = h[i] / 6;
                        a[i] = (d[i + 1] - d[i]) / h[i + 1] - (d[i] - d[i - 1]) / h[i];
                    }
                    solveTridiag(sub, diag, sup, a, np - 2);
                    oldt = x[0];
                    oldy = d[0];
                    s.seriesPath.moveTo(oldt, oldy);
                    for (int i = 1; i <= np - 1; i++) {
                        for (int j = 1; j <= this.precision; j++) {
                            t1 = (h[i] * j) / this.precision;
                            t2 = h[i] - t1;
                            y = ((-a[i - 1] / 6 * (t2 + h[i]) * t1 + d[i - 1]) * t2 + (-a[i] / 6 * (t1 + h[i]) * t2 + d[i]) * t1) / h[i];
                            t = x[i - 1] + t1;
                            s.seriesPath.lineTo(t, y);
                            oldt = t;
                            oldy = y;
                        }
                    }
                }
                drawFirstPassShape(g2, pass, series, item, s.seriesPath);
            }
            this.points = new Vector();
        }
    }
",0
250503,7,"    public static void main(String[] args) throws IOException {
        final int operadores_totales = 10;
        final int numeros_totales = 10;
        int i, j, k;
        int n_op = 0;
        int n_num = 0;
        float numero[] = new float[numeros_totales];
        char op[] = new char[operadores_totales];
        char entradaC[];
        String[] numeroS = new String[numeros_totales];
        String entrada;
        InputStreamReader teclado;
        BufferedReader bufferLectura;
        teclado = new InputStreamReader(System.in);
        bufferLectura = new BufferedReader(teclado);
        System.out.println(""\tOPERACIONES POSIBLES (Entre paréntesis su PREFERENCIA)\n- Suma:\t\t\t \""+\""(3)\n- Resta:\t\t \""-\""(3)\n- Multiplicación:\t \""*\""(2)\n- División:\t\t \""/\""(2)\n- Potencia:\t\t \""**\""(1) (después debe ponerse el exponente)\n\tEj. 3³ + 5 = 3**3+5"");
        System.out.print(""Introduce la operación: "");
        entrada = bufferLectura.readLine();
        entradaC = new char[entrada.length()];
        for (i = 0; i < entrada.length(); i++) entradaC[i] = entrada.charAt(i);
        for (i = 0; i < entrada.length(); i++) {
            if (entradaC[i] == '/' || entradaC[i] == '-' || entradaC[i] == '+') {
                op[n_op] = entradaC[i];
                n_op++;
            } else if (entradaC[i] == '*') {
                if (entradaC[i + 1] == '*') {
                    op[n_op] = '^';
                    n_op++;
                    i++;
                } else {
                    op[n_op] = '*';
                    n_op++;
                }
            }
        }
        for (i = 0; i <= 9; i++) numeroS[i] = """";
        for (i = 0; i < entrada.length(); i++) {
            if (entradaC[i] == '/' || entradaC[i] == '-' || entradaC[i] == '+') {
                n_num++;
            } else if (entradaC[i] == '*') {
                if (entradaC[i + 1] == '*' || entradaC[i] == '/' || entradaC[i] == '-' || entradaC[i] == '+') {
                    i++;
                    n_num++;
                } else n_num++;
            } else numeroS[n_num] += String.valueOf(entradaC[i]);
        }
        for (i = 0; i <= n_num; i++) {
            if (numeroS[i] != """") numero[i] = Float.parseFloat(numeroS[i]);
        }
        System.out.print(""Operación Evaluada: "");
        for (i = 0, j = 0; i <= n_num; i++, j++) {
            System.out.print(numero[i]);
            System.out.print(op[j]);
        }
        System.out.println();
        for (i = 0, j = 0; i <= n_op; ) {
            if (op[i] == '^') {
                numero[i] = potencia(numero[i], numero[i + 1]);
                op[i] = '0';
                numero[i + 1] = 0;
            } else i++;
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (numero[j] == 0) {
                    numero[j] = numero[j + 1];
                    numero[j + 1] = 0;
                }
            }
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (op[j] == '0') {
                    op[j] = op[j + 1];
                    op[j + 1] = '0';
                }
            }
        }
        System.out.print(""Operación tras realizar las POTENCIAS: "");
        for (i = 0, j = 0; i <= n_num; i++, j++) {
            System.out.print(numero[i]);
            System.out.print(op[j]);
        }
        System.out.println();
        for (i = 0; i <= n_op; ) {
            if (op[i] == '*') {
                numero[i] = numero[i] * numero[i + 1];
                op[i] = '0';
                numero[i + 1] = 0;
            } else if (op[i] == '/') {
                numero[i] = numero[i] / numero[i + 1];
                op[i] = '0';
                numero[i + 1] = 0;
            } else i++;
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (numero[j] == 0) {
                    numero[j] = numero[j + 1];
                    numero[j + 1] = 0;
                }
            }
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (op[j] == '0') {
                    op[j] = op[j + 1];
                    op[j + 1] = '0';
                }
            }
        }
        System.out.print(""Operación tras realizar MULTIPLICACIONES Y DIVISIONES: "");
        for (i = 0, j = 0; i <= n_num; i++, j++) {
            System.out.print(numero[i]);
            System.out.print(op[j]);
        }
        System.out.println();
        for (i = 0; i <= n_op; i++) {
            if (op[0] == '+') {
                numero[0] = numero[0] + numero[1];
                op[0] = '0';
                numero[i + 1] = 0;
            }
            if (op[0] == '-') {
                numero[0] = numero[0] - numero[1];
                op[0] = '0';
                numero[1] = 0;
            }
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (numero[j] == 0) {
                    numero[j] = numero[j + 1];
                    numero[j + 1] = 0;
                }
            }
            for (k = 0; k <= n_num; k++) for (j = 0; j <= n_num; j++) {
                if (op[j] == '0') {
                    op[j] = op[j + 1];
                    op[j + 1] = '0';
                }
            }
        }
        System.out.println(""RESULTADO: "" + numero[0]);
    }
",0
5218564,7,"    public void RemoveKey(int key) {
        if (buffer_size <= 0) return;
        boolean key_found = false;
        int i = 0;
        for (; i < buffer_size; i++) {
            if (buffer[i] == key) {
                key_found = true;
                break;
            }
        }
        if (!key_found) return;
        for (int j = i; j < (buffer_size - 1); j++) {
            buffer[j] = buffer[j + 1];
        }
        buffer_size--;
    }
",1
5856494,7,"    public InternalNodeArrayMap split() {
        InternalNodeArrayMap newMap = new InternalNodeArrayMap(keys.length);
        final int mid = currentSize / 2;
        int count = 0;
        newMap.nodes[0] = nodes[mid + 1];
        for (int i = mid + 1; i < currentSize; i++) {
            newMap.keys[count] = keys[i];
            newMap.nodes[++count] = nodes[i + 1];
        }
        for (int i = mid; i < currentSize; i++) {
            nodes[i + 1] = null;
        }
        newMap.currentSize = currentSize - mid - 1;
        currentSize = mid;
        return newMap;
    }
",1
12600805,7,"    public void vecProd(double[] ds, int i, double[] ds_11_, int i_12_, double[] ds_13_, int i_14_) {
        ds_13_[i_14_] = ds[i + 1] * ds_11_[i_12_ + 2] - ds[i + 2] * ds_11_[i_12_ + 1];
        ds_13_[i_14_ + 1] = ds[i + 2] * ds_11_[i_12_] - ds[i] * ds_11_[i_12_ + 2];
        ds_13_[i_14_ + 2] = ds[i] * ds_11_[i_12_ + 1] - ds[i + 1] * ds_11_[i_12_];
    }
",1
2835972,7,"        public synchronized void paintComponent(Graphics g) {
            big = (Graphics2D) g;
            FontMetrics fm = big.getFontMetrics(font);
            ascent = (int) fm.getAscent();
            descent = (int) fm.getDescent();
            big.setBackground(getBackground());
            big.clearRect(0, 0, w, h);
            float totalMemory = (float) r.totalMemory();
            float freeMemory = (float) r.freeMemory();
            float usedMemory = (float) totalMemory - freeMemory;
            if (totalMemoryPrev != totalMemory) updatePts = true;
            big.setColor(Color.green);
            big.drawString(String.valueOf((int) totalMemory / 1024) + ""K allocated"", 4.0f, (float) ascent + 0.5f);
            usedStr = String.valueOf(((int) (usedMemory)) / 1024) + ""K used"";
            big.drawString(usedStr, 4, h - descent);
            float ssH = ascent + descent;
            float remainingHeight = (float) (h - (ssH * 2) - 0.5f);
            float blockHeight = remainingHeight / 10;
            float blockWidth = 20.0f;
            float remainingWidth = (float) (w - blockWidth - 10);
            big.setColor(mfColor);
            int MemUsage = (int) ((freeMemory / totalMemory) * 10);
            int i = 0;
            for (; i < MemUsage; i++) {
                mfRect.setRect(5, (float) ssH + i * blockHeight, blockWidth, (float) blockHeight - 1);
                big.fill(mfRect);
            }
            big.setColor(Color.green);
            for (; i < 10; i++) {
                muRect.setRect(5, (float) ssH + i * blockHeight, blockWidth, (float) blockHeight - 1);
                big.fill(muRect);
            }
            big.setColor(graphColor);
            int graphX = 30;
            int graphY = (int) ssH;
            int graphW = w - graphX - 5;
            int graphH = (int) remainingHeight;
            if (graphW <= 0 || graphH <= 0) {
                System.out.println(""size = "" + getSize());
                System.out.println(""w = "" + w + "", h = "" + h);
                System.out.println(""graphW = "" + graphW + "", graphH = "" + graphH);
                return;
            }
            graphOutlineRect.setRect(graphX, graphY, graphW, graphH);
            big.draw(graphOutlineRect);
            int graphRow = graphH / 10;
            for (int j = graphY; j <= graphH + graphY; j += graphRow) {
                graphLine.setLine(graphX, j, graphX + graphW, j);
                big.draw(graphLine);
            }
            int graphColumn = graphW / 15;
            if (animating()) {
                if (columnInc == 0) {
                    columnInc = graphColumn;
                }
                --columnInc;
            }
            for (int j = graphX + columnInc; j < graphW + graphX; j += graphColumn) {
                graphLine.setLine(j, graphY, j, graphY + graphH);
                big.draw(graphLine);
            }
            if (pts == null) {
                pts = new int[graphW];
                values = new float[graphW];
                ptNum = 0;
            } else if (pts.length != graphW) {
                int tmp[] = null;
                float tmpf[] = null;
                if (ptNum < graphW) {
                    tmp = new int[ptNum];
                    System.arraycopy(pts, 0, tmp, 0, ptNum);
                    tmpf = new float[ptNum];
                    System.arraycopy(values, 0, tmpf, 0, ptNum);
                } else {
                    tmp = new int[graphW];
                    System.arraycopy(pts, ptNum - graphW, tmp, 0, graphW);
                    tmpf = new float[graphW];
                    System.arraycopy(values, ptNum - graphW, tmpf, 0, graphW);
                    ptNum = graphW;
                }
                pts = new int[graphW];
                System.arraycopy(tmp, 0, pts, 0, tmp.length);
                values = new float[graphW];
                System.arraycopy(tmpf, 0, values, 0, tmpf.length);
            } else {
                if (ptNum > values.length) {
                    System.out.println(""size = "" + getSize());
                    System.out.println(""w = "" + w + "", h = "" + h);
                    System.out.println(""graphW = "" + graphW + "", graphH = "" + graphH);
                    System.out.println(""ptNum = "" + ptNum);
                    return;
                }
                big.setColor(Color.yellow);
                if (animating()) {
                    if (ptNum == graphW) {
                        ptNum--;
                        for (int j = 0; j < ptNum; j++) {
                            pts[j] = pts[j + 1];
                            values[j] = values[j + 1];
                        }
                    }
                    values[ptNum] = usedMemory;
                    pts[ptNum] = (int) (graphY + graphH * (totalMemory - values[ptNum]) / totalMemory);
                    ptNum++;
                }
            }
            if (updatePts) {
                for (int k = 0; k < ptNum; k++) pts[k] = (int) (graphY + graphH * (totalMemory - values[k]) / totalMemory);
                updatePts = false;
            }
            for (int j = graphX + graphW - ptNum + 1, k = 1; k < ptNum; k++, j++) {
                big.drawLine(j - 1, pts[k - 1], j, pts[k]);
            }
        }
",1
2277422,7,"    public String highlightedBestFragmentedText(String content) {
        String fragment = """";
        String[] temp = new String[5];
        String word, stemmed_word;
        String content_copy = new String(content);
        StringTokenizer tokens = new StringTokenizer(content_copy, "" "");
        int i = 0;
        while (tokens.hasMoreTokens()) {
            word = tokens.nextToken();
            stemmed_word = stemmer.stem(word);
            if (userquery.indexOf(stemmed_word) == -1) {
                switch(i) {
                    case 5:
                        for (int j = 0; j < 4; j++) temp[j] = temp[j + 1];
                        temp[4] = word;
                        break;
                    default:
                        temp[i++] = word;
                }
            } else {
                fragment = fragment + ""..."";
                for (int j = 0; j < i; j++) fragment = fragment + "" "" + temp[j];
                fragment = fragment + ""<i><b>"" + word + ""</b></i>"";
                for (int j = 0; j < 5; j++) {
                    if (tokens.hasMoreTokens()) {
                        word = tokens.nextToken();
                        stemmed_word = stemmer.stem(word);
                        if (userquery.indexOf(stemmed_word) != -1) {
                            fragment = fragment + ""  "" + ""<i><b>"" + word + ""</b></i>"";
                        } else {
                            fragment = fragment + "" "" + word;
                        }
                    }
                }
                i = 0;
            }
            if (fragment.length() > 150) break;
        }
        return fragment + ""..."";
    }
",1
3126010,7,"    public void pop() {
        for (int i = 0; i < Config.NUMAKKUS - 1; ++i) accu[i] = accu[i + 1];
    }
",1
5332051,7,"    protected static final void determineThresholdsRB(int i, int j, double[][] in0, double[][] inG, double[][] in2, double[] ave0, double[] Gave, double[] ave2, int[] ind) {
        for (int k = 0; k < ind.length; k++) {
            switch(ind[k]) {
                case 0:
                    ave0[0] = 1. / 2. * (in0[i][j] + in0[i - 2][j]);
                    Gave[0] = inG[i - 1][j];
                    ave2[0] = 1. / 2. * (in2[i - 1][j - 1] + in2[i - 1][j + 1]);
                    break;
                case 1:
                    ave0[1] = 1. / 2. * (in0[i][j] + in0[i][j + 2]);
                    Gave[1] = inG[i][j + 1];
                    ave2[1] = 1. / 2. * (in2[i - 1][j + 1] + in2[i + 1][j + 1]);
                    break;
                case 2:
                    ave0[2] = 1. / 2. * (in0[i][j] + in0[i + 2][j]);
                    Gave[2] = inG[i + 1][j];
                    ave2[2] = 1. / 2. * (in2[i + 1][j - 1] + in2[i + 1][j + 1]);
                    break;
                case 3:
                    ave0[3] = 1. / 2. * (in0[i][j] + in0[i][j - 2]);
                    Gave[3] = inG[i][j - 1];
                    ave2[3] = 1. / 2. * (in2[i - 1][j - 1] + in2[i + 1][j - 1]);
                    break;
                case 4:
                    ave0[4] = 1. / 2. * (in0[i][j] + in0[i - 2][j + 2]);
                    Gave[4] = 1. / 4. * (inG[i][j + 1] + inG[i - 1][j + 2] + inG[i - 1][j] + inG[i - 2][j + 1]);
                    ave2[4] = in2[i - 1][j + 1];
                    break;
                case 5:
                    ave0[5] = 1. / 2. * (in0[i][j] + in0[i + 2][j + 2]);
                    Gave[5] = 1. / 4. * (inG[i][j + 1] + inG[i + 1][j + 2] + inG[i + 1][j] + inG[i + 2][j + 1]);
                    ave2[5] = in2[i + 1][j + 1];
                    break;
                case 6:
                    ave0[6] = 1. / 2. * (in0[i][j] + in0[i - 2][j - 2]);
                    Gave[6] = 1. / 4. * (inG[i][j - 1] + inG[i - 1][j - 2] + inG[i - 1][j] + inG[i - 2][j - 1]);
                    ave2[6] = in2[i - 1][j - 1];
                    break;
                case 7:
                    ave0[7] = 1. / 2. * (in0[i][j] + in0[i + 2][j - 2]);
                    Gave[7] = 1. / 4. * (inG[i][j - 1] + inG[i + 1][j - 2] + inG[i + 1][j] + inG[i + 2][j - 1]);
                    ave2[7] = in2[i + 1][j - 1];
                    break;
            }
        }
    }
",1
20471645,7,"    protected void shiftRight() {
        for (int i = 0; i < DIGITS - 1; i++) mant[i] = mant[i + 1];
        mant[DIGITS - 1] = 0;
        exp++;
    }
",0
238090,7,"    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.out.println(""Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}"");
            return;
        }
        int argc = args.length;
        if (args[0].equals(""-debug"")) {
            DEBUG = true;
            argc--;
            for (int i = 0; i < argc; i++) args[i] = args[i + 1];
        }
        int limit = argc;
        argc = 2;
        for (int i = 2; i < limit; i++) {
            if (args[i].indexOf(""="") < 0) args[argc - 1] = args[argc - 1] + "" "" + args[i]; else {
                args[argc++] = args[i];
            }
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        if (DEBUG) System.out.println(""in:"" + args[0] + ""\nout:"" + args[1]);
        try {
            if (args[0].indexOf(File.separator) != -1) inDir = args[0].substring(0, args[0].lastIndexOf(File.separator) + 1); else inDir = """";
            inStream = new FileInputStream(args[0]);
            outStream = new FileOutputStream(args[1]);
            String[] vars = new String[argc - 2];
            String[] vals = new String[argc - 2];
            for (int i = 2; i < argc; i++) {
                String arg = args[i];
                int pos = arg.indexOf(""="");
                vars[i - 2] = arg.substring(0, pos);
                vals[i - 2] = arg.substring(pos + 1);
                if (DEBUG) System.out.println(vars[i - 2] + "" = "" + vals[i - 2]);
            }
            GenerateFromTemplate gft = new GenerateFromTemplate(inStream, outStream);
            gft.setSubst(vars, vals);
            gft.generateOutputFromTemplate();
        } finally {
            try {
                inStream.close();
                outStream.close();
            } catch (Exception e) {
            }
        }
    }
",1
13274348,7,"    public void remove(int index) {
        if (index >= listSize || index < 0) throw new IndexOutOfBoundsException();
        listSize--;
        if (index == listSize) {
            list[listSize] = null;
            return;
        }
        for (int i = index; i < listSize; i++) {
            list[i] = list[i + 1];
        }
        list[listSize] = null;
    }
",0
19632761,7,"    public void read_wchar_array(char[] val, int voff, int vlen) {
        if (0 == vlen) {
            return;
        }
        if (m_wchar_enc == null) {
            if (m_version.minor == 0) {
                cancel(new org.omg.CORBA.BAD_OPERATION(""Wchar not supported in IIOP 1.0"", IIOPMinorCodes.BAD_OPERATION_IIOP_VERSION, CompletionStatus.COMPLETED_MAYBE));
            } else {
                cancel(new org.omg.CORBA.MARSHAL(""Missing wchar encoder."", IIOPMinorCodes.MARSHAL_WCHAR, CompletionStatus.COMPLETED_MAYBE));
            }
            return;
        }
        byte[] buf;
        int off;
        int len;
        switch(m_version.minor) {
            case 0:
                cancel(new org.omg.CORBA.MARSHAL(""Wchar not supported in IIOP 1.0"", IIOPMinorCodes.BAD_OPERATION_IIOP_VERSION, CompletionStatus.COMPLETED_MAYBE));
                break;
            case 1:
                alignment(2);
                m_tmp_len.value = 2 * vlen;
                len = m_tmp_len.value;
                next(m_tmp_buf, m_tmp_off, m_tmp_len);
                postread(len - m_tmp_len.value);
                if (m_tmp_len.value != 0) {
                    buf = new byte[len];
                    off = 0;
                    System.arraycopy(m_tmp_buf.value, m_tmp_off.value, buf, 0, len - m_tmp_len.value);
                    read_octet_array(buf, len - m_tmp_len.value, m_tmp_len.value);
                    if (m_wchar_reverse) {
                        byte tmp;
                        for (int i = 0; i < len; i += 2) {
                            tmp = buf[i];
                            buf[i] = buf[i + 1];
                            buf[i + 1] = tmp;
                        }
                    }
                } else if (m_wchar_reverse) {
                    buf = new byte[len];
                    off = 0;
                    for (int i = 0; i < len; i += 2) {
                        buf[0] = m_tmp_buf.value[m_tmp_off.value + i + 1];
                        buf[1] = m_tmp_buf.value[m_tmp_off.value + i];
                    }
                } else {
                    buf = m_tmp_buf.value;
                    off = m_tmp_off.value;
                }
                try {
                    String s = new String(buf, off, len, m_wchar_enc);
                    if (s.length() != vlen) {
                        cancel(new org.omg.CORBA.MARSHAL(""Unable to decode char value"", IIOPMinorCodes.MARSHAL_CHAR, CompletionStatus.COMPLETED_MAYBE));
                    }
                    s.getChars(0, vlen, val, voff);
                } catch (final UnsupportedEncodingException ex) {
                    getLogger().error(""Unsupported encoding should be impossible."", ex);
                }
                return;
            case 2:
                alignment(1);
                int post = 0;
                for (int c = 0; c < vlen; ++c) {
                    m_tmp_len.value = 1;
                    next(m_tmp_buf, m_tmp_off, m_tmp_len);
                    len = m_tmp_buf.value[m_tmp_off.value];
                    m_tmp_len.value = m_tmp_buf.value[m_tmp_off.value];
                    next(m_tmp_buf, m_tmp_off, m_tmp_len);
                    if (m_tmp_len.value != 0) {
                        postread(post + len + 1 - m_tmp_len.value);
                        post = 0;
                        buf = new byte[len];
                        off = 0;
                        System.arraycopy(m_tmp_buf.value, m_tmp_off.value, buf, 0, len - m_tmp_len.value);
                        read_octet_array(buf, len - m_tmp_len.value, m_tmp_len.value);
                        if (m_wchar_reverse) {
                            byte tmp;
                            for (int i = 0; i < m_wchar_align / 2; ++i) {
                                tmp = buf[off + i];
                                buf[off + i] = buf[off + m_wchar_align - i];
                                buf[off + m_wchar_align - i] = tmp;
                            }
                        }
                    } else if (m_wchar_reverse) {
                        buf = new byte[len];
                        off = 0;
                        for (int i = 0; i < m_wchar_align; ++i) {
                            buf[i] = m_tmp_buf.value[m_tmp_off.value + m_wchar_align - 1];
                        }
                    } else {
                        post += len + 1;
                        buf = m_tmp_buf.value;
                        off = m_tmp_off.value;
                    }
                    try {
                        String s = new String(buf, off, len, m_wchar_enc);
                        if (s.length() != 1) {
                            cancel(new org.omg.CORBA.MARSHAL(""Unable to decode wchar value"", IIOPMinorCodes.MARSHAL_WCHAR, CompletionStatus.COMPLETED_MAYBE));
                        }
                        val[voff + c] = s.charAt(0);
                    } catch (final UnsupportedEncodingException ex) {
                        getLogger().error(""Unsupported encoding should be impossible."", ex);
                    }
                }
                if (post > 0) {
                    postread(post);
                }
                break;
        }
    }
",1
14398500,7,"    public void removeTabPanel(int i) {
        if (i < 0 || i >= nbTab) return;
        tabPanel.remove(cards[i]);
        for (int j = i; j < nbTab - 1; j++) {
            arrName[j] = arrName[j + 1];
            cards[j] = cards[j + 1];
        }
        nbTab--;
        if (selected == i) select(Math.min(selected + 1, nbTab - 1));
        mustRecalculate = true;
        repaint();
    }
",1
323857,7,"    public void addText(String s) {
        int i;
        for (i = 0; i < lines.length - 1; i++) lines[i] = lines[i + 1];
        lines[i] = s;
        String tmp = """";
        for (i = 0; i < lines.length; i++) tmp += lines[i] + ""\n"";
        textArea.setText(tmp);
        textArea.refresh();
    }
",1
19170235,7,"    public void run() {
        try {
            Socket.setSocketImplFactory(new SocketImplFactory() {

                public SocketImpl createSocketImpl() {
                    return new JikesRVMSocketImpl();
                }
            });
            ServerSocket.setSocketFactory(new SocketImplFactory() {

                public SocketImpl createSocketImpl() {
                    return new JikesRVMSocketImpl();
                }
            });
            DatagramSocket.setDatagramSocketImplFactory(new DatagramSocketImplFactory() {

                public DatagramSocketImpl createDatagramSocketImpl() {
                    throw new VM_UnimplementedError(""Need to implement JikesRVMDatagramSocketImpl"");
                }
            });
        } catch (java.io.IOException e) {
            VM.sysWrite(""trouble setting socket impl factories"");
        }
        VM_Controller.boot();
        ClassLoader cl = VM_ClassLoader.getApplicationClassLoader();
        setContextClassLoader(cl);
        VM_Class cls = null;
        try {
            VM_Atom mainAtom = VM_Atom.findOrCreateUnicodeAtom(args[0].replace('.', '/'));
            VM_TypeReference mainClass = VM_TypeReference.findOrCreate(cl, mainAtom.descriptorFromClassName());
            cls = mainClass.resolve().asClass();
            cls.resolve();
            cls.instantiate();
            cls.initialize();
        } catch (ClassNotFoundException e) {
            VM.sysWrite(e + ""\n"");
            return;
        }
        mainMethod = cls.findMainMethod();
        if (mainMethod == null) {
            VM.sysWrite(cls + "" doesn't have a \""public static void main(String[])\"" method to execute\n"");
            return;
        }
        String[] mainArgs = new String[args.length - 1];
        for (int i = 0, n = mainArgs.length; i < n; ++i) mainArgs[i] = args[i + 1];
        mainMethod.compile();
        VM_Callbacks.notifyStartup();
        VM.debugBreakpoint();
        VM_Magic.invokeMain(mainArgs, mainMethod.getCurrentCompiledMethod().getInstructions());
    }
",1
20502523,7,"    Roi getRoi() {
        IJ.showStatus(""Converting threshold to selection"");
        boolean[] prevRow, thisRow;
        ArrayList polygons = new ArrayList();
        Outline[] outline;
        int progressInc = Math.max(h / 50, 1);
        prevRow = new boolean[w + 2];
        thisRow = new boolean[w + 2];
        outline = new Outline[w + 1];
        for (int y = 0; y <= h; y++) {
            boolean[] b = prevRow;
            prevRow = thisRow;
            thisRow = b;
            for (int x = 0; x <= w; x++) {
                if (y < h && x < w) thisRow[x + 1] = selected(x, y); else thisRow[x + 1] = false;
                if (thisRow[x + 1]) {
                    if (!prevRow[x + 1]) {
                        if (outline[x] == null) {
                            if (outline[x + 1] == null) {
                                outline[x + 1] = outline[x] = new Outline();
                                outline[x].push(x + 1, y);
                                outline[x].push(x, y);
                            } else {
                                outline[x] = outline[x + 1];
                                outline[x + 1] = null;
                                outline[x].push(x, y);
                            }
                        } else {
                            if (outline[x + 1] == null) {
                                outline[x + 1] = outline[x];
                                outline[x] = null;
                                outline[x + 1].shift(x + 1, y);
                            } else if (outline[x + 1] == outline[x]) {
                                polygons.add(outline[x].getPolygon());
                                outline[x] = outline[x + 1] = null;
                            } else {
                                outline[x].shift(outline[x + 1]);
                                for (int x1 = 0; x1 <= w; x1++) if (x1 != x + 1 && outline[x1] == outline[x + 1]) {
                                    outline[x1] = outline[x];
                                    outline[x] = outline[x + 1] = null;
                                    break;
                                }
                                if (outline[x] != null) throw new RuntimeException(""assertion failed"");
                            }
                        }
                    }
                    if (!thisRow[x]) {
                        if (outline[x] == null) throw new RuntimeException(""assertion failed!"");
                        outline[x].push(x, y + 1);
                    }
                } else {
                    if (prevRow[x + 1]) {
                        if (outline[x] == null) {
                            if (outline[x + 1] == null) {
                                outline[x] = outline[x + 1] = new Outline();
                                outline[x].push(x, y);
                                outline[x].push(x + 1, y);
                            } else {
                                outline[x] = outline[x + 1];
                                outline[x + 1] = null;
                                outline[x].shift(x, y);
                            }
                        } else if (outline[x + 1] == null) {
                            outline[x + 1] = outline[x];
                            outline[x] = null;
                            outline[x + 1].push(x + 1, y);
                        } else if (outline[x + 1] == outline[x]) {
                            polygons.add(outline[x].getPolygon());
                            outline[x] = outline[x + 1] = null;
                        } else {
                            outline[x].push(outline[x + 1]);
                            for (int x1 = 0; x1 <= w; x1++) if (x1 != x + 1 && outline[x1] == outline[x + 1]) {
                                outline[x1] = outline[x];
                                outline[x] = outline[x + 1] = null;
                                break;
                            }
                            if (outline[x] != null) throw new RuntimeException(""assertion failed"");
                        }
                    }
                    if (thisRow[x]) {
                        if (outline[x] == null) throw new RuntimeException(""assertion failed"");
                        outline[x].shift(x, y + 1);
                    }
                }
            }
            if ((y & progressInc) == 0) IJ.showProgress(y + 1, h + 1);
        }
        GeneralPath path = new GeneralPath(GeneralPath.WIND_EVEN_ODD);
        for (int i = 0; i < polygons.size(); i++) path.append((Polygon) polygons.get(i), false);
        ShapeRoi shape = new ShapeRoi(path);
        Roi roi = shape != null ? shape.shapeToRoi() : null;
        IJ.showProgress(1, 1);
        if (roi != null) return roi; else return shape;
    }
",0
621550,7,"    public void addRandomRows(int count) {
        Row r;
        for (int i = 0; i < count; i++) {
            r = new Row(ROWS - 1);
            for (int z = 0; z < r.blocks.length; z++) {
                if (Math.abs((int) rand.nextLong() % 6) != 0) {
                    int color = Brick.colors[Math.abs((int) rand.nextLong() % 7)];
                    r.blocks[z] = new Block(color, z, ROWS - 1);
                }
            }
            for (int y = 0; y < ROWS - 1; y++) {
                rows[y] = rows[y + 1];
            }
            rows[ROWS - 1] = r;
        }
        repaint();
    }
",1
23543173,7,"    private void init() {
        AudibleButton button;
        PictureEntry current;
        JScrollPane scrollPane;
        JPanel entryPanel;
        JPanel infoPanel;
        JPanel mainPanel;
        JPanel flowPanel;
        JLabel label;
        Image image;
        float f;
        float g;
        int i;
        int j;
        for (i = 0; i < entries_.length - 1; i++) {
            for (j = 0; j < entries_.length - i - 1; j++) {
                f = entries_[j].distance;
                g = entries_[j + 1].distance;
                if (f > g) {
                    current = entries_[j];
                    entries_[j] = entries_[j + 1];
                    entries_[j + 1] = current;
                }
            }
        }
        setLayout(new BorderLayout());
        if (entries_.length == 0) {
            mainPanel = new JPanel();
            label = new JLabel(""Keine Bilder gefunden"");
            mainPanel.add(label);
            add(mainPanel, BorderLayout.CENTER);
        } else {
            mainPanel = new JPanel(new GridLayout(0, 1));
            scrollPane = new JScrollPane(mainPanel, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
            for (i = 0; i < entries_.length; i++) {
                current = entries_[i];
                try {
                    image = Images.newImage(current.thumbnail);
                    image = image.getScaledInstance(140, 140, Image.SCALE_SMOOTH);
                    button = new AudibleButton(new ImageIcon(image));
                } catch (Exception e) {
                    button = new AudibleButton(""kein Bild"");
                }
                entryPanel = new JPanel(new BorderLayout());
                button.setPreferredSize(new Dimension(150, 150));
                button.addActionListener(controller_);
                button.setActionCommand(SearchController.FETCH + "" "" + (id_ - 1) + "" "" + i);
                entryPanel.add(button, BorderLayout.WEST);
                infoPanel = new JPanel(new GridLayout(0, 1));
                label = new JLabel("" "" + current.name);
                label.setForeground(Color.black);
                infoPanel.add(label);
                label = new JLabel("" Bild�hnlichkeit: "" + ((int) ((1f - current.distance) * 100f)) + ""%"");
                label.setForeground(Color.black);
                infoPanel.add(label);
                label = new JLabel("" Preis: "" + current.price + "" Euro"");
                label.setForeground(Color.black);
                infoPanel.add(label);
                entryPanel.add(infoPanel, BorderLayout.CENTER);
                mainPanel.add(entryPanel);
            }
            add(scrollPane, BorderLayout.CENTER);
        }
        flowPanel = new JPanel();
        button = new AudibleButton(""Suchergebnis l�schen"");
        button.addActionListener(controller_);
        button.setActionCommand(SearchController.CLOSE + "" "" + id_);
        flowPanel.add(button);
        add(flowPanel, BorderLayout.SOUTH);
    }
",1
8176616,7,"    protected static float lpCoeffs(float[] data, int dataOff, int dataLen, float[] coeffBuf, int coeffNum) {
        int i, j, k;
        float f;
        float[] wk1 = new float[dataLen - 1];
        float[] wk2 = new float[dataLen - 1];
        float[] wkm = new float[coeffNum - 1];
        float xms, num, denom;
        for (j = dataLen, i = dataLen + dataOff, f = 0.0f; j < i; j++) {
            f += data[j] * data[j];
        }
        xms = f / dataLen;
        wk1[0] = data[0];
        wk2[dataLen - 2] = data[dataLen - 1];
        System.arraycopy(data, dataOff, wk1, 0, dataLen - 1);
        System.arraycopy(data, dataOff + 1, wk2, 0, dataLen - 1);
        for (k = 0; ; ) {
            num = 0.0f;
            denom = 0.0f;
            for (j = 0, i = dataLen - k - 1; j < i; j++) {
                num += wk1[j] * wk2[j];
                denom += wk1[j] * wk1[j] + wk2[j] * wk2[j];
            }
            if (denom > 0.0f) {
                f = 2.0f * num / denom;
            } else {
                f = 1.0f;
            }
            coeffBuf[k] = f;
            xms *= 1.0f - f * f;
            for (i = 0; i < k; i++) {
                coeffBuf[i] = wkm[i] - f * wkm[k - i - 1];
            }
            if (++k == coeffNum) return xms;
            System.arraycopy(coeffBuf, 0, wkm, 0, k);
            for (j = 0, i = dataLen - k - 1; j < i; j++) {
                wk1[j] -= f * wk2[j];
                wk2[j] = wk2[j + 1] - f * wk1[j + 1];
            }
        }
    }
",1
4600730,7,"    private static String FixString(String s) {
        if (ignoreCase) s = s.toUpperCase();
        char[] a = s.toCharArray();
        int len = a.length;
        if (len == 2) SemError(29);
        boolean spaces = false;
        int start = a[0];
        for (int i = 1; i <= len - 2; i++) {
            if (a[i] <= ' ') spaces = true;
            if (a[i] == '\\') {
                if (a[i + 1] == '\\' || a[i + 1] == '\'' || a[i + 1] == '\""') {
                    for (int j = i; j < len - 1; j++) a[j] = a[j + 1];
                    len--;
                }
            }
        }
        a[0] = '""';
        a[len - 1] = '""';
        if (spaces) SemError(24);
        return new String(a, 0, len);
    }
",1
5653782,7,"    public static final double[] Preprocess_Series(double[] v, boolean seriesFixedLength, boolean Nor, boolean Tip, boolean Dif) {
        int longitud = v.length;
        double min = Double.MAX_VALUE;
        double max = Double.MIN_VALUE;
        double total = 0;
        for (int pos = 0; pos < longitud; pos++) {
            if (v[pos] < min) min = v[pos];
            if (v[pos] > max) max = v[pos];
            total += v[pos];
        }
        double amplitud = max - min;
        double media = total / longitud;
        double suma = 0;
        if (Nor) {
            for (int i = 0; i < longitud; i++) v[i] = (v[i] - min) / amplitud;
        } else if (Tip) {
            for (int i = 0; i < longitud; i++) suma += Math.pow(v[i] - media, 2);
            if (suma > 0) {
                double desv = Math.sqrt(suma / (longitud - 1));
                for (int i = 0; i < longitud; i++) v[i] = (v[i] - media) / desv;
            }
        }
        if (Dif) longitud--;
        double[] aux = new double[longitud];
        if (Dif) for (int i = 0; i < longitud; i++) aux[i] = v[i + 1] - v[i]; else for (int i = 0; i < longitud; i++) aux[i] = v[i];
        return aux;
    }
",1
5272382,13,"    private void addStat(int id, int submitTime, int dataId, int dataSize, int userId) throws SQLException {
        int runTime = MIN_RUNTIME + random.nextInt(MAX_RUNTIME - MIN_RUNTIME);
        stat.setInt(1, id);
        stat.setInt(2, submitTime);
        stat.setInt(3, runTime);
        stat.setInt(4, dataId);
        stat.setInt(5, dataSize);
        stat.setInt(6, userId);
        stat.addBatch();
    }
",1
17057125,13,"    public static void generate(int seed) throws SlickException {
        if (!initDone) throw new SlickException(""Use init() first."");
        Random rnd = new Random(seed);
        int rocks = 11;
        for (int i = 0; i < rocks; i++) {
            int x = 46 + rnd.nextInt(W - 46);
            int y = 46 + rnd.nextInt(H - 46);
            Disc(x, y, 8, Properties.ids.get(""stone""));
        }
        int trees = 10;
        int tree_height = 50;
        int tree_width = 50;
        int branches_height = 50;
        int branches_width = 50;
        for (int i = 0; i < trees; i++) {
            int y = tree_height + branches_height + rnd.nextInt(H - tree_height - branches_height);
            int x = tree_width + branches_width + rnd.nextInt(W - tree_width - branches_width);
            int tree_top = y - tree_height;
            for (int a = y - tree_height; a < y; a++) {
                map[x][a] = Properties.ids.get(""wood"");
                map[x - 1][a] = Properties.ids.get(""wood"");
                map[x + 1][a] = Properties.ids.get(""wood"");
            }
            Disc(x, y - (tree_height + 16), 32, Properties.ids.get(""plant""));
        }
        int lakes = 1;
        for (int i = 0; i < lakes; i++) {
            int x = 46 + rnd.nextInt(W - 46);
            int y = 46 + rnd.nextInt(H - 46);
            Circle(x, y, 64, Properties.ids.get(""stone""));
            Circle(x + 1, y, 64, Properties.ids.get(""stone""));
            Disc(x, y, 60, Properties.ids.get(""water""));
        }
        int house_width = 50;
        int house_height = 50;
        int x = 4 + rnd.nextInt(46);
        int y = 4 + rnd.nextInt(H - 4);
        for (int i = x; i < x + house_width; i++) {
            for (int a = y; a < y + house_height; a++) {
                map[i][a] = Properties.ids.get(""house"");
            }
        }
    }
",0
10685284,13,"    private static Color getRandColor(int fc, int bc) {
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + RandomUtil.nextInt(bc - fc);
        int g = fc + RandomUtil.nextInt(bc - fc);
        int b = fc + RandomUtil.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
9900366,13,"    private int getNumberBetween(int low, int high) {
        Random rand = new Random();
        int retInt = low - 1;
        while (retInt < low) retInt = rand.nextInt(high + 1);
        return retInt;
    }
",1
3000636,13,"    public static int generateRandomNumber(int maxSize) {
        Random rand = new Random();
        int randnum = rand.nextInt();
        randnum = rand.nextInt(maxSize + 1);
        return randnum;
    }
",1
20253121,13,"    private void generateRandomPack2(BitSet pack) {
        pack.set(0, N, true);
        pack.set(N, C, false);
        for (int i = 0; i < N; i++) {
            int j = i + random.nextInt(C - i);
            if (i != j) {
                boolean temp = pack.get(i);
                pack.set(i, pack.get(j));
                pack.set(j, temp);
            }
        }
    }
",1
2584059,13,"    public static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
12999076,13,"        void reset(Random random) {
            rfqAverageNumber = rfqAvgMin + random.nextInt(rfqAvgMax - rfqAvgMin);
        }
",1
12831746,13,"    public void crossover(int c1, int c2, float[] kid) {
        int i, cut1;
        cut1 = 1 + r.nextInt(CHROMOSOME_SIZE - 1);
        for (i = 0; i < cut1; i++) kid[i] = pop[c1][i];
        for (i = cut1; i < CHROMOSOME_SIZE; i++) kid[i] = pop[c2][i];
    }
",1
7635076,13,"    public static int getRndInt(int beginRange, int endRange) {
        int result = 0;
        if (endRange > beginRange && beginRange > 0) {
            result = beginRange + _rnd.nextInt(endRange - beginRange);
        }
        return result;
    }
",0
2446339,13,"    private static double getMinimumDistanceBetweenHubSubMangersForHub(StringMatrix matrix, int targetHubId) {
        double minimumDistance = Double.MAX_VALUE;
        int minIndex = -1;
        int maxIndex = -1;
        for (int i = 0; i < matrix.getNumberOfRows(); i++) {
            int currentHub = matrix.convertDoubleToInteger(i, 0);
            if (currentHub == targetHubId) {
                if (minIndex == -1) {
                    minIndex = i;
                }
                maxIndex = i;
            }
        }
        if (minIndex == maxIndex) {
            return -1.0;
        }
        Random random = new Random();
        for (int i = 0; i < 100; i++) {
            int rowFirstHubSubManager = minIndex + random.nextInt(maxIndex - minIndex);
            int rowSecondHubSubManager = minIndex + random.nextInt(maxIndex - minIndex);
            if (rowFirstHubSubManager == rowSecondHubSubManager) {
                continue;
            }
            Coord coordinateFirstHubSubManager = new CoordImpl(matrix.getDouble(rowFirstHubSubManager, 1), matrix.getDouble(rowFirstHubSubManager, 2));
            Coord coordinateSecondHubSubManager = new CoordImpl(matrix.getDouble(rowSecondHubSubManager, 1), matrix.getDouble(rowSecondHubSubManager, 2));
            if (GeneralLib.getDistance(coordinateFirstHubSubManager, coordinateSecondHubSubManager) < minimumDistance) {
                minimumDistance = GeneralLib.getDistance(coordinateFirstHubSubManager, coordinateSecondHubSubManager);
            }
        }
        while (minimumDistance == Double.MAX_VALUE) {
            return -1.0;
        }
        return minimumDistance;
    }
",1
13913361,13,"    @Override
    public void crossover(AttributeWeightedExampleSet es1, AttributeWeightedExampleSet es2) {
        LinkedList<AttributeWeightContainer> dummyList1 = new LinkedList<AttributeWeightContainer>();
        LinkedList<AttributeWeightContainer> dummyList2 = new LinkedList<AttributeWeightContainer>();
        int maxSize = Math.max(es1.getAttributes().size(), es2.getAttributes().size());
        if (maxSize < 2) return;
        switch(getType()) {
            case SelectionCrossover.ONE_POINT:
                int splitPoint = 1 + random.nextInt(maxSize - 2);
                Iterator<Attribute> it = es1.getAttributes().iterator();
                int counter = 0;
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (counter > splitPoint) {
                        double weight = es1.getWeight(attribute);
                        it.remove();
                        dummyList1.add(new AttributeWeightContainer(attribute, weight));
                    }
                    counter++;
                }
                it = es2.getAttributes().iterator();
                counter = 0;
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (counter > splitPoint) {
                        double weight = es2.getWeight(attribute);
                        it.remove();
                        dummyList2.add(new AttributeWeightContainer(attribute, weight));
                    }
                    counter++;
                }
                break;
            case SelectionCrossover.UNIFORM:
                it = es1.getAttributes().iterator();
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (random.nextBoolean()) {
                        double weight = es1.getWeight(attribute);
                        dummyList1.add(new AttributeWeightContainer(attribute, weight));
                        it.remove();
                    }
                }
                it = es2.getAttributes().iterator();
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (random.nextBoolean()) {
                        double weight = es2.getWeight(attribute);
                        dummyList2.add(new AttributeWeightContainer(attribute, weight));
                        it.remove();
                    }
                }
                break;
            case SelectionCrossover.SHUFFLE:
                double prob1 = (double) (random.nextInt(es1.getAttributes().size() - 1) + 1) / (double) es1.getAttributes().size();
                it = es1.getAttributes().iterator();
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (random.nextDouble() < prob1) {
                        double weight = es1.getWeight(attribute);
                        dummyList1.add(new AttributeWeightContainer(attribute, weight));
                        it.remove();
                    }
                }
                double prob2 = (double) (random.nextInt(es2.getAttributes().size() - 1) + 1) / (double) es2.getAttributes().size();
                it = es2.getAttributes().iterator();
                while (it.hasNext()) {
                    Attribute attribute = it.next();
                    if (random.nextDouble() < prob2) {
                        double weight = es2.getWeight(attribute);
                        dummyList2.add(new AttributeWeightContainer(attribute, weight));
                        it.remove();
                    }
                }
                break;
            default:
                break;
        }
        mergeAttributes(es1, dummyList2);
        mergeAttributes(es2, dummyList1);
    }
",1
15666494,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
14121891,13,"    protected int getRandomValue(int min, int max) {
        int v = min + rand.nextInt(max - min);
        return rand.nextBoolean() ? v : -v;
    }
",1
11205537,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
21516361,13,"    private void updateDirection() {
        this.direction = random.nextInt(DOWN + 1);
    }
",1
21360254,13,"    public Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
5037656,13,"    public static TuringMachine generateTestTuringMachine(char startChar, Random random, int maxCountArray, int maxCountTransition, boolean finiteAutomate, String alphabetIT, String alphabetWT, int maxLengthIT, int maxLengthWT) {
        int lengthIT = random.nextInt(maxLengthIT);
        int lengthWT = random.nextInt(maxLengthWT);
        int ItHead = random.nextInt(lengthIT + 2);
        int WtHead = random.nextInt(lengthWT + 1);
        return generateTestTuringMachine(startChar, new Random(), maxCountArray, maxCountTransition, finiteAutomate, alphabetIT, alphabetWT, lengthIT, lengthWT, ItHead, WtHead);
    }
",1
22513686,13,"    public static int[] calculateMinerals(Solar planet, Random rng) {
        int[] deposits = new int[PlanetResources.Minerals.values().length];
        switch(planet.ptype) {
            case BARE_ROCK:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(401) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(205) / 100;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(205) / 100;
                break;
            case ATM_ROCK:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(401) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(105) / 100;
                break;
            case CLOUD:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(201) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(103) / 100;
                break;
            case EARTH:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(401) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(103) / 100;
                break;
            case ICE:
                deposits[PlanetResources.Minerals.Kaolinite.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Minerals.Cerium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Dysprosium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Erbium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Europium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Gadolinium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Holmium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Lanthanum.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Lutetium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Neodymium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Praseodymium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Promethium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Samarium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Scandium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Terbium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Thulium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Ytterbium.ordinal()] = rng.nextInt(301) / 300;
                deposits[PlanetResources.Minerals.Yttrium.ordinal()] = rng.nextInt(301) / 300;
                break;
            default:
        }
        final int promotionFactor = calculateRichness(planet);
        for (int i = 0; i < deposits.length; i++) {
            if (deposits[i] != 0) {
                int rich = rng.nextInt(promotionFactor + 1);
                rich += deposits[i] - 1;
                deposits[i] = rich;
            }
        }
        return deposits;
    }
",1
9414363,13,"    private static void testForSubSetRemovalStress() {
        IntegerSet previousBits = new IntegerSet(new ConciseSet());
        IntegerSet currentBits = new IntegerSet(new ConciseSet());
        TreeSet<Integer> currentItems = new TreeSet<Integer>();
        currentBits.add(10001);
        currentBits.complement();
        currentItems.addAll(currentBits);
        if (currentItems.size() != 10001) {
            System.out.println(""Unexpected error!"");
            return;
        }
        Random rnd = new MersenneTwister();
        for (int j = 0; j < 100000; j++) {
            previousBits = currentBits;
            currentBits = currentBits.clone();
            int min = rnd.nextInt(10000);
            int max = min + 1 + rnd.nextInt(10000 - (min + 1) + 1);
            int item = rnd.nextInt(10000 + 1);
            System.out.println(""Removing "" + item + "" from the subview from "" + min + "" to "" + max + "" - 1"");
            SortedSet<Integer> subBits = currentBits.subSet(min, max);
            SortedSet<Integer> subItems = currentItems.subSet(min, max);
            boolean subBitsResult = subBits.remove(item);
            boolean subItemsResult = subItems.remove(item);
            if (subBitsResult != subItemsResult || subBits.size() != subItems.size() || !subBits.toString().equals(subItems.toString())) {
                System.out.println(""Subset error!"");
                return;
            }
            if (!checkContent(currentBits, currentItems)) {
                System.out.println(""Subview not correct!"");
                System.out.println(""Same elements: "" + (currentItems.toString().equals(currentBits.toString())));
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            IntegerSet otherBits = new IntegerSet(new ConciseSet());
            otherBits.addAll(currentItems);
            if (otherBits.hashCode() != currentBits.hashCode()) {
                System.out.println(""Representation not correct!"");
                System.out.println(currentBits.debugInfo());
                System.out.println(otherBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
        }
        System.out.println(currentBits.debugInfo());
        System.out.println(IntSetStatistics.summary());
    }
",1
11039579,13,"    public void doSomething() {
        if (!this.isRegisteredAtCoordinator()) {
            try {
                this.registerAtCoordinator();
            } catch (ParticipantException e) {
                System.out.println(""ConcreteService2 exception: "" + e.getLocalizedMessage());
            }
        }
        Random randomGenerator = new Random();
        int r = randomGenerator.nextInt(PROCESSINGTIME_MAX + 1);
        long sleepTimeMilli = 1000;
        if (r < PROCESSINGTIME_MIN) {
            sleepTimeMilli *= PROCESSINGTIME_MIN;
        } else {
            sleepTimeMilli *= r;
        }
        try {
            Thread.sleep(sleepTimeMilli);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        StatisticsManager.getInstance().addFinishedService(true);
    }
",1
4925096,13,"    public static void main(String[] args) throws IOException {
        File dir = new File(""e:/algorithm/url"");
        int FILE_COUNT = 100;
        int FILE_SIZE = 10000000;
        int MAX_URL_LENGTH = 7;
        String[] words = { ""word1"", ""word2"", ""word3"", ""word4"", ""word5"", ""word6"", ""word7"" };
        Random rnd = new Random();
        for (int fileIndex = 0; fileIndex < FILE_COUNT; fileIndex++) {
            File file = new File(dir, ""url_"" + fileIndex + "".data"");
            file.createNewFile();
            PrintWriter writer = new PrintWriter(new FileOutputStream(file));
            for (int i = 0; i < FILE_SIZE; i++) {
                StringBuilder sb = new StringBuilder();
                int urlLen = rnd.nextInt(MAX_URL_LENGTH + 1);
                for (int len = 0; len < urlLen; len++) {
                    sb.append(words[rnd.nextInt(words.length)]);
                }
                writer.println(sb.toString());
            }
            writer.close();
            System.out.println(file.getName() + "" has been written ."");
        }
    }
",1
6482417,13,"    private static String calc(String exp) {
        if (exp.startsWith(""random"")) {
            int beg = exp.indexOf(""("");
            int end = exp.indexOf("")"");
            String[] ss = exp.substring(beg + 1, end).split("","");
            int rb = Integer.parseInt(ss[0]);
            int re = Integer.parseInt(ss[1]);
            int rr = rb + random.nextInt(re - rb);
            return String.valueOf(rr);
        }
        return exp;
    }
",1
22485235,13,"    private static String calc(String exp) {
        if (exp.startsWith(""random"")) {
            int beg = exp.indexOf(""("");
            int end = exp.indexOf("")"");
            String[] ss = exp.substring(beg + 1, end).split("","");
            int rb = Integer.parseInt(ss[0]);
            int re = Integer.parseInt(ss[1]);
            int rr = rb + random.nextInt(re - rb);
            return String.valueOf(rr);
        }
        return exp;
    }
",1
3206815,13,"    public Operator addRandomValidOperatorTo(OperatorChain chain, RandomGenerator random) throws UndefinedParameterError, NoValidOperatorException {
        int which = random.nextInt(MAX_VALID_TYPE + 1);
        Operator vsOp = createValidOperator(which, random);
        addOperator(chain, vsOp, random);
        return vsOp;
    }
",1
2407324,13,"    @Override
    public Bitmap apply(Bitmap source) {
        Bitmap dest = source.clone();
        int w = dest.getWidth();
        int h = dest.getHeight();
        for (int x = 0; x < w; x++) for (int y = 0; y < h; y++) {
            int px = dest.getPixel(x, y);
            int l = mRand.nextInt(mLevel + 1);
            int nx = x + l;
            if (nx >= w) nx = w - 1;
            int ny = y + l;
            if (ny >= h) ny = h - 1;
            dest.setPixel(nx, ny, px);
        }
        return dest;
    }
",0
20867230,13,"    public void testForward() throws IOException {
        System.out.println(""\nforward"");
        BufferForwarder bufferTransformer = new BufferForwarder(ByteBufferForwardingMode.DIRECT);
        byteBufferToArrayTransformer.setNextForwarder(bufferTransformer);
        MyByteBufferCopyForwarder myByteBufferCopyForwarder = new MyByteBufferCopyForwarder();
        bufferTransformer.setNextForwarder(myByteBufferCopyForwarder);
        System.out.println(""one input - one forward"");
        ByteBuffer input = createRandomBuffer(100);
        int size = input.remaining();
        byteBufferToArrayTransformer.forward(input);
        ByteBuffer result = myByteBufferCopyForwarder.getInput();
        assertNull(result);
        bufferTransformer.forward(size);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(size, result.remaining());
        System.out.println(""one input - two forwards"");
        input = createRandomBuffer(100);
        size = input.remaining();
        byteBufferToArrayTransformer.forward(input);
        result = myByteBufferCopyForwarder.getInput();
        int firstHalf = random.nextInt(size + 1);
        bufferTransformer.forward(firstHalf);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(firstHalf, result.remaining());
        int secondHalf = size - firstHalf;
        bufferTransformer.forward(secondHalf);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(secondHalf, result.remaining());
        System.out.println(""two inputs - one forward"");
        input = createRandomBuffer(100);
        size = input.remaining();
        byteBufferToArrayTransformer.forward(input);
        input = createRandomBuffer(100);
        size += input.remaining();
        byteBufferToArrayTransformer.forward(input);
        bufferTransformer.forward(size);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(size, result.remaining());
        System.out.println(""two inputs - two forwards"");
        input = createRandomBuffer(100);
        size = input.remaining();
        byteBufferToArrayTransformer.forward(input);
        input = createRandomBuffer(100);
        size += input.remaining();
        byteBufferToArrayTransformer.forward(input);
        firstHalf = random.nextInt(size + 1);
        bufferTransformer.forward(firstHalf);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(firstHalf, result.remaining());
        secondHalf = size - firstHalf;
        bufferTransformer.forward(secondHalf);
        result = myByteBufferCopyForwarder.getInput();
        assertNotNull(result);
        assertEquals(secondHalf, result.remaining());
    }
",0
4409375,13,"        public static int randomizedPartition(int[] array, int startIndex, int endIndex) {
            int i = startIndex + random.nextInt(endIndex - startIndex);
            swap(array, i, startIndex);
            return partition(array, startIndex, endIndex);
        }
",1
20010244,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
11658920,13,"    private void shuffleNeighborOffsets() {
        for (int i = 0; i < 8; i++) {
            int j = i + rnd.nextInt(8 - i);
            int t = neighborOffsets[i];
            neighborOffsets[i] = neighborOffsets[j];
            neighborOffsets[j] = t;
            t = neighborXYOffsets[i][0];
            neighborXYOffsets[i][0] = neighborXYOffsets[j][0];
            neighborXYOffsets[j][0] = t;
            t = neighborXYOffsets[i][1];
            neighborXYOffsets[i][1] = neighborXYOffsets[j][1];
            neighborXYOffsets[j][1] = t;
        }
    }
",1
19406526,13,"        void doMovements() {
            Random r = new Random();
            int x = 0;
            int y = 0;
            int v = 0;
            String retstr = new String(executeAndGetResponse(""c"", rm.out, rm.in));
            System.out.println(retstr);
            while (rm.keepOn) {
                while (isInMotion(rm.out, rm.in)) {
                    try {
                        Thread.sleep(1200);
                        System.out.print('.');
                    } catch (InterruptedException e) {
                    }
                }
                System.out.println();
                x = r.nextInt(XMAX - XMIN + 1) + XMIN;
                y = r.nextInt(YMAX - YMIN + 1) + YMIN;
                v = r.nextInt(VMAX + 1);
                System.out.printf(""   x: %5d     y: %5d     v: %2d\n"", x, y, v);
                retstr = new String(executeAndGetResponse(""x"" + x, rm.out, rm.in));
                System.out.println(retstr);
                retstr = new String(executeAndGetResponse(""y"" + y, rm.out, rm.in));
                System.out.println(retstr);
                retstr = new String(executeAndGetResponse(""v"" + v, rm.out, rm.in));
                System.out.println(retstr);
                retstr = new String(executeAndGetResponse(""m"", rm.out, rm.in));
                System.out.println(retstr);
            }
        }
",1
8206774,13,"    private TravellerChromosome algorithm(TravellerChromosome parent) {
        MersenneTwister mt = MersenneTwister.getTwister();
        TravellerChromosome offspring = new TravellerChromosome(parent);
        offspring.canonicalize();
        double startingFitness = offspring.testFitness();
        int genomeLength = TravellerWorld.getTravellerWorld().getNumberOfCities();
        int permuteGlobalLimit = PermutationController.getGlobalPermuteLimit();
        int permuteStartingLimit = PermutationController.getStartingPermuteLimit();
        int permuteCurrentLimit = PermutationController.getCurrentPermuteLimit();
        double selectionChance = 0.0D;
        if (genomeLength > permuteGlobalLimit) {
            selectionChance = ((double) permuteCurrentLimit) / ((double) (permuteStartingLimit + permuteGlobalLimit));
        } else {
            selectionChance = ((double) permuteGlobalLimit) / 100.0D;
        }
        int selectees[] = new int[genomeLength];
        boolean selected[] = new boolean[genomeLength];
        for (int i = 0; i < genomeLength; i++) {
            selectees[i] = -1;
            selected[i] = false;
        }
        int offset = mt.nextInt(genomeLength);
        int selectionCount = 0;
        for (int i = 0; i < genomeLength; i++) {
            if (mt.nextDouble() < selectionChance) {
                selectees[selectionCount] = parent.getCity(i + offset);
                selected[(i + offset) % genomeLength] = true;
                selectionCount++;
            }
            if (selectionCount >= permuteCurrentLimit) {
                break;
            }
        }
        if (selectionCount != 0) {
            int unselectedIndex = 0;
            int copiedCount = 0;
            int lefties = mt.nextInt(genomeLength - selectionCount);
            while (copiedCount < lefties) {
                while (selected[unselectedIndex]) {
                    unselectedIndex++;
                }
                offspring.setCity(copiedCount, parent.getCity(unselectedIndex));
                unselectedIndex++;
                copiedCount++;
            }
            for (int currentSlot = selectionCount - 1; currentSlot > 0; currentSlot--) {
                int swapSlot = mt.nextInt(currentSlot + 1);
                int temp = selectees[swapSlot];
                selectees[swapSlot] = selectees[currentSlot];
                selectees[currentSlot] = temp;
            }
            for (int i = 0; i < selectionCount; i++) {
                offspring.setCity(copiedCount, selectees[i]);
                copiedCount++;
            }
            while (copiedCount < genomeLength) {
                while (selected[unselectedIndex]) {
                    unselectedIndex++;
                }
                offspring.setCity(copiedCount, parent.getCity(unselectedIndex));
                unselectedIndex++;
                copiedCount++;
            }
        }
        offspring.canonicalize();
        double finalFitness = offspring.testFitness();
        if (adaptPermutation) {
            if ((finalFitness > startingFitness) || (Math.abs(finalFitness - startingFitness) < TravellerStatus.LITTLE_FUZZ)) {
                PermutationController.reportFailure();
            } else {
                PermutationController.reportSuccess();
            }
        }
        return offspring;
    }
",1
2670867,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
10816274,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
20635236,13,"    private FuncionPorTramosVectorial creaFuncionColoresBandas(int minColores, int maxColores, Vector3d[] colores, Vector3d colorExtremos, Random random) {
        FuncionPorTramosVectorial funcionColores = new FuncionPorTramosVectorial();
        int numColores = minColores + random.nextInt(maxColores - minColores);
        if (numColores > 0) {
            if (colorExtremos != null) {
                funcionColores.nuevoPunto(0.0d, colorExtremos);
            } else {
                funcionColores.nuevoPunto(0.0d, colorBanda(colores, random));
            }
            if (numColores > 1) {
                funcionColores.nuevoPunto(1.0d, colorBanda(colores, random));
                if (numColores > 2) {
                    double lat = 0.0d;
                    double dLat = 1.0d / (numColores - 2);
                    for (int i = 2; i < numColores - 1; i++) {
                        lat += dLat + random.nextDouble() * 4.0d;
                        funcionColores.nuevoPunto(lat, colorBanda(colores, random));
                    }
                    lat += dLat + random.nextDouble() * 4.0d;
                    if (colorExtremos != null) {
                        funcionColores.nuevoPunto(lat, colorExtremos);
                    } else {
                        funcionColores.nuevoPunto(lat, colorBanda(colores, random));
                    }
                }
            }
            funcionColores.normalizarX();
        }
        return funcionColores;
    }
",1
14823678,13,"    public void testRandomlyAgainstJavaList() {
        PVector<Integer> pvec = TreePVector.empty();
        List<Integer> list = new LinkedList<Integer>();
        Random r = new Random();
        for (int i = 0; i < 1000; i++) {
            if (pvec.size() == 0 || r.nextBoolean()) {
                if (r.nextBoolean()) {
                    Integer v = r.nextInt();
                    assertEquals(list.contains(v), pvec.contains(v));
                    list.add(v);
                    pvec = pvec.plus(v);
                } else {
                    int k = r.nextInt(pvec.size() + 1);
                    Integer v = r.nextInt();
                    assertEquals(list.contains(v), pvec.contains(v));
                    if (k < pvec.size()) assertEquals(list.get(k), pvec.get(k));
                    list.add(k, v);
                    pvec = pvec.plus(k, v);
                }
            } else if (r.nextBoolean()) {
                int k = r.nextInt(pvec.size());
                Integer v = r.nextInt();
                list.set(k, v);
                pvec = pvec.with(k, v);
            } else {
                int j = r.nextInt(pvec.size()), k = 0;
                for (Integer e : pvec) {
                    assertTrue(list.contains(e));
                    assertTrue(pvec.contains(e));
                    assertEquals(e, pvec.get(k));
                    assertEquals(list.get(k), pvec.get(k));
                    UtilityTest.assertEqualsAndHash(pvec, pvec.minus(k).plus(k, pvec.get(k)));
                    UtilityTest.assertEqualsAndHash(pvec, pvec.plus(k, 10).minus(k));
                    if (k == j) {
                        list.remove(k);
                        pvec = pvec.minus(k);
                        k--;
                        j = -1;
                    }
                    k++;
                }
            }
            Integer v = r.nextInt();
            assertEquals(list.contains(v), pvec.contains(v));
            list.remove(v);
            pvec = pvec.minus(v);
            String s = Integer.toString(v);
            assertFalse(pvec.contains(v));
            pvec = pvec.minus(s);
            assertEquals(list.size(), pvec.size());
            UtilityTest.assertEqualsAndHash(list, pvec);
            UtilityTest.assertEqualsAndHash(pvec, TreePVector.from(pvec));
            UtilityTest.assertEqualsAndHash(TreePVector.empty(), pvec.minusAll(pvec));
            UtilityTest.assertEqualsAndHash(pvec, TreePVector.empty().plusAll(pvec));
            UtilityTest.assertEqualsAndHash(pvec, TreePVector.singleton(10).plusAll(1, pvec).minus(0));
            int end = r.nextInt(pvec.size() + 1), start = r.nextInt(end + 1);
            UtilityTest.assertEqualsAndHash(pvec.subList(start, end), list.subList(start, end));
        }
    }
",1
15564158,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
20277574,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
19569166,13,"    public Object newValue(Random random) {
        if (random.nextBoolean()) {
            return null;
        }
        StringBuilder strBuilder = new StringBuilder();
        int remainingLength = minLength + random.nextInt(maxLength - minLength);
        boolean endsWithPunctuation = random.nextBoolean();
        if (endsWithPunctuation) {
            remainingLength--;
        }
        String word = getWord(remainingLength, random);
        strBuilder.append(word);
        remainingLength -= word.length();
        while (remainingLength > 1) {
            strBuilder.append(getChar(midPunctuation, random));
            remainingLength--;
            word = getWord(remainingLength, random);
            strBuilder.append(word);
            remainingLength -= word.length();
        }
        if (endsWithPunctuation) {
            strBuilder.append(getChar(endPunctuation, random));
        }
        return strBuilder.toString();
    }
",1
3290612,13,"    private static Color getRandomColor(int minColor, int maxColor) {
        Random random = new Random();
        int red = minColor + random.nextInt(maxColor - minColor);
        int green = minColor + random.nextInt(maxColor - minColor);
        int blue = minColor + random.nextInt(maxColor - minColor);
        return new Color(red, green, blue);
    }
",1
9414359,13,"    private static void testForAdditionStress(Class<? extends ExtendedSet<Integer>> c) {
        ExtendedSet<Integer> previousBits = empty(c);
        ExtendedSet<Integer> currentBits = empty(c);
        TreeSet<Integer> currentItems = new TreeSet<Integer>();
        Random rnd = new MersenneTwister();
        for (int i = 0; i < 100000; i++) {
            int item = rnd.nextInt(10000 + 1);
            previousBits = currentBits;
            currentBits = currentBits.clone();
            System.out.format(""Adding %d...\n"", item);
            boolean itemExistsBefore = currentItems.contains(item);
            boolean itemAdded = currentItems.add(item);
            boolean itemExistsAfter = currentItems.contains(item);
            boolean bitExistsBefore = currentBits.contains(item);
            boolean bitAdded = currentBits.add(item);
            boolean bitExistsAfter = currentBits.contains(item);
            if (itemAdded ^ bitAdded) {
                System.out.println(""wrong add() result"");
                return;
            }
            if (itemExistsBefore ^ bitExistsBefore) {
                System.out.println(""wrong contains() before"");
                return;
            }
            if (itemExistsAfter ^ bitExistsAfter) {
                System.out.println(""wrong contains() after"");
                return;
            }
            if (!checkContent(currentBits, currentItems)) {
                System.out.println(""add() error"");
                System.out.println(""Same elements: "" + (currentItems.toString().equals(currentBits.toString())));
                System.out.println(""\tcorrect: "" + currentItems.toString());
                System.out.println(""\twrong:   "" + currentBits.toString());
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            ExtendedSet<Integer> otherBits = previousBits.convert(currentItems);
            if (otherBits.hashCode() != currentBits.hashCode()) {
                System.out.println(""Representation error"");
                System.out.println(currentBits.debugInfo());
                System.out.println(otherBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            ExtendedSet<Integer> singleBitSet = empty(c);
            singleBitSet.add(item);
            if (currentItems.size() != currentBits.unionSize(singleBitSet)) {
                System.out.println(""Size error"");
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
        }
        System.out.println(""Final"");
        System.out.println(currentBits.debugInfo());
        System.out.println();
        System.out.println(IntSetStatistics.summary());
    }
",0
22230122,13,"    public void buildClusterer(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        if (!m_dontReplaceMissing) {
            m_ReplaceMissingFilter.setInputFormat(instances);
            instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        }
        m_FullMeansOrModes = new double[instances.numAttributes()];
        m_FullMissingCounts = new int[instances.numAttributes()];
        if (m_displayStdDevs) {
            m_FullStdDevs = new double[instances.numAttributes()];
        }
        m_FullNominalCounts = new int[instances.numAttributes()][0];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_FullMissingCounts[i] = instances.attributeStats(i).missingCount;
            m_FullMeansOrModes[i] = instances.meanOrMode(i);
            if (instances.attribute(i).isNumeric()) {
                if (m_displayStdDevs) {
                    m_FullStdDevs[i] = Math.sqrt(instances.variance(i));
                }
                if (m_FullMissingCounts[i] == instances.numInstances()) {
                    m_FullMeansOrModes[i] = Double.NaN;
                }
            } else {
                m_FullNominalCounts[i] = instances.attributeStats(i).nominalCounts;
                if (m_FullMissingCounts[i] > m_FullNominalCounts[i][Utils.maxIndex(m_FullNominalCounts[i])]) {
                    m_FullMeansOrModes[i] = -1;
                }
            }
        }
        m_Min = new double[instances.numAttributes()];
        m_Max = new double[instances.numAttributes()];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_Min[i] = m_Max[i] = Double.NaN;
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        for (int i = 0; i < instances.numInstances(); i++) {
            updateMinMax(instances.instance(i));
        }
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTableHashKey hk = null;
        for (int j = instances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTableHashKey(instances.instance(instIndex), instances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(instances.instance(instIndex));
                initC.put(hk, null);
            }
            instances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        m_ClusterMissingCounts = new int[m_NumClusters][instances.numAttributes()];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                double[] vals = new double[instances.numAttributes()];
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    for (int j = 0; j < instances.numAttributes(); j++) {
                        vals[j] = tempI[i].meanOrMode(j);
                        m_ClusterMissingCounts[i][j] = tempI[i].attributeStats(j).missingCount;
                        m_ClusterNominalCounts[i][j] = tempI[i].attributeStats(j).nominalCounts;
                        if (tempI[i].attribute(j).isNominal()) {
                            if (m_ClusterMissingCounts[i][j] > m_ClusterNominalCounts[i][j][Utils.maxIndex(m_ClusterNominalCounts[i][j])]) {
                                vals[j] = Instance.missingValue();
                            }
                        } else {
                            if (m_ClusterMissingCounts[i][j] == tempI[i].numInstances()) {
                                vals[j] = Instance.missingValue();
                            }
                        }
                    }
                    m_ClusterCentroids.add(new Instance(1.0, vals));
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                if (converged) {
                    Instances[] t = new Instances[m_NumClusters];
                    int index = 0;
                    for (int k = 0; k < tempI.length; k++) {
                        if (tempI[k].numInstances() > 0) {
                            t[index++] = tempI[k];
                        }
                    }
                    tempI = t;
                } else {
                    tempI = new Instances[m_NumClusters];
                }
            }
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        if (m_displayStdDevs) {
            m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        }
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            if (m_displayStdDevs) {
                double[] vals2 = new double[instances.numAttributes()];
                for (int j = 0; j < instances.numAttributes(); j++) {
                    if (instances.attribute(j).isNumeric()) {
                        vals2[j] = Math.sqrt(tempI[i].variance(j));
                    } else {
                        vals2[j] = Instance.missingValue();
                    }
                }
                m_ClusterStdDevs.add(new Instance(1.0, vals2));
            }
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
",0
2801895,13,"    public void buildClusterer(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        if (!m_dontReplaceMissing) {
            m_ReplaceMissingFilter.setInputFormat(instances);
            instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        }
        m_FullMissingCounts = new int[instances.numAttributes()];
        if (m_displayStdDevs) {
            m_FullStdDevs = new double[instances.numAttributes()];
        }
        m_FullNominalCounts = new int[instances.numAttributes()][0];
        m_FullMeansOrMediansOrModes = moveCentroid(0, instances, false);
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_FullMissingCounts[i] = instances.attributeStats(i).missingCount;
            if (instances.attribute(i).isNumeric()) {
                if (m_displayStdDevs) {
                    m_FullStdDevs[i] = Math.sqrt(instances.variance(i));
                }
                if (m_FullMissingCounts[i] == instances.numInstances()) {
                    m_FullMeansOrMediansOrModes[i] = Double.NaN;
                }
            } else {
                m_FullNominalCounts[i] = instances.attributeStats(i).nominalCounts;
                if (m_FullMissingCounts[i] > m_FullNominalCounts[i][Utils.maxIndex(m_FullNominalCounts[i])]) {
                    m_FullMeansOrMediansOrModes[i] = -1;
                }
            }
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        if (m_PreserveOrder) m_Assignments = clusterAssignments;
        m_DistanceFunction.setInstances(instances);
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTableHashKey hk = null;
        Instances initInstances = null;
        if (m_PreserveOrder) initInstances = new Instances(instances); else initInstances = instances;
        if (m_initializeWithKMeansPlusPlus) {
            kMeansPlusPlusInit(initInstances);
        } else {
            for (int j = initInstances.numInstances() - 1; j >= 0; j--) {
                instIndex = RandomO.nextInt(j + 1);
                hk = new DecisionTableHashKey(initInstances.instance(instIndex), initInstances.numAttributes(), true);
                if (!initC.containsKey(hk)) {
                    m_ClusterCentroids.add(initInstances.instance(instIndex));
                    initC.put(hk, null);
                }
                initInstances.swap(j, instIndex);
                if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                    break;
                }
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        initInstances = null;
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        m_ClusterMissingCounts = new int[m_NumClusters][instances.numAttributes()];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, false, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    moveCentroid(i, tempI[i], true);
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                if (converged) {
                    Instances[] t = new Instances[m_NumClusters];
                    int index = 0;
                    for (int k = 0; k < tempI.length; k++) {
                        if (tempI[k].numInstances() > 0) {
                            t[index++] = tempI[k];
                        }
                    }
                    tempI = t;
                } else {
                    tempI = new Instances[m_NumClusters];
                }
            }
            if (m_Iterations == m_MaxIterations) converged = true;
            if (!converged) {
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        if (!m_FastDistanceCalc) {
            for (i = 0; i < instances.numInstances(); i++) {
                clusterProcessedInstance(instances.instance(i), true, false);
            }
        }
        if (m_displayStdDevs) {
            m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        }
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            if (m_displayStdDevs) {
                double[] vals2 = new double[instances.numAttributes()];
                for (int j = 0; j < instances.numAttributes(); j++) {
                    if (instances.attribute(j).isNumeric()) {
                        vals2[j] = Math.sqrt(tempI[i].variance(j));
                    } else {
                        vals2[j] = Utils.missingValue();
                    }
                }
                m_ClusterStdDevs.add(new DenseInstance(1.0, vals2));
            }
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
",1
8682225,13,"    @Test
    public void testGrabPixelsWhileRunning() throws IOException, BoblightException {
        final Random random = new Random();
        final int scrWidth = SCREEN_WIDTH_MIN + random.nextInt(SCREEN_WIDTH_MAX - SCREEN_WIDTH_MIN);
        final int scrHeight = SCREEN_HEIGHT_MIN + random.nextInt(SCREEN_HEIGHT_MAX - SCREEN_HEIGHT_MIN);
        testable = spy(new AbstractActiveGrabber(client, false, 100, 80) {

            @Override
            public int[] grabPixelAt(int xpos, int ypos) {
                return null;
            }

            @Override
            protected void updateDimensions() {
            }

            @Override
            protected int getScreenWidth() {
                return scrWidth;
            }

            @Override
            protected int getScreenHeight() {
                return scrHeight;
            }

            @Override
            public void setup(FlagManager flagManager) throws BoblightException {
            }

            @Override
            public void cleanup() {
            }
        });
        int size = 2 + random.nextInt(64 - 2);
        Whitebox.setInternalState(testable, ""width"", size);
        Whitebox.setInternalState(testable, ""height"", size);
        doAnswer(new Answer<Object>() {

            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                Whitebox.setInternalState(testable, ""stop"", true);
                return null;
            }
        }).when(client).sendRgb(false, null);
        System.out.println(""Starting test method."");
        testable.run();
        double cellWidth = (double) scrWidth / (double) size;
        double cellHeight = (double) scrHeight / size;
        System.out.println(""Starting verification."");
        for (int width = 0; width < size; width++) {
            for (int height = 0; height < size; height++) {
                final int xpos = (int) (cellWidth / 2 + cellWidth * width);
                final int ypos = (int) (cellHeight / 2 + cellHeight * height);
                verify(testable).grabPixelAt(xpos, ypos);
            }
        }
    }
",1
868920,13,"    public TestThread(int minRunTime, int maxRunTime) {
        Random r = new Random();
        int min = minRunTime;
        int max = maxRunTime;
        actualRunTime = min + r.nextInt(max - min);
    }
",0
5542265,13,"    public void buildClusterer(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        if (!m_dontReplaceMissing) {
            m_ReplaceMissingFilter.setInputFormat(instances);
            instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        }
        m_FullMissingCounts = new int[instances.numAttributes()];
        if (m_displayStdDevs) {
            m_FullStdDevs = new double[instances.numAttributes()];
        }
        m_FullNominalCounts = new int[instances.numAttributes()][0];
        m_FullMeansOrMediansOrModes = moveCentroid(0, instances, false);
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_FullMissingCounts[i] = instances.attributeStats(i).missingCount;
            if (instances.attribute(i).isNumeric()) {
                if (m_displayStdDevs) {
                    m_FullStdDevs[i] = Math.sqrt(instances.variance(i));
                }
                if (m_FullMissingCounts[i] == instances.numInstances()) {
                    m_FullMeansOrMediansOrModes[i] = Double.NaN;
                }
            } else {
                m_FullNominalCounts[i] = instances.attributeStats(i).nominalCounts;
                if (m_FullMissingCounts[i] > m_FullNominalCounts[i][Utils.maxIndex(m_FullNominalCounts[i])]) {
                    m_FullMeansOrMediansOrModes[i] = -1;
                }
            }
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        if (m_PreserveOrder) m_Assignments = clusterAssignments;
        m_DistanceFunction.setInstances(instances);
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTableHashKey hk = null;
        Instances initInstances = null;
        if (m_PreserveOrder) initInstances = new Instances(instances); else initInstances = instances;
        for (int j = initInstances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTableHashKey(initInstances.instance(instIndex), initInstances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(initInstances.instance(instIndex));
                initC.put(hk, null);
            }
            initInstances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        initInstances = null;
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        m_ClusterMissingCounts = new int[m_NumClusters][instances.numAttributes()];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    moveCentroid(i, tempI[i], true);
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                if (converged) {
                    Instances[] t = new Instances[m_NumClusters];
                    int index = 0;
                    for (int k = 0; k < tempI.length; k++) {
                        if (tempI[k].numInstances() > 0) {
                            t[index++] = tempI[k];
                        }
                    }
                    tempI = t;
                } else {
                    tempI = new Instances[m_NumClusters];
                }
            }
            if (m_Iterations == m_MaxIterations) converged = true;
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        if (m_displayStdDevs) {
            m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        }
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            if (m_displayStdDevs) {
                double[] vals2 = new double[instances.numAttributes()];
                for (int j = 0; j < instances.numAttributes(); j++) {
                    if (instances.attribute(j).isNumeric()) {
                        vals2[j] = Math.sqrt(tempI[i].variance(j));
                    } else {
                        vals2[j] = Instance.missingValue();
                    }
                }
                m_ClusterStdDevs.add(new Instance(1.0, vals2));
            }
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
",0
21625693,13,"    public void buildClusterer(Instances data) throws Exception {
        for (int i = 0; i < m_NumClusters; i++) {
            bucket[i] = new ArrayList<bucketInstance>();
        }
        bucketSize = (int) Math.ceil(data.numInstances() / (double) m_NumClusters);
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        m_ReplaceMissingFilter.setInputFormat(instances);
        instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        m_Min = new double[instances.numAttributes()];
        m_Max = new double[instances.numAttributes()];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_Min[i] = m_Max[i] = Double.NaN;
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        for (int i = 0; i < instances.numInstances(); i++) {
            updateMinMax(instances.instance(i));
        }
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTableHashKey hk = null;
        for (int j = instances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTableHashKey(instances.instance(instIndex), instances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(instances.instance(instIndex));
                initC.put(hk, null);
            }
            instances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        while (!converged) {
            for (int j = 0; j < m_NumClusters; j++) {
                bucket[j] = new ArrayList<bucketInstance>();
            }
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            if (m_Iterations > maxIterations) {
                converged = true;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                double[] vals = new double[instances.numAttributes()];
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    for (int j = 0; j < instances.numAttributes(); j++) {
                        vals[j] = tempI[i].meanOrMode(j);
                        m_ClusterNominalCounts[i][j] = tempI[i].attributeStats(j).nominalCounts;
                    }
                    m_ClusterCentroids.add(new DenseInstance(1.0, vals));
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                tempI = new Instances[m_NumClusters];
            }
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        for (int j = 0; j < m_NumClusters; j++) {
            bucket[j] = new ArrayList<bucketInstance>();
        }
        m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            double[] vals2 = new double[instances.numAttributes()];
            for (int j = 0; j < instances.numAttributes(); j++) {
                if (instances.attribute(j).isNumeric()) {
                    vals2[j] = Math.sqrt(tempI[i].variance(j));
                } else {
                    vals2[j] = Utils.missingValue();
                }
            }
            m_ClusterStdDevs.add(new DenseInstance(1.0, vals2));
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
",1
10969249,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
2988615,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
6036290,13,"    public static String getRandomDocId() throws XMLDBException {
        String randomDocId = """";
        Integer objNum = null;
        java.util.Random rand = new java.util.Random();
        int max = 1000;
        for (int i = 0; i < 3; i++) {
            objNum = rand.nextInt(max + 1);
        }
        if (null != objNum) {
            String xquery = ""xquery version \""1.0\"";"" + ""  let $col := collection('"" + forumDB + ""')["" + objNum + ""],"" + ""  $docName := item-at($col, 1)"" + ""  return replace(util:document-name($docName), \"".xml\"", \""\"")"";
            XQueryService service = (XQueryService) vobs.dbaccess.CollectionsManager.getService(rootDB, true, ""XQueryService"");
            ResourceSet result = service.query(xquery);
            if (result.getSize() > 0) {
                XMLResource resource = (XMLResource) result.getResource(0);
                randomDocId = resource.getContent().toString();
            }
        }
        return randomDocId;
    }
",1
16204711,13,"    private void addRandomApple() {
        Coordinate newCoord = null;
        boolean found = false;
        while (!found) {
            int newX = 1 + RNG.nextInt(mXTileCount - 2);
            int newY = 1 + RNG.nextInt(mYTileCount - 2);
            newCoord = new Coordinate(newX, newY);
            boolean collision = false;
            int snakelength = mSnakeTrail.size();
            for (int index = 0; index < snakelength; index++) {
                if (mSnakeTrail.get(index).equals(newCoord)) {
                    collision = true;
                }
            }
            found = !collision;
        }
        if (newCoord == null) {
            Log.e(TAG, ""Somehow ended up with a null newCoord!"");
        }
        mAppleList.add(newCoord);
    }
",1
1410386,13,"    public static String getRandomStr(char startChr, char endChr) {
        int randomInt;
        String randomStr = null;
        int startInt = Integer.valueOf(startChr);
        int endInt = Integer.valueOf(endChr);
        if (startInt > endInt) {
            throw new IllegalArgumentException(""Start String: "" + startChr + "" End String: "" + endChr);
        }
        try {
            SecureRandom rnd = new SecureRandom();
            do {
                randomInt = rnd.nextInt(endInt + 1);
            } while (randomInt < startInt);
            randomStr = (char) randomInt + """";
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return randomStr;
    }
",1
18088116,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
479568,13,"    public DSoCService() {
        Random rand = new Random();
        int RandNum = rand.nextInt(MAX_NUMBER_OF_SES + 1);
        NUMBER_OF_SES = (RandNum < 3) ? 3 : RandNum;
        hx_SES = new SES[NUMBER_OF_SES];
        sx_SES = new SES[NUMBER_OF_SES];
        NumberFormat nf = NumberFormat.getInstance();
        nf.setMinimumIntegerDigits(4);
        nf.setMaximumIntegerDigits(4);
        str_Name = ""Service"" + nf.format((long) NameSec);
        NameSec++;
        init_SESs();
    }
",1
14416348,13,"    void createArtificialROIs(int howMany) {
        int nCandidates = 2 * howMany;
        Vector<Rectangle> candidates = new Vector<Rectangle>();
        int maxX = imageDim.width - displayDim.width;
        int maxY = imageDim.height - displayDim.height;
        {
            int way = 0;
            if (way == 0) {
                for (int i = 0; i < nCandidates; i++) {
                    int x = rand.nextInt(maxX + 1);
                    int y = rand.nextInt(maxY + 1);
                    candidates.add(new Rectangle(new Point(x, y), displayDim));
                }
            } else if (way == 1) {
            }
        }
        {
            int way = 0;
            if (way == 0) {
                for (int i = 0; i < howMany; i++) {
                    Rectangle rect = candidates.remove(rand.nextInt(candidates.size()));
                    ROI roi = new ROI(rect.getLocation(), rect.getSize(), null);
                    roi.setStaticRelevance(ARTIFICIAL_RELEVANCE);
                    rois.add(roi);
                }
            } else if (way == 1) {
            }
        }
    }
",0
22697396,13,"    private static void resetLocalPRNG() {
        if (Configuration.DEBUG) log.entering(ICMRandomSpi.class.getName(), ""resetLocalPRNG"");
        HashMap attributes = new HashMap();
        attributes.put(ICMGenerator.CIPHER, Registry.AES_CIPHER);
        byte[] key = new byte[128 / 8];
        Random rand = new Random(System.currentTimeMillis());
        rand.nextBytes(key);
        attributes.put(IBlockCipher.KEY_MATERIAL, key);
        int aesBlockSize = 128 / 8;
        byte[] offset = new byte[aesBlockSize];
        rand.nextBytes(offset);
        attributes.put(ICMGenerator.OFFSET, offset);
        int ndxLen = 0;
        int limit = aesBlockSize / 2;
        while (ndxLen < 1 || ndxLen > limit) ndxLen = rand.nextInt(limit + 1);
        attributes.put(ICMGenerator.SEGMENT_INDEX_LENGTH, Integer.valueOf(ndxLen));
        byte[] index = new byte[ndxLen];
        rand.nextBytes(index);
        attributes.put(ICMGenerator.SEGMENT_INDEX, new BigInteger(1, index));
        prng.setup(attributes);
        if (Configuration.DEBUG) log.exiting(ICMRandomSpi.class.getName(), ""resetLocalPRNG"");
    }
",1
4987113,13,"    private static Color _GetRandColor(int fc, int bc) {
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
9708819,13,"    private Odds computeFlop(int flops, long holes, int activeOpponents, Card cards[], MersenneTwisterFast rand) {
        Odds odds = new Odds();
        if (flops >= 1081) {
            int unknownCount = 52 - 2 - 3;
            FastIntCombiner fc = new FastIntCombiner(Card.INDEXES, unknownCount);
            TurnCommunityVisitor turn = new TurnCommunityVisitor(activeOpponents, cards, holes, rand);
            fc.combine(turn);
            odds = turn.odds();
        } else {
            for (int i = 0; i < flops; i++) {
                int xComD = rand.nextInt(COM_D + 1);
                swap(cards, xComD, COM_D);
                int xComE = rand.nextInt(COM_E + 1);
                swap(cards, xComE, COM_E);
                odds = odds.plus(computeOppOdds(activeOpponents, cards, holes, rand));
                swap(cards, xComE, COM_E);
                swap(cards, xComD, COM_D);
            }
        }
        return odds;
    }
",1
6476018,13,"    public List<Regla> planificar(IBaseConocimientos bc) {
        List<Regla> reglas = bc.getReglas();
        Collections.sort(reglas);
        Collection<Sensor> estado = bc.getEstadoActual();
        DefaultMutableTreeNode nodo = null;
        Iterator i = reglas.iterator();
        while (i.hasNext() && nodo == null) {
            Regla regla = (Regla) i.next();
            DefaultMutableTreeNode root = armarArbol(regla.getPredicciones(), reglas);
            nodo = buscarNodo(root, estado);
        }
        if (nodo == null) {
            List<Regla> plan = new ArrayList<Regla>();
            int count = reglas.size();
            Random r = new Random();
            int number = r.nextInt(count + 1);
            Regla regla = reglas.get(number);
            plan.add(regla);
            return plan;
        } else {
            return armarCamino(nodo, reglas);
        }
    }
",1
13281621,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
10829219,13,"    public Object newValue(Random random) {
        if (random.nextBoolean()) {
            return null;
        }
        StringBuilder strBuilder = new StringBuilder();
        int remainingLength = minLength + random.nextInt(maxLength - minLength);
        boolean endsWithPunctuation = random.nextBoolean();
        if (endsWithPunctuation) {
            remainingLength--;
        }
        String word = getWord(remainingLength, random);
        strBuilder.append(word);
        remainingLength -= word.length();
        while (remainingLength > 1) {
            strBuilder.append(getChar(midPunctuation, random));
            remainingLength--;
            word = getWord(remainingLength, random);
            strBuilder.append(word);
            remainingLength -= word.length();
        }
        if (endsWithPunctuation) {
            strBuilder.append(getChar(endPunctuation, random));
        }
        return strBuilder.toString();
    }
",1
5805315,13,"    @Override
    public void mutate(PermutationGenotype<?> genotype, double p) {
        int size = genotype.size();
        if (size > 1) {
            for (int a = 0; a < size - 1; a++) {
                if (random.nextDouble() < p) {
                    int b;
                    do {
                        b = a + random.nextInt(size - a);
                    } while (b == a);
                    while (a < b) {
                        Collections.swap(genotype, a, b);
                        a++;
                        b--;
                    }
                }
            }
        }
    }
",1
20387184,13,"    private void testListIterator(BitVector v) {
        int size = v.size();
        final BitVector w = new BitVector(size);
        ListIterator<Boolean> i = v.listIterator();
        while (i.hasNext()) {
            w.setBit(i.nextIndex(), i.next());
        }
        assertEquals(v, w);
        final BitVector x = new BitVector(size);
        i = v.listIterator(size);
        while (i.hasPrevious()) {
            x.setBit(i.previousIndex(), i.previous());
        }
        assertEquals(v, x);
        final int a = random.nextInt(size + 1);
        i = v.listIterator(a);
        if (a == size) {
            assertEquals(-1, i.nextIndex());
        } else {
            assertEquals(a, i.nextIndex());
            assertEquals(v.getBit(a), i.next().booleanValue());
        }
        i = v.listIterator(a);
        if (a == 0) {
            assertEquals(-1, i.previousIndex());
        } else {
            assertEquals(a - 1, i.previousIndex());
            assertEquals(v.getBit(a - 1), i.previous().booleanValue());
        }
    }
",1
14259881,13,"    private List<InetSocketAddressInfo> getPeerList(Hash fileId, Peer peer, int numNeighbors) {
        Map<InetSocketAddressInfo, Peer> peerMap = fileIdToPeerMap.get(fileId);
        int numSharers = peerMap.size();
        int missingNeighbors = ((int) Math.ceil(Math.log(numSharers))) + peerListAnswerConst - numNeighbors;
        List<InetSocketAddressInfo> peerListAnswer = new ArrayList<InetSocketAddressInfo>();
        if (peerMap == null) {
            return peerListAnswer;
        }
        Object[] peerList = peerMap.values().toArray();
        int lastPeer = peerList.length - 1;
        while (peerListAnswer.size() < missingNeighbors && lastPeer >= 0) {
            int randomPeer = random.nextInt(lastPeer + 1);
            Peer neighbor = (Peer) peerList[randomPeer];
            InetSocketAddressInfo address = neighbor.getAddress();
            if (!peer.neighbor(neighbor)) {
                peer.addNeighbor(neighbor);
                neighbor.addNeighbor(peer);
                peerListAnswer.add(neighbor.getAddress());
            }
            peerList[randomPeer] = peerList[lastPeer];
            peerList[lastPeer] = neighbor;
            lastPeer--;
        }
        return peerListAnswer;
    }
",1
18515074,13,"    public void buildClusterer(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        m_Iterations = 0;
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        m_ReplaceMissingFilter.setInputFormat(instances);
        instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        m_Min = new double[instances.numAttributes()];
        m_Max = new double[instances.numAttributes()];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_Min[i] = m_Max[i] = Double.NaN;
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        for (int i = 0; i < instances.numInstances(); i++) {
            updateMinMax(instances.instance(i));
        }
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTable.hashKey hk = null;
        for (int j = instances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTable.hashKey(instances.instance(instIndex), instances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(instances.instance(instIndex));
                initC.put(hk, null);
            }
            instances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                double[] vals = new double[instances.numAttributes()];
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    for (int j = 0; j < instances.numAttributes(); j++) {
                        vals[j] = tempI[i].meanOrMode(j);
                        m_ClusterNominalCounts[i][j] = tempI[i].attributeStats(j).nominalCounts;
                    }
                    m_ClusterCentroids.add(new Instance(1.0, vals));
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                tempI = new Instances[m_NumClusters];
            }
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            double[] vals2 = new double[instances.numAttributes()];
            for (int j = 0; j < instances.numAttributes(); j++) {
                if (instances.attribute(j).isNumeric()) {
                    vals2[j] = Math.sqrt(tempI[i].variance(j));
                } else {
                    vals2[j] = Instance.missingValue();
                }
            }
            m_ClusterStdDevs.add(new Instance(1.0, vals2));
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
",1
23128478,13,"    public static InetSocketAddress getNewInetSocketAddressWithRandomPort(InetAddress addr) {
        int portNum = 1024 + random.nextInt(65535 - 1024);
        InetSocketAddress localAddr = new InetSocketAddress(addr, portNum);
        return localAddr;
    }
",1
10856256,13,"    public void testQueue() {
        FastPriorityQueueLong queue = new FastPriorityQueueLong(MAX_DISTANCE, TOP);
        List<OBResultInvertedInt<Long>> result = new ArrayList<OBResultInvertedInt<Long>>(TOTAL);
        int[] counts = new int[MAX_DISTANCE + 1];
        Random r = new Random();
        int i = 0;
        while (i < TOTAL) {
            int distance = r.nextInt(MAX_DISTANCE + 1);
            queue.add(distance, distance);
            result.add(new OBResultInvertedInt(distance, distance, distance));
            i++;
        }
        Collections.sort(result);
        Iterator<OBResultInvertedInt<Long>> it = result.iterator();
        i = 0;
        long[] data = queue.get();
        for (long l : data) {
            if (i >= TOP) {
                break;
            }
            OBResultInvertedInt<Long> e = it.next();
            assertTrue(""Found: "" + e.getDistance() + "" but fast got: "" + l, e.getDistance() == l);
            i++;
        }
    }
",1
17624942,13,"        public Layer(int num, ALayer pl, int inputs_per_neuron) {
            prevLayer = pl;
            index = num;
            ANeuron[] copyN;
            ANeuron[] inputsChoosen = new ANeuron[inputs_per_neuron];
            prevLayer = pl;
            ALayer aLayer;
            ANeuron choosen;
            Neuron berle = new Neuron();
            layerProgress = 0;
            boolean tryAgain;
            inputsToNeuron = inputs_per_neuron;
            number = c.getLayerNeuronsNumber(num);
            inumber = c.getLayerInitialNeuronsNumber(num);
            if (number > inumber) {
                number = inumber;
            }
            int actInput, golayer, which, s;
            berle.init(ja, inputsChoosen, inputs_per_neuron);
            mode = PASSIVE;
            prevLayer.computeOutputs();
            for (int i = 0; i < inumber; i++) {
                copyN = prevLayer.getRandomNeurons(2);
                inputsChoosen[0] = copyN[0];
                inputsChoosen[1] = copyN[1];
                actInput = 2;
                while (actInput < inputs_per_neuron) {
                    do {
                        aLayer = prevLayer;
                        switch(c.getParents()) {
                            case NetworkConfiguration.YOUNG:
                                if (actInput >= aLayer.getNumber()) {
                                    aLayer = aLayer.getPreviousLayer();
                                }
                                break;
                            case NetworkConfiguration.YOUNGER:
                                for (int j = s = 0; j < num + 1; j++) {
                                    s += (j + 1);
                                }
                                s = myRandom.nextInt(s + 1) - num - 1;
                                for (int j = num; s > 0; s -= j--) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.MIDDLE:
                                s = myRandom.nextInt(num + 1);
                                for (int j = 0; j < s; j++) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.OLDER:
                                for (int j = s = 0; j < num + 1; j++) {
                                    s += (j + 1);
                                }
                                s = myRandom.nextInt(s + 1) - num - 1;
                                for (int j = num; s > 0; s -= (num - (--j))) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.OLD:
                                if (actInput >= aLayer.getNumber()) {
                                    while ((aLayer.getPreviousLayer() != null) && (aLayer.getPreviousLayer().getPreviousLayer() != null)) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                } else {
                                    while ((aLayer != null) && (aLayer.getPreviousLayer() != null)) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                        }
                        choosen = aLayer.getNeuron(myRandom.nextInt(aLayer.getNumber()));
                        tryAgain = false;
                        for (int j = 0; j < actInput; j++) {
                            if (inputsChoosen[j].equals(choosen)) {
                                tryAgain = true;
                            }
                        }
                    } while (tryAgain);
                    inputsChoosen[actInput] = choosen;
                    actInput++;
                }
                do {
                    which = myRandom.nextInt(u.getNeuronsNumber());
                } while (!c.neuronTypeAllowed(which));
                int train;
                do {
                    train = myRandom.nextInt(u.getTrainersNumber());
                } while (!GlobalConfig.getInstance().getGac().neuronTrainerAllowed(train));
                try {
                    n[i] = (Neuron) u.getNeuronClass(which).newInstance();
                    n[i].init(ja, inputsChoosen, inputs_per_neuron, u.getNeuronConfig(which));
                    Trainer tt = (Trainer) u.getTrainerClass(train).newInstance();
                    tt.init(n[i], tt, n[i].getCoefsNumber());
                    n[i].setTrainer(tt);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    i--;
                } catch (InstantiationException e) {
                    e.printStackTrace();
                    i--;
                }
            }
            mode = ACTIVE;
        }
",0
15294077,13,"    private static Color getRandColor(int min, int max) {
        if (min > 255) {
            min = 255;
        }
        if (max > 255) {
            max = 255;
        }
        Random random = new Random();
        int r = min + random.nextInt(max - min);
        int g = min + random.nextInt(max - min);
        int b = min + random.nextInt(max - min);
        return new Color(r, g, b);
    }
",0
4409384,13,"        public static <T> int randomizedPartition(T[] array, int startIndex, int endIndex, Comparator<T> comparator) {
            int i = startIndex + random.nextInt(endIndex - startIndex);
            swap(array, i, startIndex);
            return partition(array, startIndex, endIndex, comparator);
        }
",1
9414364,13,"    private static void testForSubSetRandomOperationsStress() {
        IntegerSet bits = new IntegerSet(new ConciseSet());
        IntegerSet bitsPrevious = new IntegerSet(new ConciseSet());
        TreeSet<Integer> items = new TreeSet<Integer>();
        Random rnd = new MersenneTwister();
        for (int i = 0; i < 100000; i++) {
            System.out.print(""Test "" + i + "": "");
            bitsPrevious = bits.clone();
            if (!bitsPrevious.toString().equals(bits.toString())) throw new RuntimeException(""clone() error!"");
            bits.clear();
            items.clear();
            final int size = 1 + rnd.nextInt(10000);
            final int min = 1 + rnd.nextInt(10000 - 1);
            final int max = min + rnd.nextInt(10000 - min + 1);
            final int minSub = 1 + rnd.nextInt(10000 - 1);
            final int maxSub = minSub + rnd.nextInt(10000 - minSub + 1);
            for (int j = 0; j < size; j++) {
                int item = min + rnd.nextInt(max - min + 1);
                bits.add(item);
                items.add(item);
            }
            SortedSet<Integer> bitsSubSet = bits.subSet(minSub, maxSub);
            SortedSet<Integer> itemsSubSet = items.subSet(minSub, maxSub);
            if (!bitsSubSet.toString().equals(itemsSubSet.toString())) {
                System.out.println(""toString() difference!"");
                System.out.println(""value: "" + bitsSubSet.toString());
                System.out.println(""actual: "" + itemsSubSet.toString());
                return;
            }
            if (bitsSubSet.size() != itemsSubSet.size()) {
                System.out.println(""size() difference!"");
                System.out.println(""value: "" + bitsSubSet.size());
                System.out.println(""actual: "" + itemsSubSet.size());
                System.out.println(""bits: "" + bits.toString());
                System.out.println(""items: "" + items.toString());
                System.out.println(""bitsSubSet: "" + bitsSubSet.toString());
                System.out.println(""itemsSubSet: "" + itemsSubSet.toString());
                return;
            }
            if (!itemsSubSet.isEmpty() && (!bitsSubSet.first().equals(itemsSubSet.first()))) {
                System.out.println(""first() difference!"");
                System.out.println(""value: "" + bitsSubSet.first());
                System.out.println(""actual: "" + itemsSubSet.first());
                System.out.println(""bits: "" + bits.toString());
                System.out.println(""items: "" + items.toString());
                System.out.println(""bitsSubSet: "" + bitsSubSet.toString());
                System.out.println(""itemsSubSet: "" + itemsSubSet.toString());
                return;
            }
            if (!itemsSubSet.isEmpty() && (!bitsSubSet.last().equals(itemsSubSet.last()))) {
                System.out.println(""last() difference!"");
                System.out.println(""value: "" + bitsSubSet.last());
                System.out.println(""actual: "" + itemsSubSet.last());
                System.out.println(""bits: "" + bits.toString());
                System.out.println(""items: "" + items.toString());
                System.out.println(""bitsSubSet: "" + bitsSubSet.toString());
                System.out.println(""itemsSubSet: "" + itemsSubSet.toString());
                return;
            }
            boolean resBits = false;
            boolean resItems = false;
            boolean exceptionBits = false;
            boolean exceptionItems = false;
            switch(1 + rnd.nextInt(4)) {
                case 1:
                    System.out.format("" addAll() of %d elements on %d elements... "", bitsPrevious.size(), bits.size());
                    try {
                        resBits = bitsSubSet.addAll(bitsPrevious);
                    } catch (Exception e) {
                        bits.clear();
                        System.out.print(""\n\tEXCEPTION on bitsSubSet: "" + e.getClass() + "" "");
                        exceptionBits = true;
                    }
                    try {
                        resItems = itemsSubSet.addAll(bitsPrevious);
                    } catch (Exception e) {
                        items.clear();
                        System.out.print(""\n\tEXCEPTION on itemsSubSet: "" + e.getClass() + "" "");
                        exceptionItems = true;
                    }
                    break;
                case 2:
                    System.out.format("" removeAll() of %d elements on %d elements... "", bitsPrevious.size(), bits.size());
                    try {
                        resBits = bitsSubSet.removeAll(bitsPrevious);
                    } catch (Exception e) {
                        bits.clear();
                        System.out.print(""\n\tEXCEPTION on bitsSubSet: "" + e.getClass() + "" "");
                        exceptionBits = true;
                    }
                    try {
                        resItems = itemsSubSet.removeAll(bitsPrevious);
                    } catch (Exception e) {
                        items.clear();
                        System.out.print(""\n\tEXCEPTION on itemsSubSet: "" + e.getClass() + "" "");
                        exceptionItems = true;
                    }
                    break;
                case 3:
                    System.out.format("" retainAll() of %d elements on %d elements... "", bitsPrevious.size(), bits.size());
                    try {
                        resBits = bitsSubSet.retainAll(bitsPrevious);
                    } catch (Exception e) {
                        bits.clear();
                        System.out.print(""\n\tEXCEPTION on bitsSubSet: "" + e.getClass() + "" "");
                        exceptionBits = true;
                    }
                    try {
                        resItems = itemsSubSet.retainAll(bitsPrevious);
                    } catch (Exception e) {
                        items.clear();
                        System.out.print(""\n\tEXCEPTION on itemsSubSet: "" + e.getClass() + "" "");
                        exceptionItems = true;
                    }
                    break;
                case 4:
                    System.out.format("" clear() of %d elements on %d elements... "", bitsPrevious.size(), bits.size());
                    try {
                        bitsSubSet.clear();
                    } catch (Exception e) {
                        bits.clear();
                        System.out.print(""\n\tEXCEPTION on bitsSubSet: "" + e.getClass() + "" "");
                        exceptionBits = true;
                    }
                    try {
                        itemsSubSet.clear();
                    } catch (Exception e) {
                        items.clear();
                        System.out.print(""\n\tEXCEPTION on itemsSubSet: "" + e.getClass() + "" "");
                        exceptionItems = true;
                    }
                    break;
            }
            if (exceptionBits != exceptionItems) {
                System.out.println(""Incorrect exception!"");
                return;
            }
            if (resBits != resItems) {
                System.out.println(""Incorrect results!"");
                System.out.println(""resBits: "" + resBits);
                System.out.println(""resItems: "" + resItems);
                return;
            }
            if (!checkContent(bits, items)) {
                System.out.println(""Subview not correct!"");
                System.out.format(""min: %d, max: %d, minSub: %d, maxSub: %d\n"", min, max, minSub, maxSub);
                System.out.println(""Same elements: "" + (items.toString().equals(bits.toString())));
                System.out.println(""Original: "" + items);
                System.out.println(bits.debugInfo());
                System.out.println(bitsPrevious.debugInfo());
                return;
            }
            IntegerSet otherBits = new IntegerSet(new ConciseSet());
            otherBits.addAll(items);
            if (otherBits.hashCode() != bits.hashCode()) {
                System.out.println(""Representation not correct!"");
                System.out.format(""min: %d, max: %d, minSub: %d, maxSub: %d\n"", min, max, minSub, maxSub);
                System.out.println(bits.debugInfo());
                System.out.println(otherBits.debugInfo());
                System.out.println(bitsPrevious.debugInfo());
                return;
            }
            System.out.println(""done."");
        }
    }
",1
14015068,13,"    public static void main(String[] args) {
        StatisticsManager.getInstance().startEvaluation(NUMBER_TRANSACTIONS);
        ClientStarter starter;
        int numberParticipants;
        Random randomGenerator = new Random();
        for (int i = 0; i < NUMBER_TRANSACTIONS; i++) {
            numberParticipants = randomGenerator.nextInt(NUMBER_PARTICIPANTS_MAX + 1);
            if (numberParticipants < NUMBER_PARTICIPANTS_MIN) {
                numberParticipants = NUMBER_PARTICIPANTS_MIN;
            }
            starter = new ClientStarter(i + 1, NUMBER_TRANSACTIONS, USE_ABSTRACTSERVICE, numberParticipants, COMPENSATION_FAILURE_PROBABILITY);
            starter.start();
            try {
                Thread.sleep(TIME_SLEEP);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
",1
10056156,13,"    public void buildClusterer(Instances data) throws Exception {
        m_Iterations = 0;
        if (data.checkForStringAttributes()) {
            throw new Exception(""Can't handle string attributes!"");
        }
        m_ReplaceMissingFilter = new ReplaceMissingValues();
        Instances instances = new Instances(data);
        instances.setClassIndex(-1);
        m_ReplaceMissingFilter.setInputFormat(instances);
        instances = Filter.useFilter(instances, m_ReplaceMissingFilter);
        m_Min = new double[instances.numAttributes()];
        m_Max = new double[instances.numAttributes()];
        for (int i = 0; i < instances.numAttributes(); i++) {
            m_Min[i] = m_Max[i] = Double.NaN;
        }
        m_ClusterCentroids = new Instances(instances, m_NumClusters);
        int[] clusterAssignments = new int[instances.numInstances()];
        for (int i = 0; i < instances.numInstances(); i++) {
            updateMinMax(instances.instance(i));
        }
        Random RandomO = new Random(m_Seed);
        int instIndex;
        HashMap initC = new HashMap();
        DecisionTable.hashKey hk = null;
        for (int j = instances.numInstances() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            hk = new DecisionTable.hashKey(instances.instance(instIndex), instances.numAttributes(), true);
            if (!initC.containsKey(hk)) {
                m_ClusterCentroids.add(instances.instance(instIndex));
                initC.put(hk, null);
            }
            instances.swap(j, instIndex);
            if (m_ClusterCentroids.numInstances() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.numInstances();
        int i;
        boolean converged = false;
        int emptyClusterCount;
        Instances[] tempI = new Instances[m_NumClusters];
        m_squaredErrors = new double[m_NumClusters];
        m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
        while (!converged) {
            emptyClusterCount = 0;
            m_Iterations++;
            converged = true;
            for (i = 0; i < instances.numInstances(); i++) {
                Instance toCluster = instances.instance(i);
                int newC = clusterProcessedInstance(toCluster, true);
                if (newC != clusterAssignments[i]) {
                    converged = false;
                }
                clusterAssignments[i] = newC;
            }
            m_ClusterCentroids = new Instances(instances, m_NumClusters);
            for (i = 0; i < m_NumClusters; i++) {
                tempI[i] = new Instances(instances, 0);
            }
            for (i = 0; i < instances.numInstances(); i++) {
                tempI[clusterAssignments[i]].add(instances.instance(i));
            }
            for (i = 0; i < m_NumClusters; i++) {
                float[] vals = new float[instances.numAttributes()];
                if (tempI[i].numInstances() == 0) {
                    emptyClusterCount++;
                } else {
                    for (int j = 0; j < instances.numAttributes(); j++) {
                        vals[j] = tempI[i].meanOrMode(j);
                        m_ClusterNominalCounts[i][j] = tempI[i].attributeStats(j).nominalCounts;
                    }
                    m_ClusterCentroids.add(new Instance((float) 1.0, vals));
                }
            }
            if (emptyClusterCount > 0) {
                m_NumClusters -= emptyClusterCount;
                tempI = new Instances[m_NumClusters];
            }
            if (!converged) {
                m_squaredErrors = new double[m_NumClusters];
                m_ClusterNominalCounts = new int[m_NumClusters][instances.numAttributes()][0];
            }
        }
        m_ClusterStdDevs = new Instances(instances, m_NumClusters);
        m_ClusterSizes = new int[m_NumClusters];
        for (i = 0; i < m_NumClusters; i++) {
            float[] vals2 = new float[instances.numAttributes()];
            for (int j = 0; j < instances.numAttributes(); j++) {
                if (instances.attribute(j).isNumeric()) {
                    vals2[j] = (float) Math.sqrt(tempI[i].variance(j));
                } else {
                    vals2[j] = Instance.missingValue();
                }
            }
            m_ClusterStdDevs.add(new Instance((float) 1.0, vals2));
            m_ClusterSizes[i] = tempI[i].numInstances();
        }
    }
",0
2655635,13,"    public static Color getRandColor(int fc, int bc) {
        fc = Math.min(fc, 255);
        bc = Math.min(bc, 255);
        final int r = fc + random.nextInt(bc - fc);
        final int g = fc + random.nextInt(bc - fc);
        final int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
802699,13,"    @Override
    void parseLine(String strLine) {
        String dest = strLine;
        int groupID = _randMemId.nextInt(_totNumOfTeams + 1);
        _missionID++;
        int month = _randDateMonth.nextInt(10);
        int day = _randDateDay.nextInt(26);
        String startDate = gerateDate(month, day);
        String endDate = gerateDate(month + 1, day + 1);
        _cols.clear();
        _vals.clear();
        _cols.add(""MissionID"");
        _cols.add(""GroupID"");
        _cols.add(""StartDate"");
        _cols.add(""EndDate"");
        _cols.add(""Location"");
        _cols.add(""State"");
        _vals.add(""'"" + _missionID + ""'"");
        _vals.add(""'"" + groupID + ""'"");
        _vals.add(""'"" + startDate + ""'"");
        _vals.add(""'"" + endDate + ""'"");
        _vals.add(""'"" + dest + ""'"");
        _vals.add(""'"" + ""NA"" + ""'"");
        genSQLInsertForTable(""missions"", _cols, _vals);
    }
",1
10048471,13,"    private TravellerChromosome algorithm(TravellerChromosome f, TravellerChromosome m) {
        MersenneTwister mt = MersenneTwister.getTwister();
        int genomeLength = f.getNumCities();
        f.canonicalize();
        m.canonicalize();
        TravellerChromosome fatherOffspring = new TravellerChromosome(f);
        TravellerChromosome motherOffspring = new TravellerChromosome(m);
        fatherOffspring.invalidateCities();
        motherOffspring.invalidateCities();
        int segmentLength = 2 + mt.nextInt(genomeLength - 3);
        int fatherStart = mt.nextInt(genomeLength);
        int motherOffset = mt.nextInt(genomeLength);
        boolean reverseMother = mt.nextBoolean();
        int mcx_to = 0;
        int fcx_to = 0;
        int mcx_from = 0;
        int fcx_from = 0;
        int mcnx = segmentLength;
        int fcnx = segmentLength;
        for (int i = 0; i < genomeLength; i++) {
            int fatherCity = f.getCity(i + fatherStart);
            int motherCity = m.getCity(i, motherOffset + fatherStart, reverseMother);
            int fatherCityIndexInMother = m.findCity(fatherCity, motherOffset, reverseMother);
            int motherCityIndexInFather = f.findCity(motherCity);
            if (m.indexIsInSegment(fatherCityIndexInMother, fatherStart, segmentLength, motherOffset, reverseMother)) {
                fatherOffspring.setCity(fcx_to, m.getCity(mcx_from, motherOffset + fatherStart, reverseMother));
                fcx_to++;
                mcx_from++;
            } else {
                fatherOffspring.setCity(fcnx, fatherCity);
                fcnx++;
            }
            if (f.indexIsInSegment(motherCityIndexInFather, fatherStart, segmentLength, 0, false)) {
                motherOffspring.setCity(mcx_to, f.getCity(fcx_from + fatherStart));
                mcx_to++;
                fcx_from++;
            } else {
                motherOffspring.setCity(mcnx, motherCity);
                mcnx++;
            }
        }
        TravellerChromosome child = null;
        if ((Population.areMinimizing() && (motherOffspring.testFitness() < fatherOffspring.testFitness())) || ((!Population.areMinimizing()) && (motherOffspring.testFitness() > fatherOffspring.testFitness()))) {
            child = motherOffspring;
        } else {
            child = fatherOffspring;
        }
        return child;
    }
",1
6416636,13,"    private void generateClassifierForNode(Instances data, Range classes, Random rand, Classifier classifier, Hashtable table, double[] instsNumAllClasses) throws Exception {
        int[] indices = classes.getSelection();
        for (int j = indices.length - 1; j > 0; j--) {
            int randPos = rand.nextInt(j + 1);
            int temp = indices[randPos];
            indices[randPos] = indices[j];
            indices[j] = temp;
        }
        double total = 0;
        for (int j = 0; j < indices.length; j++) {
            total += instsNumAllClasses[indices[j]];
        }
        double halfOfTotal = total / 2;
        double sumLeft = 0, sumRight = 0;
        int i = 0, j = indices.length - 1;
        do {
            if (i == j) {
                if (rand.nextBoolean()) {
                    sumLeft += instsNumAllClasses[indices[i++]];
                } else {
                    sumRight += instsNumAllClasses[indices[j--]];
                }
            } else {
                sumLeft += instsNumAllClasses[indices[i++]];
                sumRight += instsNumAllClasses[indices[j--]];
            }
        } while (Utils.sm(sumLeft, halfOfTotal) && Utils.sm(sumRight, halfOfTotal));
        int first = 0, second = 0;
        if (!Utils.sm(sumLeft, halfOfTotal)) {
            first = i;
        } else {
            first = j + 1;
        }
        second = indices.length - first;
        int[] firstInds = new int[first];
        int[] secondInds = new int[second];
        System.arraycopy(indices, 0, firstInds, 0, first);
        System.arraycopy(indices, first, secondInds, 0, second);
        int[] sortedFirst = Utils.sort(firstInds);
        int[] sortedSecond = Utils.sort(secondInds);
        int[] firstCopy = new int[first];
        int[] secondCopy = new int[second];
        for (int k = 0; k < sortedFirst.length; k++) {
            firstCopy[k] = firstInds[sortedFirst[k]];
        }
        firstInds = firstCopy;
        for (int k = 0; k < sortedSecond.length; k++) {
            secondCopy[k] = secondInds[sortedSecond[k]];
        }
        secondInds = secondCopy;
        if (firstInds[0] > secondInds[0]) {
            int[] help = secondInds;
            secondInds = firstInds;
            firstInds = help;
            int help2 = second;
            second = first;
            first = help2;
        }
        m_Range = new Range(Range.indicesToRangeList(firstInds));
        m_Range.setUpper(data.numClasses() - 1);
        Range secondRange = new Range(Range.indicesToRangeList(secondInds));
        secondRange.setUpper(data.numClasses() - 1);
        MakeIndicator filter = new MakeIndicator();
        filter.setAttributeIndex("""" + (data.classIndex() + 1));
        filter.setValueIndices(m_Range.getRanges());
        filter.setNumeric(false);
        filter.setInputFormat(data);
        m_FilteredClassifier = new FilteredClassifier();
        if (data.numInstances() > 0) {
            m_FilteredClassifier.setClassifier(Classifier.makeCopies(classifier, 1)[0]);
        } else {
            m_FilteredClassifier.setClassifier(new weka.classifiers.rules.ZeroR());
        }
        m_FilteredClassifier.setFilter(filter);
        m_classifiers = table;
        if (!m_classifiers.containsKey(getString(firstInds) + ""|"" + getString(secondInds))) {
            m_FilteredClassifier.buildClassifier(data);
            m_classifiers.put(getString(firstInds) + ""|"" + getString(secondInds), m_FilteredClassifier);
        } else {
            m_FilteredClassifier = (FilteredClassifier) m_classifiers.get(getString(firstInds) + ""|"" + getString(secondInds));
        }
        m_FirstSuccessor = new DataNearBalancedND();
        if (first == 1) {
            m_FirstSuccessor.m_Range = m_Range;
        } else {
            RemoveWithValues rwv = new RemoveWithValues();
            rwv.setInvertSelection(true);
            rwv.setNominalIndices(m_Range.getRanges());
            rwv.setAttributeIndex("""" + (data.classIndex() + 1));
            rwv.setInputFormat(data);
            Instances firstSubset = Filter.useFilter(data, rwv);
            m_FirstSuccessor.generateClassifierForNode(firstSubset, m_Range, rand, classifier, m_classifiers, instsNumAllClasses);
        }
        m_SecondSuccessor = new DataNearBalancedND();
        if (second == 1) {
            m_SecondSuccessor.m_Range = secondRange;
        } else {
            RemoveWithValues rwv = new RemoveWithValues();
            rwv.setInvertSelection(true);
            rwv.setNominalIndices(secondRange.getRanges());
            rwv.setAttributeIndex("""" + (data.classIndex() + 1));
            rwv.setInputFormat(data);
            Instances secondSubset = Filter.useFilter(data, rwv);
            m_SecondSuccessor = new DataNearBalancedND();
            m_SecondSuccessor.generateClassifierForNode(secondSubset, secondRange, rand, classifier, m_classifiers, instsNumAllClasses);
        }
    }
",1
12750603,13,"    protected void startKeepAliveTimer() {
        keep_alive_ticks = MIN_KEEPALIVE_TICKS + random.nextInt(MAX_KEEPALIVE_TICKS - MIN_KEEPALIVE_TICKS);
    }
",1
9414369,13,"    private static void testForSkip(Class<? extends ExtendedSet<Integer>> c) {
        ExtendedSet<Integer> bits = empty(c);
        Random rnd = new MersenneTwister(31);
        for (int i = 0; i < 10000; i++) {
            int max = rnd.nextInt(10000);
            bits = bits.convert(new RandomNumbers.Uniform(rnd.nextInt(1000), rnd.nextDouble() * 0.999, rnd.nextInt(100)).generate());
            for (int j = 0; j < 100; j++) {
                int skip = rnd.nextInt(max + 1);
                boolean reverse = rnd.nextBoolean();
                System.out.format(""%d) size=%d, skip=%d, reverse=%b ---> "", (i * 100) + j + 1, bits.size(), skip, reverse);
                ExtendedIterator<Integer> itr1, itr2;
                if (!reverse) {
                    itr1 = bits.iterator();
                    itr2 = bits.iterator();
                    while (itr1.hasNext() && itr1.next() < skip) {
                    }
                } else {
                    itr1 = bits.descendingIterator();
                    itr2 = bits.descendingIterator();
                    while (itr1.hasNext() && itr1.next() > skip) {
                    }
                }
                if (!itr1.hasNext()) {
                    System.out.println(""Skipped!"");
                    continue;
                }
                itr2.skipAllBefore(skip);
                itr2.next();
                Integer i1, i2;
                if (!(i1 = itr1.next()).equals(i2 = itr2.next())) {
                    System.out.println(""Error!"");
                    System.out.println(""i1 = "" + i1);
                    System.out.println(""i2 = "" + i2);
                    System.out.println(bits.debugInfo());
                    return;
                }
                System.out.println(""OK!"");
            }
        }
        System.out.println(""Done!"");
    }
",1
3475974,13,"    private void addRandomApple() {
        Coordinate newCoord = null;
        boolean found = false;
        while (!found) {
            int newX = 1 + RNG.nextInt(mXTileCount - 2);
            int newY = 1 + RNG.nextInt(mYTileCount - 2);
            newCoord = new Coordinate(newX, newY);
            boolean collision = false;
            int snakelength = mSnakeTrail.size();
            for (int index = 0; index < snakelength; index++) {
                if (mSnakeTrail.get(index).equals(newCoord)) {
                    collision = true;
                }
            }
            found = !collision;
        }
        if (newCoord == null) {
            Log.e(TAG, ""Somehow ended up with a null newCoord!"");
        }
        mAppleList.add(newCoord);
    }
",1
7231842,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
21561478,13,"    public void mutate(Permutation tomutate, int sl) {
        if (len == 2) tomutate.swap(0, 1);
        int from = rand.nextInt(len);
        int subsegmentlength = -1;
        if (sl == -1) subsegmentlength = 2 + rand.nextInt(len - 2); else {
            if (sl < 2) subsegmentlength = 2; else if (sl >= len) subsegmentlength = sl - 1; else subsegmentlength = sl;
        }
        int to = (from + subsegmentlength) % len;
        int elems;
        if (from < to) elems = to - from + 1; else elems = to + len - from + 1;
        int cut = (from + 1 + rand.nextInt(elems - 2)) % len;
        tomutate.invert(from, cut);
        tomutate.invert((cut + 1) % len, to);
    }
",1
16914987,13,"    private static String getLikeDescription(int likeLow, int likeHigh) {
        int passnum = likeLow;
        if (likeHigh != -1) {
            passnum = likeLow + random.nextInt(likeHigh - likeLow);
        }
        return getPassenger(passnum).getDescription();
    }
",1
7106275,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
9708818,13,"    private Odds computePreflop(int flops, long holes, int activeOpponents, Card cards[], MersenneTwisterFast rand) {
        Odds odds = new Odds();
        for (int i = 0; i < flops; i++) {
            int xComA = rand.nextInt(COM_A + 1);
            swap(cards, xComA, COM_A);
            int xComB = rand.nextInt(COM_B + 1);
            swap(cards, xComB, COM_B);
            int xComC = rand.nextInt(COM_C + 1);
            swap(cards, xComC, COM_C);
            int xComD = rand.nextInt(COM_D + 1);
            swap(cards, xComD, COM_D);
            int xComE = rand.nextInt(COM_E + 1);
            swap(cards, xComE, COM_E);
            odds = odds.plus(computeOppOdds(activeOpponents, cards, holes, rand));
            swap(cards, xComE, COM_E);
            swap(cards, xComD, COM_D);
            swap(cards, xComC, COM_C);
            swap(cards, xComB, COM_B);
            swap(cards, xComA, COM_A);
        }
        return odds;
    }
",1
20027640,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
18758340,13,"    private FramedMessage createFramedMessage(int headerLength) throws IOException {
        int MAX = (int) Math.pow(2, 8 * headerLength) - 1;
        System.out.println(""MAX = "" + MAX);
        final int MESSAGE_LENGTH = random.nextInt(MAX + 1);
        System.out.println(""MESSAGE_LENGTH = "" + MESSAGE_LENGTH + "" Byte"");
        return createFramedMessage(headerLength, MESSAGE_LENGTH);
    }
",1
6353292,13,"    private Color getRandColor(int fc, int bc) {
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
15066658,13,"    public void crossOver(Object ao, Object bo, Object a1o, Object b1o) {
        Gene a = (Gene) ao;
        Gene b = (Gene) bo;
        Gene a1 = (Gene) a1o;
        Gene b1 = (Gene) b1o;
        int point = MyRandom.nextInt(bitsPerGene + 1);
        for (int j = 0; j < bitsPerGene; j++) {
            if (j < point) {
                a1.bits[j] = a.bits[j];
                b1.bits[j] = b.bits[j];
            } else {
                a1.bits[j] = b.bits[j];
                b1.bits[j] = a.bits[j];
            }
        }
    }
",1
17498236,13,"    public boolean batchFinished() throws Exception {
        Instances data = getInputFormat();
        if (data == null) throw new IllegalStateException(""No input instance format defined"");
        if (m_Converter == null) {
            int[] randomIndices = new int[m_ClassCounts.length];
            for (int i = 0; i < randomIndices.length; i++) {
                randomIndices[i] = i;
            }
            for (int j = randomIndices.length - 1; j > 0; j--) {
                int toSwap = m_Random.nextInt(j + 1);
                int tmpIndex = randomIndices[j];
                randomIndices[j] = randomIndices[toSwap];
                randomIndices[toSwap] = tmpIndex;
            }
            double[] randomizedCounts = new double[m_ClassCounts.length];
            for (int i = 0; i < randomizedCounts.length; i++) {
                randomizedCounts[i] = m_ClassCounts[randomIndices[i]];
            }
            if (m_ClassOrder == RANDOM) {
                m_Converter = randomIndices;
                m_ClassCounts = randomizedCounts;
            } else {
                int[] sorted = Utils.sort(randomizedCounts);
                m_Converter = new int[sorted.length];
                if (m_ClassOrder == FREQ_ASCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[i]];
                    }
                } else if (m_ClassOrder == FREQ_DESCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[sorted.length - i - 1]];
                    }
                } else {
                    throw new IllegalArgumentException(""Class order not defined!"");
                }
                double[] tmp2 = new double[m_ClassCounts.length];
                for (int i = 0; i < m_Converter.length; i++) {
                    tmp2[i] = m_ClassCounts[m_Converter[i]];
                }
                m_ClassCounts = tmp2;
            }
            FastVector values = new FastVector(data.classAttribute().numValues());
            for (int i = 0; i < data.numClasses(); i++) {
                values.addElement(data.classAttribute().value(m_Converter[i]));
            }
            FastVector newVec = new FastVector(data.numAttributes());
            for (int i = 0; i < data.numAttributes(); i++) {
                if (i == data.classIndex()) {
                    newVec.addElement(new Attribute(data.classAttribute().name(), values, data.classAttribute().getMetadata()));
                } else {
                    newVec.addElement(data.attribute(i));
                }
            }
            Instances newInsts = new Instances(data.relationName(), newVec, 0);
            newInsts.setClassIndex(data.classIndex());
            setOutputFormat(newInsts);
            int[] temp = new int[m_Converter.length];
            for (int i = 0; i < temp.length; i++) {
                temp[m_Converter[i]] = i;
            }
            m_Converter = temp;
            for (int xyz = 0; xyz < data.numInstances(); xyz++) {
                Instance datum = data.instance(xyz);
                if (!datum.isMissing(datum.classIndex())) {
                    datum.setClassValue((double) m_Converter[(int) datum.classValue()]);
                }
                push(datum);
            }
        }
        flushInput();
        m_NewBatch = true;
        return (numPendingOutput() != 0);
    }
",0
11866074,13,"    public int computerMove(IProgressMonitor progMonitor) {
        if (gameOver()) {
            return (whoWon);
        }
        if (!computerTurn) return (INVALID_MOVE);
        int maxScore = -322000;
        int bestPlay = -1;
        if (!firstMove && level != 0) {
            try {
                for (int col = 0; col <= COL_MAX; col++) {
                    if (validMove(col)) {
                        int[] testBoard = copyBoard(gameState);
                        int score = 0;
                        score = calculateComputerChances(col, testBoard, level == 1 ? 2 : MAX_LEVEL);
                        progMonitor.worked(col);
                        if (score > maxScore && makeMove(COMPUTER_PIECE, col, gameState) != -1) {
                            removePiece(col, gameState);
                            maxScore = score;
                            bestPlay = col;
                        }
                    }
                }
            } catch (Exception ex) {
                System.out.println(""Problem:"" + ex);
            }
        } else {
            firstMove = false;
        }
        int row, col;
        if (bestPlay != -1) {
            col = bestPlay;
            row = makeMove(COMPUTER_PIECE, bestPlay, gameState);
        } else {
            Random rand = new Random();
            col = rand.nextInt(COL_MAX + 1);
            while ((row = makeMove(COMPUTER_PIECE, col, gameState)) == -1) {
                col = rand.nextInt(COL_MAX + 1);
            }
        }
        lastRow = row;
        lastCol = col;
        if (checkForWin(COMPUTER_PIECE, gameState) == COMPUTER_WIN) {
            gameOver = true;
            whoWon = COMPUTER_WIN;
            return (COMPUTER_WIN);
        }
        computerTurn = false;
        if (gameOver()) return (whoWon); else return (NO_WINYET);
    }
",1
4042116,13,"    public void doSomethingElse() {
        if (!this.isRegisteredAtCoordinator()) {
            try {
                this.registerAtCoordinator();
            } catch (ParticipantException e) {
                System.out.println(""SharedParticipantService exception: "" + e.getLocalizedMessage());
            }
        }
        Random randomGenerator = new Random();
        int r = randomGenerator.nextInt(PROCESSINGTIME_MAX + 1);
        long sleepTimeMilli = 1000;
        if (r < PROCESSINGTIME_MIN) {
            sleepTimeMilli *= PROCESSINGTIME_MIN;
        } else {
            sleepTimeMilli *= r;
        }
        try {
            Thread.sleep(sleepTimeMilli);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        StatisticsManager.getInstance().addFinishedService(true);
    }
",1
914783,13,"    private InputStream dataInStreamCommand(String cmd) {
        InputStream dataStream;
        if (passiveMode) {
            printCommand(""PASV"");
            waitForResult();
            getLastResult();
            int[] i = parsePassiveParentheses((String) lastlines.get(lastlines.size() - 1));
            String datahost = i[0] + ""."" + i[1] + ""."" + i[2] + ""."" + i[3];
            int dataport = (i[4] * 256) + i[5];
            try {
                dataPassiveConnection = new FTPPassiveConnection(datahost, dataport);
                dataStream = dataPassiveConnection.getIn();
            } catch (IOException e) {
                System.out.println(e);
                return null;
            }
            printCommand(cmd);
            waitForResult();
            getLastResult();
        } else {
            int port = portrange_lower + random.nextInt(portrange_upper - portrange_lower);
            System.out.println(""port "" + port);
            try {
                dataPortConnection = new FTPPortConnection(port);
            } catch (IOException e) {
                System.out.println(e);
                return null;
            }
            printCommand(""PORT "" + localip + "","" + port2ascii(port));
            waitForResult();
            getLastResult();
            printCommand(cmd);
            waitForResult();
            getLastResult();
            try {
                dataPortConnection.waitForConnection();
            } catch (InterruptedException e) {
                System.out.println(""Interrupted in join(): "" + e);
            }
            try {
                dataStream = dataPortConnection.getIn();
            } catch (IOException e) {
                System.out.println(""Can not establish connection :"" + e);
                return null;
            }
        }
        return dataStream;
    }
",1
479570,13,"    public DSoCService(int MaximumNumberOfSegmentation, String ServiceName) {
        MAX_NUMBER_OF_SES = MaximumNumberOfSegmentation;
        Random rand = new Random();
        int RandNum = rand.nextInt(MAX_NUMBER_OF_SES + 1);
        NUMBER_OF_SES = (RandNum < 3) ? 3 : RandNum;
        hx_SES = new SES[NUMBER_OF_SES];
        sx_SES = new SES[NUMBER_OF_SES];
        str_Name = ServiceName;
        init_SESs();
    }
",1
23303673,13,"    protected void doSingle(int maxSize) {
        int sz = rand.nextInt(maxSize + 1);
        int sz2 = rand.nextInt(maxSize);
        OpenBitSet bs1 = getRandomSet(sz, rand.nextInt(sz + 1));
        OpenBitSet bs2 = getRandomSet(sz, rand.nextInt(sz2 + 1));
        DocSet a1 = new BitDocSet(bs1);
        DocSet a2 = new BitDocSet(bs2);
        DocSet b1 = getDocSet(bs1);
        DocSet b2 = getDocSet(bs2);
        checkEqual(bs1, b1);
        checkEqual(bs2, b2);
        iter(a1, b1);
        iter(a2, b2);
        OpenBitSet a_and = (OpenBitSet) bs1.clone();
        a_and.and(bs2);
        OpenBitSet a_or = (OpenBitSet) bs1.clone();
        a_or.or(bs2);
        OpenBitSet a_andn = (OpenBitSet) bs1.clone();
        a_andn.andNot(bs2);
        checkEqual(a_and, b1.intersection(b2));
        checkEqual(a_or, b1.union(b2));
        checkEqual(a_andn, b1.andNot(b2));
        assertEquals(a_and.cardinality(), b1.intersectionSize(b2));
        assertEquals(a_or.cardinality(), b1.unionSize(b2));
        assertEquals(a_andn.cardinality(), b1.andNotSize(b2));
    }
",1
4243051,13,"    @Override
    public IGenome mutate(IGenome genome) {
        double mutationRate = getMutationRate();
        if (s_rnd.nextDouble() < mutationRate) {
            int maxDelta = Math.abs(getMaxDelta());
            int delta = s_rnd.nextInt(maxDelta + 1);
            if (delta == 0) {
                return genome;
            }
            if (s_rnd.nextBoolean()) {
                delta = -delta;
            }
            List<IGene> genes = genome.getGenes();
            if (delta % genes.size() == 0) {
                return genome;
            }
            List<IGene> childGenes = Collections.synchronizedList(new ArrayList<IGene>(genes));
            Collections.rotate(childGenes, delta);
            IGenome childGenome = genome.createClone(true);
            childGenome.setGenes(childGenes);
            if (s_log.isDebugEnabled()) {
                s_log.debug(""[MUTATE]  Shifted "" + genome + "" ["" + delta + ""] --> "" + childGenome);
            }
            return childGenome;
        } else {
            return genome;
        }
    }
",0
18357814,13,"        void reset(Random random) {
            rfqAverageNumber = rfqAvgMin + random.nextInt(rfqAvgMax - rfqAvgMin);
        }
",1
21977662,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
10163526,13,"    public void testForward() throws IOException {
        System.out.println(""\nforward"");
        SimpleBufferTransformer bufferTransformer = new SimpleBufferTransformer();
        MyTransformer myTransformer = new MyTransformer();
        bufferTransformer.setNextTransformer(myTransformer);
        System.out.println(""one input - one forward"");
        ByteBuffer input = createRandomBuffer(100);
        int size = input.remaining();
        bufferTransformer.transform(input);
        ByteBuffer result = myTransformer.getInput();
        assertNull(result);
        bufferTransformer.forward(size);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(size, result.remaining());
        System.out.println(""one input - two forwards"");
        input = createRandomBuffer(100);
        size = input.remaining();
        bufferTransformer.transform(input);
        result = myTransformer.getInput();
        int firstHalf = random.nextInt(size + 1);
        bufferTransformer.forward(firstHalf);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(firstHalf, result.remaining());
        int secondHalf = size - firstHalf;
        bufferTransformer.forward(secondHalf);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(secondHalf, result.remaining());
        System.out.println(""two inputs - one forward"");
        input = createRandomBuffer(100);
        size = input.remaining();
        bufferTransformer.transform(input);
        input = createRandomBuffer(100);
        size += input.remaining();
        bufferTransformer.transform(input);
        bufferTransformer.forward(size);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(size, result.remaining());
        System.out.println(""two inputs - two forwards"");
        input = createRandomBuffer(100);
        size = input.remaining();
        bufferTransformer.transform(input);
        input = createRandomBuffer(100);
        size += input.remaining();
        bufferTransformer.transform(input);
        firstHalf = random.nextInt(size + 1);
        bufferTransformer.forward(firstHalf);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(firstHalf, result.remaining());
        secondHalf = size - firstHalf;
        bufferTransformer.forward(secondHalf);
        result = myTransformer.getInput();
        assertNotNull(result);
        assertEquals(secondHalf, result.remaining());
    }
",0
2884214,13,"    public static String generateString(int minLength, int maxLength) {
        StringBuilder sb = new StringBuilder();
        int length = minLength + random.nextInt(maxLength - minLength);
        for (int i = 0; i < length; i++) {
            sb.append(CHARACTERS[random.nextInt(CHARACTERS.length)]);
        }
        return sb.toString();
    }
",1
11051820,13,"    public Object newValue(Random random) {
        if (random.nextBoolean()) {
            return """";
        }
        StringBuilder strBuilder = new StringBuilder();
        int remainingLength = minLength + random.nextInt(maxLength - minLength);
        boolean endsWithPunctuation = random.nextBoolean();
        if (endsWithPunctuation) {
            remainingLength--;
        }
        String word = getWord(remainingLength, random);
        strBuilder.append(word);
        remainingLength -= word.length();
        while (remainingLength > 1) {
            strBuilder.append(getChar(midPunctuation, random));
            remainingLength--;
            word = getWord(remainingLength, random);
            strBuilder.append(word);
            remainingLength -= word.length();
        }
        if (endsWithPunctuation) {
            strBuilder.append(getChar(endPunctuation, random));
        }
        return strBuilder.toString();
    }
",1
16451700,13,"    public static String getBestMove(String movesList) {
        if (movesList.length() > MAX_VARIANTS_LENGTH) {
            return """";
        }
        int i = 0;
        while (i < size && (!variantes[i].startsWith(movesList) || variantes[i].equals(movesList))) {
            i++;
        }
        if (i >= size) {
            return """";
        }
        int j = i;
        while (j < size && variantes[j].startsWith(movesList)) j++;
        int choice = i + rdm.nextInt(j - i);
        int lengthMoves = movesList.length();
        return variantes[choice].substring(lengthMoves, lengthMoves + 4);
    }
",1
6501588,13,"    private Color getRandColor(int fc, int bc) {
        int fc_a = fc;
        int bc_a = bc;
        Random random = new Random();
        if (fc > 255) fc_a = 255;
        if (bc > 255) bc_a = 255;
        int r = fc + random.nextInt(bc_a - fc_a);
        int g = fc + random.nextInt(bc_a - fc_a);
        int b = fc + random.nextInt(bc_a - fc_a);
        return new Color(r, g, b);
    }
",1
6944380,13,"        void doMovements() {
            Random r = new Random();
            int x = 0;
            int y = 0;
            int v = 0;
            executeAndWait(""c"", rm.out);
            while (rm.keepOn) {
                x = r.nextInt(XMAX - XMIN + 1) + XMIN;
                y = r.nextInt(YMAX - YMIN + 1) + YMIN;
                v = r.nextInt(VMAX + 1);
                v = VMAX;
                String command = ""x"" + x + ""y"" + y + ""v"" + v + ""m\r"";
                System.out.printf(""   x: %5d     y: %5d \n"", x, y);
                executeAndWait(command, rm.out);
            }
        }
",1
14809923,13,"    private void populateRandomWalksC(int number, int maxLength) {
        int counter = 0, unsucc = 0;
        FSMStructure fsm = WMethod.getGraphData(g);
        Random length = new Random(0);
        while (counter < number) {
            List<String> path = new ArrayList<String>(maxLength);
            String current = fsm.init;
            if (unsucc > 100) return;
            int randomLength = 0;
            while (randomLength == 0) randomLength = length.nextInt(maxLength + 1);
            for (int i = 0; i < randomLength; i++) {
                Map<String, String> row = fsm.trans.get(current);
                if (row.isEmpty()) break;
                String nextInput = (String) pickRandom(row.keySet());
                path.add(nextInput);
                current = row.get(nextInput);
            }
            int oldSize = sPlus.size();
            sPlus.add(new ArrayList<String>(path));
            if (sPlus.size() > oldSize) {
                counter++;
                unsucc = 0;
            } else {
                unsucc++;
            }
        }
    }
",1
11191280,13,"    public static Integer generateRandomInt(int upperLimit, boolean unique) {
        Integer randomInteger = null;
        if (unique) {
            do {
                randomInteger = generator.nextInt(upperLimit + 1);
            } while (set.contains(randomInteger));
            set.add(randomInteger);
        } else {
            randomInteger = generator.nextInt(upperLimit + 1);
        }
        return randomInteger;
    }
",1
4657480,13,"    public int next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        int value = from + rand.nextInt(to - from);
        while (memory.containsKey(value)) {
            ++value;
            if (value == to) {
                value = from;
            }
        }
        memory.put(value, value);
        return value;
    }
",1
11372483,13,"    private TObjectIntHashMap<Vertex> generateDegreeSequence(Graph graph, int maxDegree) {
        TObjectIntHashMap<Vertex> kMap = new TObjectIntHashMap<Vertex>();
        for (Vertex vertex : graph.getVertices()) {
            boolean accept = false;
            while (!accept) {
                try {
                    int k = random.nextInt(maxDegree + 1);
                    double p = degreeDistribution.value(k);
                    if (p >= random.nextDouble()) {
                        kMap.put(vertex, k);
                        accept = true;
                    }
                } catch (FunctionEvaluationException e) {
                    e.printStackTrace();
                }
            }
        }
        return kMap;
    }
",0
8896155,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
8998440,13,"    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.getDeclaringClass() == Object.class) {
            try {
                return method.invoke(realObject, args);
            } catch (InvocationTargetException ite) {
                throw ite.getCause();
            }
        }
        int remainingRetries = numRetries;
        int waitTime = minWait + rng.nextInt(maxWait - minWait);
        Throwable thrown = null;
        while (remainingRetries >= 0) {
            try {
                return method.invoke(realObject, args);
            } catch (InvocationTargetException ite) {
                thrown = ite.getCause();
                if (remainingRetries == 0) {
                    log.info(""Reached maximum retry count, giving up."");
                    break;
                } else {
                    if (retryExceptionTypes != null && retryExceptionTypes.length > 0) {
                        boolean shouldRetry = false;
                        for (Class<? extends Throwable> exceptionType : retryExceptionTypes) {
                            if (exceptionType.isInstance(thrown)) {
                                shouldRetry = true;
                                break;
                            }
                        }
                        if (!shouldRetry) {
                            log.info(""Call threw exception of type "" + thrown.getClass().getName() + "", which is not configured to cause a retry - giving up."");
                            break;
                        }
                    }
                    log.debug(""Exception thrown by method "" + method.getName() + "" of "" + realObject + "". Retrying in "" + waitTime + ""ms"", thrown);
                    try {
                        Thread.sleep(waitTime);
                    } catch (InterruptedException ie) {
                        log.info(""Thread interrupted, giving up retrying."");
                        throw thrown;
                    }
                    remainingRetries--;
                    waitTime = (int) (waitTime * backoffMultiplier);
                }
            }
        }
        throw thrown;
    }
",1
2558197,13,"    protected static int getRandomValue(int min, int max) {
        Random rand = new Random();
        int v = min + rand.nextInt(max - min);
        return rand.nextBoolean() ? v : -v;
    }
",1
15375607,13,"    public Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
5419710,13,"    public boolean batchFinished() throws Exception {
        Instances data = getInputFormat();
        if (data == null) throw new IllegalStateException(""No input instance format defined"");
        if (m_Converter == null) {
            int[] randomIndices = new int[m_ClassCounts.length];
            for (int i = 0; i < randomIndices.length; i++) {
                randomIndices[i] = i;
            }
            for (int j = randomIndices.length - 1; j > 0; j--) {
                int toSwap = m_Random.nextInt(j + 1);
                int tmpIndex = randomIndices[j];
                randomIndices[j] = randomIndices[toSwap];
                randomIndices[toSwap] = tmpIndex;
            }
            double[] randomizedCounts = new double[m_ClassCounts.length];
            for (int i = 0; i < randomizedCounts.length; i++) {
                randomizedCounts[i] = m_ClassCounts[randomIndices[i]];
            }
            if (m_ClassOrder == RANDOM) {
                m_Converter = randomIndices;
                m_ClassCounts = randomizedCounts;
            } else {
                int[] sorted = Utils.sort(randomizedCounts);
                m_Converter = new int[sorted.length];
                if (m_ClassOrder == FREQ_ASCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[i]];
                    }
                } else if (m_ClassOrder == FREQ_DESCEND) {
                    for (int i = 0; i < sorted.length; i++) {
                        m_Converter[i] = randomIndices[sorted[sorted.length - i - 1]];
                    }
                } else {
                    throw new IllegalArgumentException(""Class order not defined!"");
                }
                double[] tmp2 = new double[m_ClassCounts.length];
                for (int i = 0; i < m_Converter.length; i++) {
                    tmp2[i] = m_ClassCounts[m_Converter[i]];
                }
                m_ClassCounts = tmp2;
            }
            FastVector values = new FastVector(data.classAttribute().numValues());
            for (int i = 0; i < data.numClasses(); i++) {
                values.addElement(data.classAttribute().value(m_Converter[i]));
            }
            FastVector newVec = new FastVector(data.numAttributes());
            for (int i = 0; i < data.numAttributes(); i++) {
                if (i == data.classIndex()) {
                    newVec.addElement(new Attribute(data.classAttribute().name(), values, data.classAttribute().getMetadata()));
                } else {
                    newVec.addElement(data.attribute(i));
                }
            }
            Instances newInsts = new Instances(data.relationName(), newVec, 0);
            newInsts.setClassIndex(data.classIndex());
            setOutputFormat(newInsts);
            int[] temp = new int[m_Converter.length];
            for (int i = 0; i < temp.length; i++) {
                temp[m_Converter[i]] = i;
            }
            m_Converter = temp;
            for (int xyz = 0; xyz < data.numInstances(); xyz++) {
                Instance datum = data.instance(xyz);
                if (!datum.isMissing(datum.classIndex())) {
                    datum.setClassValue((double) m_Converter[(int) datum.classValue()]);
                }
                push(datum);
            }
        }
        flushInput();
        m_NewBatch = true;
        return (numPendingOutput() != 0);
    }
",0
8498047,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
19862707,13,"    public static Agent createRandomAgent(final World world) {
        Position anywhere = world.getPlaces().get(0).getPos();
        Agent a = new Agent(anywhere, ""HumanGreen"", world);
        boolean hasCar = false;
        if (rand.nextFloat() < PROB_HAS_CAR) {
            hasCar = true;
        }
        int age = MIN_AGE + rand.nextInt(MAX_AGE - MIN_AGE);
        EasyTime workStart = new EasyTime(AVG_WORK_START, 0);
        EasyTime sleepEnd = new EasyTime(workStart).shift(-1, 0);
        EasyTime sleepStart = new EasyTime(sleepEnd).shift(-AVG_SLEEP_TIME, 0);
        workStart.blur(TWO_HOUR_BLUR);
        sleepEnd.blur(HALF_HOUR_BLUR);
        sleepStart.blur(TWO_HOUR_BLUR);
        a.set(AGE, new IntegerNumber(age));
        a.set(CUISINE, getRandomType(CUISINE_TYPES));
        a.set(LANGUAGE, getRandomType(LANGUAGE_TYPES));
        a.set(GENDER, getRandomType(GENDER_TYPES));
        a.set(PARTY_ANIMAL, getRandomType(PARTY_ANIMAL_TYPES));
        a.set(WORKAHOLIC, getRandomType(WORKAHOLIC_TYPES));
        a.set(HAS_CAR, new BooleanType(hasCar));
        a.set(ACTIVITY, Activity.ASLEEP);
        a.set(WORK_START, workStart);
        a.set(WORK_END, new EasyTime(workStart).shift(AVG_WORK_TIME, 0));
        a.set(SLEEP_PERIOD, new TimePeriod(sleepStart, sleepEnd));
        try {
            a.set(HOME, world.getRandomPlaceOfType(""Homes""));
        } catch (PlaceNotFoundException e) {
            throw new RuntimeException(""Can't find any homes Places. Did u create them?"");
        }
        try {
            a.set(OFFICE, world.getRandomPlaceOfType(""Offices""));
        } catch (PlaceNotFoundException e) {
            throw new RuntimeException(""Can't find any offices. Did u create them?"");
        }
        a.setPos(((Place) a.get(HOME)).getPos());
        return a;
    }
",1
17048141,13,"    private void qSort(int[] a, int i, int j) {
        if (i >= j - 1) return;
        int rand = i + r.nextInt(j - i);
        if (rand < j - 1) {
            a[rand] += a[j - 1];
            a[j - 1] = a[rand] - a[j - 1];
            a[rand] -= a[j - 1];
        }
        int p = i;
        for (int k = i; k < j - 1; k++) {
            if (a[k] <= a[j - 1]) {
                if (p < k) {
                    a[p] = a[p] + a[k];
                    a[k] = a[p] - a[k];
                    a[p] = a[p] - a[k];
                }
                p++;
            }
        }
        if (p < j - 1) {
            a[p] += a[j - 1];
            a[j - 1] = a[p] - a[j - 1];
            a[p] -= a[j - 1];
        }
        qSort(a, i, p);
        qSort(a, p + 1, j);
    }
",1
21668962,13,"    private static String calc(String exp) {
        if (exp.startsWith(""random"")) {
            int beg = exp.indexOf(""("");
            int end = exp.indexOf("")"");
            String[] ss = exp.substring(beg + 1, end).split("","");
            int rb = Integer.parseInt(ss[0]);
            int re = Integer.parseInt(ss[1]);
            int rr = rb + random.nextInt(re - rb);
            return String.valueOf(rr);
        }
        return exp;
    }
",1
9414368,13,"    private static void testForPosition(Class<? extends ExtendedSet<Integer>> c) {
        ExtendedSet<Integer> bits = empty(c);
        Random rnd = new MersenneTwister(31);
        for (int i = 0; i < 1000; i++) {
            bits.clear();
            final int size = 1 + rnd.nextInt(10000);
            final int min = 1 + rnd.nextInt(10000 - 1);
            final int max = min + rnd.nextInt(10000 - min + 1);
            for (int j = 0; j < size; j++) {
                int item = min + rnd.nextInt(max - min + 1);
                bits.add(item);
            }
            String good = bits.toString();
            StringBuilder other = new StringBuilder();
            int s = bits.size();
            other.append('[');
            for (int j = 0; j < s; j++) {
                other.append(bits.get(j));
                if (j < s - 1) other.append("", "");
            }
            other.append(']');
            if (good.equals(other.toString())) {
                System.out.println(i + "") OK"");
            } else {
                System.out.println(""ERROR"");
                System.out.println(bits.debugInfo());
                System.out.println(bits);
                System.out.println(other);
                return;
            }
            int pos = 0;
            for (Integer x : bits) {
                if (bits.indexOf(x) != pos) {
                    System.out.println(""ERROR! "" + pos + "" != "" + bits.indexOf(x) + "" for element "" + x);
                    System.out.println(bits.debugInfo());
                    return;
                }
                pos++;
            }
        }
    }
",1
8811298,13,"    static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
19137253,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
14744159,13,"    public E next() {
        if (cursor < 1) {
            cursor = size - 1;
            return (E) data[0];
        }
        int grab = gen.nextInt(cursor + 1);
        E temp = (E) data[grab];
        data[grab] = data[cursor];
        data[cursor] = temp;
        cursor--;
        return temp;
    }
",1
16442937,13,"    private Color getRandColor(int min, int max) {
        Random random = new Random();
        if (min > 255) min = 255;
        if (max > 255) max = 255;
        int r = min + random.nextInt(max - min);
        int g = min + random.nextInt(max - min);
        int b = min + random.nextInt(max - min);
        return new Color(r, g, b);
    }
",1
10275021,13,"    public static String getRandomStr(char startChr, char endChr) {
        int randomInt;
        String randomStr = null;
        int startInt = Integer.valueOf(startChr);
        int endInt = Integer.valueOf(endChr);
        if (startInt > endInt) {
            throw new IllegalArgumentException(""Start String: "" + startChr + "" End String: "" + endChr);
        }
        try {
            SecureRandom rnd = new SecureRandom();
            do {
                randomInt = rnd.nextInt(endInt + 1);
            } while (randomInt < startInt);
            randomStr = (char) randomInt + """";
        } catch (Exception e) {
            Logger.getLogger(EgovStringUtil.class).debug(e);
        }
        return randomStr;
    }
",1
10274234,13,"    private void inintCluster(TextBasedDataSet dataSet) throws Exception {
        dataSet.generatePKList();
        m_Iterations = 0;
        m_ClusterCentroids = new ArrayList<TextBasedData>(m_NumClusters);
        m_ClusterCentroidsOwner = new TextBasedDataSet();
        m_ClusterCentroidsOwner.setAttrMeta(dataSet.getAttrMeta());
        m_clusterAssignments = new int[dataSet.getTextNumber()];
        Random RandomO = new Random(getSeed());
        int instIndex;
        HashMap<String, Object> initC = new HashMap<String, Object>();
        String textKey = null;
        for (int j = dataSet.getTextNumber() - 1; j >= 0; j--) {
            instIndex = RandomO.nextInt(j + 1);
            textKey = dataSet.getKeyByPosition(instIndex);
            if (!initC.containsKey(textKey)) {
                m_ClusterCentroids.add(dataSet.getByListPosition(instIndex));
                initC.put(textKey, null);
            }
            try {
                dataSet.swap(j, instIndex);
            } catch (Exception e) {
                e.printStackTrace();
            }
            if (m_ClusterCentroids.size() == m_NumClusters) {
                break;
            }
        }
        m_NumClusters = m_ClusterCentroids.size();
    }
",1
6979194,13,"    Geometry createGeometry() {
        double center_x = meansize + (rand.nextDouble() * (xrange - (2 * meansize)));
        double center_y = meansize + (rand.nextDouble() * (yrange - (2 * meansize)));
        double size = rand.nextDouble() * 2 * meansize;
        int n_vertices = 3 + rand.nextInt(max_vertices - 3);
        double[] angles = new double[n_vertices];
        double[] distances = new double[n_vertices];
        for (int k = 0; k < n_vertices; k++) {
            angles[k] = rand.nextDouble() * 2 * Math.PI;
            distances[k] = rand.nextDouble() * size;
        }
        sort(angles);
        Coordinate[] coords = new Coordinate[n_vertices + 1];
        for (int k = 0; k < n_vertices; k++) {
            double x = center_x + (distances[k] * Math.cos(angles[k]));
            double y = center_y + (distances[k] * Math.sin(angles[k]));
            coords[k] = new Coordinate(x, y);
        }
        coords[n_vertices] = coords[0];
        CoordinateSequence cs = new CoordinateArraySequence(coords);
        return new LineString(cs, gfact);
    }
",1
11071921,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
13431733,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
4482794,13,"    public int removeRandom(Forest f, int nEntries) {
        int nRemoved = 0;
        for (Node root : f.getTrees()) {
            for (int i = 0; i < nEntries; i++) {
                int nNodes = traverseTreePreorder(root, 0);
                if (nNodes <= 1) {
                    break;
                }
                int idx = 1 + randomIdx.nextInt(nNodes - 1);
                Node n = getNodeByPreorderIdx(root, new int[] { idx });
                Node parent = getParentOfPreorderIdx(root, null, new int[] { idx });
                if ((n != null) && (parent != null)) {
                    if (parent.getLeft() == n) {
                        parent.setLeft(null);
                    } else {
                        parent.setRight(null);
                    }
                    nRemoved++;
                }
            }
        }
        return nRemoved;
    }
",0
16216215,13,"    public void CreatePopulation(int popSize) throws Exception {
        InitPopulation(popSize);
        int segmentation = m_numAttribs / 2;
        for (int i = 0; i < m_popSize; i++) {
            List<Subset> attributeRankingCopy = new ArrayList<Subset>();
            for (int j = 0; j < m_attributeRanking.size(); j++) attributeRankingCopy.add(m_attributeRanking.get(j));
            double last_evaluation = -999;
            double current_evaluation = 0;
            boolean doneAnew = true;
            while (true) {
                int random_number = m_random.nextInt(segmentation + 1);
                if (doneAnew && i <= segmentation) random_number = i;
                doneAnew = false;
                Subset s1 = ((Subset) attributeRankingCopy.get(random_number)).clone();
                Subset s2 = ((Subset) m_population.get(i)).clone();
                Subset joiners = joinSubsets(s1, s2);
                current_evaluation = joiners.merit;
                if (current_evaluation > last_evaluation) {
                    m_population.set(i, joiners);
                    last_evaluation = current_evaluation;
                    try {
                        attributeRankingCopy.set(random_number, attributeRankingCopy.get(segmentation + 1));
                        attributeRankingCopy.remove(segmentation + 1);
                    } catch (IndexOutOfBoundsException ex) {
                        attributeRankingCopy.set(random_number, new Subset(new BitSet(m_numAttribs), 0));
                        continue;
                    }
                } else {
                    break;
                }
            }
        }
    }
",1
7899786,13,"    private int calcAge(AlbatrossPerson albatrossPerson) {
        int code = albatrossPerson.AGEP;
        int min = 0;
        int max = 0;
        if (code == 0) {
            min = 18;
            max = 35;
        } else if (code == 1) {
            min = 35;
            max = 55;
        } else if (code == 2) {
            min = 55;
            max = 65;
        } else if (code == 3) {
            min = 65;
            max = 75;
        } else if (code == 4) {
            min = 75;
            max = 100;
        }
        int age = min + random.nextInt(max - min);
        return age;
    }
",0
17641541,13,"    public void crossOver(Gene a, Gene b, Gene a1, Gene b1) {
        int point = MyRandom.nextInt(bitsPerGene + 1);
        for (int j = 0; j < bitsPerGene; j++) {
            if (j < point) {
                a1.bits[j] = a.bits[j];
                b1.bits[j] = b.bits[j];
            } else {
                a1.bits[j] = b.bits[j];
                b1.bits[j] = a.bits[j];
            }
        }
    }
",1
12834346,13,"    private static Color getRandColor(int cc, int bb) {
        Random random = new Random();
        if (cc > 255) cc = 255;
        if (bb > 255) bb = 255;
        int r = cc + random.nextInt(bb - cc);
        int g = cc + random.nextInt(bb - cc);
        int b = cc + random.nextInt(bb - cc);
        return new Color(r, g, b);
    }
",1
7986663,13,"    public static String generate(int minLength, int maxLength) throws Exception {
        PasswordGenerator.init();
        if (minLength <= 0 || maxLength <= 0 || minLength > maxLength) return null;
        char[][] charGroups = new char[][] { PASSWORD_CHARS_LCASE.toCharArray(), PASSWORD_CHARS_UCASE.toCharArray(), PASSWORD_CHARS_NUMERIC.toCharArray(), PASSWORD_CHARS_SPECIAL.toCharArray() };
        int[] charsLeftInGroup = new int[charGroups.length];
        for (int i = 0; i < charsLeftInGroup.length; i++) charsLeftInGroup[i] = charGroups[i].length;
        int[] leftGroupsOrder = new int[charGroups.length];
        for (int i = 0; i < leftGroupsOrder.length; i++) leftGroupsOrder[i] = i;
        char[] password = null;
        if (minLength < maxLength) password = new char[random.nextInt(maxLength - minLength) + minLength]; else password = new char[minLength];
        int nextCharIdx;
        int nextGroupIdx;
        int nextLeftGroupsOrderIdx;
        int lastCharIdx;
        int lastLeftGroupsOrderIdx = leftGroupsOrder.length - 1;
        for (int i = 0; i < password.length; i++) {
            if (lastLeftGroupsOrderIdx == 0) nextLeftGroupsOrderIdx = 0; else nextLeftGroupsOrderIdx = random.nextInt(lastLeftGroupsOrderIdx);
            nextGroupIdx = leftGroupsOrder[nextLeftGroupsOrderIdx];
            lastCharIdx = charsLeftInGroup[nextGroupIdx] - 1;
            if (lastCharIdx == 0) nextCharIdx = 0; else nextCharIdx = random.nextInt(lastCharIdx + 1);
            password[i] = charGroups[nextGroupIdx][nextCharIdx];
            if (lastCharIdx == 0) charsLeftInGroup[nextGroupIdx] = charGroups[nextGroupIdx].length; else {
                if (lastCharIdx != nextCharIdx) {
                    char temp = charGroups[nextGroupIdx][lastCharIdx];
                    charGroups[nextGroupIdx][lastCharIdx] = charGroups[nextGroupIdx][nextCharIdx];
                    charGroups[nextGroupIdx][nextCharIdx] = temp;
                }
                charsLeftInGroup[nextGroupIdx]--;
            }
            if (lastLeftGroupsOrderIdx == 0) lastLeftGroupsOrderIdx = leftGroupsOrder.length - 1; else {
                if (lastLeftGroupsOrderIdx != nextLeftGroupsOrderIdx) {
                    int temp = leftGroupsOrder[lastLeftGroupsOrderIdx];
                    leftGroupsOrder[lastLeftGroupsOrderIdx] = leftGroupsOrder[nextLeftGroupsOrderIdx];
                    leftGroupsOrder[nextLeftGroupsOrderIdx] = temp;
                }
                lastLeftGroupsOrderIdx--;
            }
        }
        return new String(password);
    }
",1
22513684,13,"    public static int[] calculateMetals(Solar planet, Random rng) {
        int[] deposits = new int[PlanetResources.Metals.values().length];
        switch(planet.ptype) {
            case BARE_ROCK:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = rng.nextInt(300) / 100;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(400) / 100;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(300) / 100;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(400) / 100;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(200) / 100;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(300) / 100;
                deposits[PlanetResources.Metals.Zinc.ordinal()] = rng.nextInt(300) / 100;
                deposits[PlanetResources.Metals.Iron.ordinal()] = rng.nextInt(600) / 100;
                deposits[PlanetResources.Metals.Nickel.ordinal()] = rng.nextInt(500) / 100;
                deposits[PlanetResources.Metals.Mercury.ordinal()] = rng.nextInt(120) / 100;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Indium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Tellurium.ordinal()] = rng.nextInt(101) / 100;
                break;
            case ATM_ROCK:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(250) / 100;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(130) / 100;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(201) / 100;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(330) / 100;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(180) / 100;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(210) / 100;
                deposits[PlanetResources.Metals.Zinc.ordinal()] = rng.nextInt(210) / 100;
                deposits[PlanetResources.Metals.Iron.ordinal()] = rng.nextInt(250) / 100;
                deposits[PlanetResources.Metals.Nickel.ordinal()] = rng.nextInt(250) / 100;
                deposits[PlanetResources.Metals.Mercury.ordinal()] = rng.nextInt(110) / 100;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(103) / 100;
                deposits[PlanetResources.Metals.Indium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Tellurium.ordinal()] = rng.nextInt(101) / 100;
                break;
            case CLOUD:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = rng.nextInt(110) / 100;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(200) / 100;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(200) / 100;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(170) / 100;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(150) / 100;
                deposits[PlanetResources.Metals.Zinc.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Iron.ordinal()] = rng.nextInt(110) / 100;
                deposits[PlanetResources.Metals.Nickel.ordinal()] = rng.nextInt(110) / 100;
                deposits[PlanetResources.Metals.Mercury.ordinal()] = rng.nextInt(105) / 100;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Indium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Tellurium.ordinal()] = rng.nextInt(101) / 100;
                break;
            case EARTH:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = 0;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(12) / 5;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(6) / 5;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(12) / 5;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(6) / 5;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(6) / 5;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(8) / 5;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(12) / 5;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(101) / 100;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(101) / 100;
                break;
            case ICE:
                deposits[PlanetResources.Metals.Chromium.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Copper.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Gold.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Lead.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Manganese.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Platinum.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Silver.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Tin.ordinal()] = rng.nextInt(21) / 20;
                deposits[PlanetResources.Metals.Iridium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Osmium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Palladium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Rhodium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Ruthenium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Bismuth.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Indium.ordinal()] = rng.nextInt(201) / 200;
                deposits[PlanetResources.Metals.Tellurium.ordinal()] = rng.nextInt(201) / 200;
                break;
            default:
        }
        final int promotionFactor = calculateRichness(planet);
        for (int i = 0; i < deposits.length; i++) {
            if (deposits[i] != 0) {
                int rich = rng.nextInt(promotionFactor + 1);
                rich += deposits[i] - 1;
                deposits[i] = rich;
            }
        }
        return deposits;
    }
",1
727500,13,"    public static void main(String args[]) {
        try {
            DB.Initialize();
            Random r = new Random();
            StudentInfo[] s = StudentModel.getStudents();
            Club[] c = ClubModel.getClubs();
            if (false) {
                for (Club b : c) {
                    if (b.rank.equals(""-1"")) {
                        b.rank = """" + r.nextInt(11);
                        System.out.println(b.name + "": -1 -> "" + b.rank + ""  "" + DB.Update(""UPDATE Club SET rank='"" + b.rank + ""' WHERE club_id="" + b.id));
                    }
                    int rank = Integer.parseInt(b.rank);
                    String q = ""20101"";
                    double moneyz[] = { 200, 300, 500, 600, 800, 1000, 2000, 4000, 6000, 8000, 10000 };
                    System.out.println(""Budget: "" + moneyz[rank] + ""   "" + DB.Update(""INSERT INTO Budget (`club_id`, `quarter_id`, `used`, `available`) VALUES ( "" + b.id + "", "" + q + "", 0, "" + moneyz[rank] + "" )"") + ""   "" + b.name);
                }
            }
            int max_club = 3;
            if (false) {
                for (StudentInfo i : s) {
                    int num = r.nextInt(max_club + 1);
                    num -= ClubModel.getClubsOfMember(i.uid).length;
                    for (int k = 0; k < num; k++) {
                        int join = r.nextInt(c.length);
                        System.out.println(i.uid + "" -> "" + c[join].name + ""   "" + ClubModel.addMember(i, c[join]));
                    }
                }
            }
        } catch (DBError de) {
        }
    }
",1
4409393,13,"        public static <T> int randomizedPartition(List<T> array, int startIndex, int endIndex, Comparator<T> comparator) {
            int i = startIndex + random.nextInt(endIndex - startIndex);
            swap(array, i, startIndex);
            return partition(array, startIndex, endIndex, comparator);
        }
",1
2948282,13,"        private void calcCurrentDrop() {
            currentDrop = minDropRate + RANDOM.nextInt(maxDropRate - minDropRate);
        }
",1
682291,13,"    public static void main(String[] args) {
        Dice Di = new Dice();
        Scanner Scan1 = new Scanner(System.in);
        Scanner Scan3 = new Scanner(System.in);
        Random randomNumbers = new Random();
        int sum1 = 0;
        int sum2 = 0;
        int lng;
        int s;
        String player1;
        String player2;
        System.out.println(""Please, write the name of the first player: "");
        player1 = Scan1.nextLine();
        System.out.println(""Please, write the name of the second player: "");
        player2 = Scan1.nextLine();
        System.out.println(""Please, type the \""Length\"" of the dice: "");
        lng = Scan3.nextInt();
        System.out.println(""It is your turn now "" + player1 + "" you'll throw 5 times 'pray to get the highest score :P'.\n"");
        for (int i = 0; i < 5; i++) {
            s = 0 + randomNumbers.nextInt(100 - 0);
            System.out.println(""You got: "" + s);
            sum1 = sum1 + s;
        }
        System.out.println(""It is your turn now "" + player2 + "" you'll throw 5 times 'pray to get the highest score :P'.\n"");
        for (int j = 0; j < 5; j++) {
            s = 0 + randomNumbers.nextInt(100 - 0);
            System.out.println(""You got: "" + s);
            sum2 = sum2 + s;
        }
        System.out.println(player1 + "", you got a sum of "" + sum1 + "" and "" + player2 + "", got a sum of "" + sum2);
        if (sum1 > sum2) {
            System.out.println(player1 + "", Congratulation! you won :D."");
        } else if (sum2 > sum1) {
            System.out.println(player2 + "", Congratulation! you won :D."");
        } else if (sum2 == sum1) {
            System.out.println(player2 + "", and "" + player2 + "" you both played a nice game, you two equal in the luck :P."");
        }
    }
",1
20387187,13,"    public void testFirstInRange() {
        for (int i = 0; i < 1000; i++) {
            BitVector v = new BitVector(1000);
            int vSize = v.size();
            int a = random.nextInt(vSize + 1);
            int b = a + random.nextInt(vSize + 1 - a);
            BitVector w = v.rangeView(a, b);
            int c;
            int wSize = w.size();
            if (wSize == 0) {
                c = -1;
            } else {
                c = random.nextInt(wSize);
                w.setBit(c, true);
            }
            if (c >= 0) {
                assertEquals(c, w.firstOne());
                assertEquals(c, w.lastOne());
                assertEquals(c, w.nextOne(c));
                assertEquals(-1, w.previousOne(c));
                if (c > 0) assertEquals(c, w.nextOne(c - 1));
                if (c < wSize) assertEquals(c, w.previousOne(c + 1));
                assertEquals(c, w.nextOne(0));
                assertEquals(c, w.previousOne(wSize));
            } else {
                assertEquals(0, w.firstOne());
                assertEquals(-1, w.lastOne());
            }
            w.flip();
            if (c >= 0) {
                assertEquals(c, w.firstZero());
                assertEquals(c, w.lastZero());
                assertEquals(c, w.nextZero(c));
                assertEquals(-1, w.previousZero(c));
                if (c > 0) assertEquals(c, w.nextZero(c - 1));
                if (c < wSize) assertEquals(c, w.previousZero(c + 1));
                assertEquals(c, w.nextZero(0));
                assertEquals(c, w.previousZero(wSize));
            } else {
                assertEquals(0, w.firstZero());
                assertEquals(-1, w.lastZero());
            }
        }
    }
",1
13621015,13,"    private void workForRandomPeriod(int minDuration, int maxDuration) {
        Random random = new Random();
        int period = minDuration + random.nextInt(maxDuration - minDuration);
        long start = Process.getElapsedCpuTime();
        while (Process.getElapsedCpuTime() - start < period) {
            for (int i = 0, temp = 0; i < 50; i++) {
                temp += i;
            }
        }
    }
",1
9479943,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
20765197,13,"        public MyGamePanel() {
            font = new Font(""lucida sans regular"", Font.PLAIN, 16);
            Random rand = new Random();
            me = new Player();
            me.x = 10 + rand.nextInt(300 - 20);
            me.y = 10 + rand.nextInt(300 - 20);
            me.latestKey = (char) ('A' + rand.nextInt(26));
            players.put(""me"", me);
        }
",0
14574135,13,"    private IndianSettlement placeIndianSettlement(Player player, boolean capital, Position position, Map map) {
        final Tile tile = map.getTile(position);
        String name = (capital) ? player.getCapitalName() : player.getSettlementName();
        if (Player.ASSIGN_SETTLEMENT_NAME.equals(name)) {
            player.installSettlementNames(Messages.getSettlementNames(player), random);
            name = (capital) ? player.getCapitalName() : player.getSettlementName();
        }
        UnitType skill = generateSkillForLocation(map, tile, player.getNationType());
        IndianSettlement settlement = new ServerIndianSettlement(map.getGame(), player, name, tile, capital, skill, new HashSet<Player>(), null);
        player.addSettlement(settlement);
        logger.fine(""Generated skill: "" + settlement.getLearnableSkill());
        int low = settlement.getType().getMinimumSize();
        int high = settlement.getType().getMaximumSize();
        int unitCount = low + random.nextInt(high - low);
        for (int i = 0; i < unitCount; i++) {
            UnitType unitType = map.getSpecification().getUnitType(""model.unit.brave"");
            Unit unit = new ServerUnit(map.getGame(), settlement, player, unitType, unitType.getDefaultEquipment());
            unit.setIndianSettlement(settlement);
            if (i == 0) {
                unit.setLocation(tile);
            } else {
                unit.setLocation(settlement);
            }
        }
        settlement.placeSettlement(true);
        if (FreeCol.isInDebugMode()) {
            for (GoodsType goodsType : map.getSpecification().getGoodsTypeList()) {
                if (goodsType.isNewWorldGoodsType()) settlement.addGoods(goodsType, 150);
            }
        }
        return settlement;
    }
",1
21135057,13,"    private static List<BitSet> makeRandomBitSetList(final long randomSeed, final int listSize, final int minBitsSize, final int maxBitsSize) {
        Random r = new Random(randomSeed);
        List<BitSet> resultList = new ArrayList<BitSet>(listSize);
        for (int i = 0; i < listSize; i++) {
            int arraySize = minBitsSize + r.nextInt(maxBitsSize - minBitsSize);
            resultList.add(makeRandomBitSet(r, arraySize));
        }
        return resultList;
    }
",1
12883936,13,"    public void testFuzz() throws Exception {
        Model model = getTestModel();
        StackEvaluator eval = new LazyStackEvaluator();
        PrintStream errStream = new PrintStream(new NullOutputStream());
        QueryEngine qe = new QueryEngine(model, eval, System.out, errStream);
        Collector<RippleList, RippleException> expected = new Collector<RippleList, RippleException>();
        Collector<RippleList, RippleException> results = new Collector<RippleList, RippleException>();
        QueryPipe qp = new QueryPipe(qe, results);
        ModelConnection mc = qe.getConnection();
        RippleValue five = mc.value(5);
        byte[] bytes = new byte[128];
        for (int i = 0; i < bytes.length; i++) {
            bytes[i] = (i >= 32) ? (byte) i : (i >= 16) ? (byte) '\n' : (byte) '\t';
        }
        for (int i = 0; i < REPEAT; i++) {
            int len = MAX_EXPR_LENGTH + rand.nextInt(MAX_EXPR_LENGTH - MIN_EXPR_LENGTH);
            byte[] expr = new byte[len];
            for (int j = 0; j < len; j++) {
                expr[j] = bytes[rand.nextInt(bytes.length)];
            }
            String s = new String(expr);
            qp.put(new String(expr));
            qp.put("".\n"");
            qp.put("".\n"");
            qp.put("".\n"");
            results.clear();
            qp.put(""2 3 add >> .\n"");
            expected.clear();
            expected.put(createStack(mc, five));
            assertCollectorsEqual(expected, results);
        }
        qp.close();
        mc.close();
    }
",1
18422684,13,"    private Color getRandColor(int fc, int bc) {
        int fc_a = fc;
        int bc_a = bc;
        Random random = new Random();
        if (fc > 255) fc_a = 255;
        if (bc > 255) bc_a = 255;
        int r = fc + random.nextInt(bc_a - fc_a);
        int g = fc + random.nextInt(bc_a - fc_a);
        int b = fc + random.nextInt(bc_a - fc_a);
        return new Color(r, g, b);
    }
",0
749901,13,"    private InputStream dataInStreamCommand(String cmd) {
        InputStream dataStream;
        if (passiveMode) {
            printCommand(""PASV"");
            waitForResult();
            getLastResult();
            int[] i = parsePassiveParentheses((String) lastlines.get(lastlines.size() - 1));
            String datahost = i[0] + ""."" + i[1] + ""."" + i[2] + ""."" + i[3];
            int dataport = (i[4] * 256) + i[5];
            try {
                dataPassiveConnection = new FTPPassiveConnection(datahost, dataport);
                dataStream = dataPassiveConnection.getIn();
            } catch (IOException e) {
                System.out.println(e);
                return null;
            }
            printCommand(cmd);
            waitForResult();
            getLastResult();
        } else {
            int port = portrange_lower + random.nextInt(portrange_upper - portrange_lower);
            System.out.println(""port "" + port);
            try {
                dataPortConnection = new FTPPortConnection(port);
            } catch (IOException e) {
                System.out.println(e);
                return null;
            }
            printCommand(""PORT "" + localip + "","" + port2ascii(port));
            waitForResult();
            getLastResult();
            printCommand(cmd);
            waitForResult();
            getLastResult();
            try {
                dataPortConnection.waitForConnection();
            } catch (InterruptedException e) {
                System.out.println(""Interrupted in join(): "" + e);
            }
            try {
                dataStream = dataPortConnection.getIn();
            } catch (IOException e) {
                System.out.println(""Can not establish connection :"" + e);
                return null;
            }
        }
        return dataStream;
    }
",1
7981579,13,"        public Layer(int num, ALayer pl, int inputs_per_neuron) {
            prevLayer = pl;
            index = num;
            ANeuron[] copyN;
            ANeuron[] inputsChoosen;
            g = new Genome[maxNeuronsInLayer];
            prevLayer = pl;
            ALayer aLayer = prevLayer;
            ANeuron choosen;
            Dimension pos;
            new Dimension();
            layerProgress = 0;
            boolean tryAgain;
            inputsToNeuron = inputs_per_neuron;
            logger.info(""New layer "" + num + "", max inputs:"" + inputs_per_neuron);
            inumber = c.getLayerInitialNeuronsNumber(num);
            logger.info(""Number of neurons in the population:"" + inumber);
            number = inumber;
            if (number > inumber) {
                number = inumber;
            }
            int actInput, golayer, which, s;
            inputsPossible = 0;
            while (aLayer != null) {
                inputsPossible += aLayer.getNumber();
                aLayer = aLayer.getPreviousLayer();
            }
            if (c.isJustTwo()) {
                inputs_per_neuron = inputsToNeuron = inputsPossible;
            }
            inputsChoosen = new ANeuron[inputs_per_neuron];
            mode = PASSIVE;
            prevLayer.computeOutputs();
            for (int i = 0; i < inumber; i++) {
                copyN = prevLayer.getRandomNeurons(1);
                aLayer = prevLayer;
                ALayer al;
                inputsChoosen[0] = copyN[0];
                int inputsPN;
                if (c.isJustTwo()) {
                    inputsPN = myRandom.nextInt(inputs_per_neuron);
                    inputsPN++;
                } else {
                    inputsPN = inputs_per_neuron;
                }
                if (c.isEmployPrevious()) {
                    actInput = 1;
                } else {
                    actInput = 0;
                }
                int full;
                while (actInput < inputsPN) {
                    do {
                        aLayer = prevLayer;
                        switch(c.getParents()) {
                            case NetworkConfiguration.YOUNG:
                                full = aLayer.getNumber();
                                while (actInput >= full) {
                                    aLayer = aLayer.getPreviousLayer();
                                    if (aLayer != null) {
                                        full += aLayer.getNumber();
                                    } else {
                                        break;
                                    }
                                }
                                break;
                            case NetworkConfiguration.YOUNGER:
                                for (int j = s = 0; j < num + 1; j++) {
                                    s += (j + 1);
                                }
                                s = myRandom.nextInt(s + 1) - num - 1;
                                for (int j = num; s > 0; s -= j--) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.MIDDLE:
                                s = myRandom.nextInt(num + 1);
                                for (int j = 0; j < s; j++) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.OLDER:
                                for (int j = s = 0; j < num + 1; j++) {
                                    s += (j + 1);
                                }
                                s = myRandom.nextInt(s + 1) - num - 1;
                                for (int j = num; s > 0; s -= (num - (--j))) {
                                    if (aLayer != null) {
                                        aLayer = aLayer.getPreviousLayer();
                                    }
                                }
                                break;
                            case NetworkConfiguration.OLD:
                                full = 0;
                                do {
                                    al = getPreviousLayer();
                                    while (al.getPreviousLayer() != null) {
                                        al = al.getPreviousLayer();
                                    }
                                    aLayer = al;
                                    full += aLayer.getNumber();
                                } while (actInput >= full);
                                break;
                        }
                        choosen = aLayer.getNeuron(myRandom.nextInt(aLayer.getNumber()));
                        tryAgain = false;
                        for (int j = 0; j < actInput; j++) {
                            if (inputsChoosen[j].equals(choosen)) {
                                tryAgain = true;
                            }
                        }
                    } while (tryAgain);
                    inputsChoosen[actInput] = choosen;
                    actInput++;
                }
                g[i] = new Genome(iNum, inputsPossible, inputsPN);
                inputsToNeuron = inputsPN;
                do {
                    which = myRandom.nextInt(u.getNeuronsNumber());
                } while (!c.neuronTypeAllowed(which));
                int train;
                do {
                    train = myRandom.nextInt(u.getTrainersNumber());
                } while (!c.neuronTrainerAllowed(train));
                do {
                    n[i] = newNeuron(which, train, inputsChoosen);
                } while (n[i] == null);
                logger.trace(""New neuron "" + i + "", type id:"" + which + "", trainer id:"" + train);
                for (int j = 0; j < inputsPN; j++) {
                    pos = getNeuronParentPosition(n[i], j);
                    if (pos == null) {
                        int h = 0;
                    }
                    int ipos = (int) pos.getWidth();
                    int layerDist = (int) pos.getHeight();
                    ALayer pLay = this;
                    for (int k = 0; k < layerDist; k++) {
                        if (pLay != null) {
                            pLay = pLay.getPreviousLayer();
                        }
                    }
                    if (pLay != null) {
                        pLay = pLay.getPreviousLayer();
                    }
                    while (pLay != null) {
                        ipos += pLay.getNumber();
                        pLay = pLay.getPreviousLayer();
                    }
                    g[i].setInput(ipos, 1);
                }
                if (n[i].getClass().getName().compareTo(""game.neurons.CombiNeuron"") == 0) {
                    g[i] = new CombiGenome((CombiNeuron) n[i], g[i]);
                    ((CombiNeuron) n[i]).readGenome(((CombiGenome) g[i]));
                }
                logger.trace(""Neuron input connections:"" + g[i].toString());
            }
            mode = ACTIVE;
            inputsToNeuron = inputs_per_neuron;
        }
",1
5279574,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
18570252,13,"    public TravellerChromosome(TravellerWorld world, String originatorName) {
        super();
        m_world = world;
        m_originator = new String(originatorName);
        if (m_mt == null) {
            m_mt = MersenneTwister.getTwister();
        }
        m_fitness = Double.MAX_VALUE;
        m_fitnessValid = false;
        m_cityList = new Codon[m_world.getNumberOfCities()];
        for (int i = 0; i < m_cityList.length; i++) {
            m_cityList[i] = new Codon(t_model.nodeIndex[i]);
        }
        for (int currentSlot = m_cityList.length - 1; currentSlot > 0; currentSlot--) {
            int swapSlot = m_mt.nextInt(currentSlot + 1);
            int temp = m_cityList[swapSlot].get();
            m_cityList[swapSlot].set(m_cityList[currentSlot].get());
            m_cityList[currentSlot].set(temp);
        }
    }
",1
1801671,13,"    public String generateValidValue(Map<ConstraintType, Constraint> constraints) throws UnsupportedConstraintException, MissingPropertyException {
        for (ConstraintType constraintType : constraints.keySet()) {
            if (!supportedConstraintTypes.contains(constraintType)) {
                throw new UnsupportedConstraintException(this, constraintType);
            }
        }
        String value = null;
        if (constraints.containsKey(ConstraintType.LENGTH)) {
            Integer max = (Integer) constraints.get(ConstraintType.LENGTH).getProperty(""max"");
            Integer min = (Integer) constraints.get(ConstraintType.LENGTH).getProperty(""min"");
            if (max == null && min == null) {
                throw new MissingPropertyException(constraints.get(ConstraintType.LENGTH), ""min"", ""Expected at least one of properties [min, max] for Constraint of type LENGTH."");
            }
            min = (min == null ? 0 : min);
            max = (max == null ? Integer.MAX_VALUE : max);
            int length = min + random.nextInt(max - min);
            value = RandomStringUtils.random(length);
            return value;
        } else if (constraints.containsKey(ConstraintType.NOTNULL)) {
            return ""notnull"";
        }
        return value;
    }
",1
10489284,13,"    private int getRandomNumber(int lowerLimit, int upperLimit) {
        int randomNumber;
        while (true) {
            randomNumber = random.nextInt(upperLimit + 1);
            if (randomNumber >= lowerLimit) {
                break;
            }
        }
        return randomNumber;
    }
",1
1181594,13,"    public File generate(String rootName, String name) {
        File root = new File(rootName, name);
        if (root.exists()) {
            if (force) {
                FileSystemUtil.deleteDirR(root, FS);
            } else {
                System.out.printf(""%s: such folder already exists!"", root.getName());
                return null;
            }
        }
        int depth = random.nextInt(maxDepth + 1);
        generateDir(new File(rootName), name, depth);
        return root;
    }
",0
9708829,13,"    private static short approxMaxOppVal(int atOpp, int activeOpps, Card cards[], int communityShortcut, MersenneTwisterFast rand) {
        if (atOpp >= activeOpps) {
            return Short.MIN_VALUE;
        }
        int holeDestA = OPP_A - atOpp * 2;
        int holeDestB = holeDestA - 1;
        int xOppA = rand.nextInt(holeDestA + 1);
        int xOppB = rand.nextInt(holeDestB + 1);
        swap(cards, xOppA, holeDestA);
        swap(cards, xOppB, holeDestB);
        Card oppA = cards[holeDestA];
        Card oppB = cards[holeDestB];
        short oppVal = Eval7Faster.fastValueOf(communityShortcut, oppA, oppB);
        short maxOtherOppVal = approxMaxOppVal(atOpp + 1, activeOpps, cards, communityShortcut, rand);
        swap(cards, xOppB, holeDestB);
        swap(cards, xOppA, holeDestA);
        return (short) Math.max(oppVal, maxOtherOppVal);
    }
",1
4301141,13,"    private static Color getRandColor(int color1, int color2) {
        Random random = new Random();
        if (color1 > 255) color1 = 255;
        if (color2 > 255) color2 = 255;
        int r = color1 + random.nextInt(color2 - color1);
        int g = color1 + random.nextInt(color2 - color1);
        int b = color1 + random.nextInt(color2 - color1);
        return new Color(r, g, b);
    }
",1
13146082,13,"    public static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
16136108,13,"    public Map<Id, List<Id>> run() {
        int cliqueSize = minCliqueSize + randomGen.nextInt(maxCliqueSize - minCliqueSize);
        List<Person> clique = new ArrayList<Person>(maxCliqueSize);
        int count = 0;
        this.cliques.clear();
        for (Person person : this.population.getPersons().values()) {
            if (count < cliqueSize) {
                count++;
                clique.add(person);
            } else {
                processClique(clique);
                cliqueSize = minCliqueSize + randomGen.nextInt(maxCliqueSize - minCliqueSize);
                clique.clear();
                clique.add(person);
                count = 1;
            }
        }
        return this.cliques;
    }
",0
5272380,13,"    public void generate(int numOfJobs, double reuse) throws Exception {
        this.createDatabase();
        int submitTime = 0;
        int threshold = numOfJobs - (int) (numOfJobs * (reuse / 100));
        int reuseLimit = numOfJobs - threshold;
        System.out.println(""-- LIMIAR: "" + threshold);
        System.out.println(""-- REUSE LIMIT: "" + reuseLimit);
        int[] datas = new int[threshold];
        for (int i = 0; i < threshold; i++) {
            random = new Random(System.nanoTime());
            datas[i] = MIN_DATA_SIZE + random.nextInt(MAX_DATA_SIZE - MIN_DATA_SIZE);
        }
        int id = 1;
        int count = 0;
        int dataId = 1;
        for (int i = 0; i < threshold; i++) {
            try {
                random = new Random(System.nanoTime());
                int userId = 1 + random.nextInt(QuotaScheduler.NUMBER_OF_USERS);
                this.addStat(id++, submitTime, dataId, datas[dataId - 1], userId);
                if (count++ == 1024) {
                    stat.executeBatch();
                    conn.commit();
                    count = 0;
                }
                submitTime += SUBMISSION_DELAY;
                dataId++;
            } catch (SQLException sqlException) {
                sqlException.printStackTrace();
            }
        }
        for (int i = 0; i < reuseLimit; ) {
            random = new Random(System.nanoTime());
            dataId = 1 + random.nextInt(threshold);
            int randomSubmitTime = random.nextInt(submitTime);
            int tasks = MIN_TASKS + random.nextInt(MAX_TASKS - MIN_TASKS);
            int userId = 1 + random.nextInt(QuotaScheduler.NUMBER_OF_USERS);
            for (int j = 0; j < tasks && i < reuseLimit; j++, i++) {
                this.addStat(id++, randomSubmitTime, dataId, datas[dataId - 1], userId);
                if (count++ == 1024) {
                    stat.executeBatch();
                    conn.commit();
                    count = 0;
                }
            }
        }
        this.close();
    }
",0
20336961,13,"    private void generateClassifierForNode(Instances data, Range classes, Random rand, Classifier classifier, Hashtable table) throws Exception {
        int[] indices = classes.getSelection();
        for (int j = indices.length - 1; j > 0; j--) {
            int randPos = rand.nextInt(j + 1);
            int temp = indices[randPos];
            indices[randPos] = indices[j];
            indices[j] = temp;
        }
        int first = indices.length / 2;
        int second = indices.length - first;
        int[] firstInds = new int[first];
        int[] secondInds = new int[second];
        System.arraycopy(indices, 0, firstInds, 0, first);
        System.arraycopy(indices, first, secondInds, 0, second);
        int[] sortedFirst = Utils.sort(firstInds);
        int[] sortedSecond = Utils.sort(secondInds);
        int[] firstCopy = new int[first];
        int[] secondCopy = new int[second];
        for (int i = 0; i < sortedFirst.length; i++) {
            firstCopy[i] = firstInds[sortedFirst[i]];
        }
        firstInds = firstCopy;
        for (int i = 0; i < sortedSecond.length; i++) {
            secondCopy[i] = secondInds[sortedSecond[i]];
        }
        secondInds = secondCopy;
        if (firstInds[0] > secondInds[0]) {
            int[] help = secondInds;
            secondInds = firstInds;
            firstInds = help;
            int help2 = second;
            second = first;
            first = help2;
        }
        m_Range = new Range(Range.indicesToRangeList(firstInds));
        m_Range.setUpper(data.numClasses() - 1);
        Range secondRange = new Range(Range.indicesToRangeList(secondInds));
        secondRange.setUpper(data.numClasses() - 1);
        MakeIndicator filter = new MakeIndicator();
        filter.setAttributeIndex("""" + (data.classIndex() + 1));
        filter.setValueIndices(m_Range.getRanges());
        filter.setNumeric(false);
        filter.setInputFormat(data);
        m_FilteredClassifier = new FilteredClassifier();
        if (data.numInstances() > 0) {
            m_FilteredClassifier.setClassifier(Classifier.makeCopies(classifier, 1)[0]);
        } else {
            m_FilteredClassifier.setClassifier(new weka.classifiers.rules.ZeroR());
        }
        m_FilteredClassifier.setFilter(filter);
        m_classifiers = table;
        if (!m_classifiers.containsKey(getString(firstInds) + ""|"" + getString(secondInds))) {
            m_FilteredClassifier.buildClassifier(data);
            m_classifiers.put(getString(firstInds) + ""|"" + getString(secondInds), m_FilteredClassifier);
        } else {
            m_FilteredClassifier = (FilteredClassifier) m_classifiers.get(getString(firstInds) + ""|"" + getString(secondInds));
        }
        m_FirstSuccessor = new ClassBalancedND();
        if (first == 1) {
            m_FirstSuccessor.m_Range = m_Range;
        } else {
            RemoveWithValues rwv = new RemoveWithValues();
            rwv.setInvertSelection(true);
            rwv.setNominalIndices(m_Range.getRanges());
            rwv.setAttributeIndex("""" + (data.classIndex() + 1));
            rwv.setInputFormat(data);
            Instances firstSubset = Filter.useFilter(data, rwv);
            m_FirstSuccessor.generateClassifierForNode(firstSubset, m_Range, rand, classifier, m_classifiers);
        }
        m_SecondSuccessor = new ClassBalancedND();
        if (second == 1) {
            m_SecondSuccessor.m_Range = secondRange;
        } else {
            RemoveWithValues rwv = new RemoveWithValues();
            rwv.setInvertSelection(true);
            rwv.setNominalIndices(secondRange.getRanges());
            rwv.setAttributeIndex("""" + (data.classIndex() + 1));
            rwv.setInputFormat(data);
            Instances secondSubset = Filter.useFilter(data, rwv);
            m_SecondSuccessor = new ClassBalancedND();
            m_SecondSuccessor.generateClassifierForNode(secondSubset, secondRange, rand, classifier, m_classifiers);
        }
    }
",1
12628703,13,"    public static Graph stressTest(int numFields, int numNodes, int numEdges) {
        final MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
        final Random random = new Random(System.currentTimeMillis());
        final Graph graph = new Graph();
        final Attributes attr = new Attributes(""TestNodeType"");
        final EdgeType et = new EdgeType(""TestEdgeType"", ""TestNodeType"", ""TestNodeType"");
        long timer;
        long[] mem, mem2;
        cleanMem(mbean);
        mem = getMemory(mbean);
        timer = System.currentTimeMillis();
        attr.add(new AttributeKey(""Name""));
        for (int f = 0; f < numFields; f++) attr.add(new AttributeContinuous(""Field"" + f));
        graph.addAttributes(attr);
        graph.addEdgeType(et);
        mem2 = getMemory(mbean);
        log.info(""Constructed Attributes container: "" + attr + lineSeparator + ""Attribute setup took: "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"" + lineSeparator + ""Memory change heap: "" + printableBytes(mem2[0] - mem[0]) + "" nonheap: "" + printableBytes(mem2[1] - mem[1]));
        cleanMem(mbean);
        mem = getMemory(mbean);
        timer = System.currentTimeMillis();
        final double[] results = new double[attr.attributeCount()];
        for (int n = 0; n < numNodes; n++) {
            final Node node = graph.addNode(""Node"" + n, attr);
            for (int r = 0; r < results.length; r++) results[r] = random.nextDouble();
            node.setValues(results);
            if (STRESS_DEBUG) System.err.println(""Created node <"" + node + '>');
            if (n % 200000 == 0 && n > 0) log.config(""Created "" + n + "" Nodes in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"");
        }
        mem2 = getMemory(mbean);
        log.info(""Created "" + numNodes + "" Nodes in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"" + lineSeparator + ""Memory change heap: "" + printableBytes(mem2[0] - mem[0]) + "" nonheap: "" + printableBytes(mem2[1] - mem[1]));
        cleanMem(mbean);
        mem = getMemory(mbean);
        timer = System.currentTimeMillis();
        for (int e = 0; e < numEdges; e++) {
            final Node n1 = graph.getNode(random.nextInt(numNodes));
            final Node n2 = graph.getNode(random.nextInt(numNodes));
            graph.addEdge(et, n1, n2, 1.0);
            if (STRESS_DEBUG) System.err.println(""Connected         ["" + n1.getName() + ""]["" + n2.getName() + ""] weight+=1.0"" + "" edgeType="" + et.getName());
            if (e % 250000 == 0 && e > 0) log.config(""Created "" + e + "" Edges in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"");
        }
        mem2 = getMemory(mbean);
        log.info(""Created "" + numEdges + "" Edges in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"" + lineSeparator + ""Memory change heap: "" + printableBytes(mem2[0] - mem[0]) + "" nonheap: "" + printableBytes(mem2[1] - mem[1]));
        final int[] nodeIndexes = new int[numNodes];
        for (int i = 0; i < nodeIndexes.length; i++) nodeIndexes[i] = i;
        for (int i = nodeIndexes.length; --i > 0; ) {
            final int swapidx = random.nextInt(i + 1);
            final int tmp = nodeIndexes[i];
            if (false) System.err.println(""Swapping nodeIndexes["" + i + ""]="" + nodeIndexes[i] + "" and NodeIndexes["" + swapidx + ""]="" + nodeIndexes[swapidx]);
            nodeIndexes[i] = nodeIndexes[swapidx];
            nodeIndexes[swapidx] = tmp;
        }
        if (false) {
            System.err.print(""Getting Nodes in order:"");
            for (int i : nodeIndexes) System.err.print("" "" + i);
            System.err.println();
        }
        cleanMem(mbean);
        mem = getMemory(mbean);
        timer = System.currentTimeMillis();
        final int maxIter = 100;
        for (int count = 0; count < maxIter; count++) {
            for (int i = 0; i < numNodes; i++) {
                final Node node = graph.getNode(nodeIndexes[i]);
                final Edge[] neighborEdges = node.getEdges();
                for (int f = 0; f < numFields; f++) {
                    double result = node.getValue(f);
                    for (final Edge edge : neighborEdges) {
                        result += edge.getDest().getValue(f);
                        result += edge.getWeight();
                    }
                }
            }
            log.config(""Completed loop "" + count + "" in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"");
        }
        mem2 = getMemory(mbean);
        log.info(""Completed ("" + maxIter + ""x) accessing "" + numNodes + "" Nodes in "" + (System.currentTimeMillis() - timer) / 1000.0 + "" secs"" + lineSeparator + ""Memory change heap: "" + printableBytes(mem2[0] - mem[0]) + "" nonheap: "" + printableBytes(mem2[1] - mem[1]));
        log.info(""SUCCESS: Graph got "" + graph.numNodes() + "" Nodes and "" + graph.numEdges() + "" (actual) Edges"");
        return graph;
    }
",1
7279295,13,"    public StringBuffer createUserKey(String username, String password) {
        StringBuffer sb = new StringBuffer();
        String rvalue = ""no"";
        String sql = """";
        String rusername = """";
        String ruserfullname = """";
        String rkey = """";
        String tkey = """";
        int userid = 0;
        Random rand = new Random();
        for (int i = 0; i < 5; i++) {
            int j = rand.nextInt();
            int n = 30;
            j = rand.nextInt(n + 1);
            tkey = tkey + j;
        }
        try {
            con = getConnection();
            if (con != null) {
                stmt = con.createStatement();
                Statement stmt1 = con.createStatement();
                sql = ""SELECT userid, firstname, lastname FROM usdms_users WHERE email='"" + username + ""' AND password = '"" + password + ""'"";
                rs = stmt.executeQuery(sql);
                String key1 = """";
                if (rs.next()) {
                    rusername = username;
                    ruserfullname = rs.getString(""firstname"") + "" "" + rs.getString(""lastname"");
                    userid = rs.getInt(""userid"");
                    sql = ""SELECT userid FROM usdms_user_keys WHERE userid ="" + userid;
                    rs = stmt.executeQuery(sql);
                    if (rs.next()) {
                        rkey = tkey;
                        sql = ""UPDATE usdms_user_keys SET userkey='"" + rkey + ""' WHERE userid ="" + userid;
                    } else {
                        rkey = tkey;
                        sql = ""INSERT INTO usdms_user_keys VALUES ("" + userid + "",'"" + rkey + ""')"";
                    }
                    stmt1.executeUpdate(sql);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } catch (NullPointerException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (rkey.length() > 0) rvalue = ""yes"";
        sb.append(""<username>"");
        sb.append(rusername);
        sb.append(""</username>"");
        sb.append(""<key>"");
        sb.append(rkey);
        sb.append(""</key>"");
        sb.append(""<rvalue>"");
        sb.append(rvalue);
        sb.append(""</rvalue>"");
        sb.append(""<usernamefullname>"");
        sb.append(ruserfullname);
        sb.append(""</usernamefullname>"");
        return sb;
    }
",1
8001809,13,"    public Simulator(String[] args) {
        super(""simulator"" + theirPopulation);
        int numpoints = Integer.parseInt(args[0]);
        int minseconds = Integer.parseInt(args[1]);
        int maxseconds = Integer.parseInt(args[2]);
        System.out.println(""Simulator: Will create "" + numpoints + "" dummy points"");
        for (int i = 0; i < numpoints; i++) {
            String[] names = { ""dummy."" + i };
            String[] empty = { ""-"" };
            String[] transaction = { ""Generic-\""simulator"" + theirPopulation + ""\"""" };
            String[] translation = { ""NumDecimals-\""2\"""" };
            String[] arch = { ""-"" };
            int period = minseconds + itsRandom.nextInt(maxseconds - minseconds);
            PointDescription pd = PointDescription.factory(names, ""Dummy "" + i, ""Dummy"" + i, """", ""sim"" + theirPopulation, transaction, empty, translation, empty, arch, """" + period + ""000000"", ""-1"", true);
            pd.populateServerFields();
        }
        theirPopulation++;
    }
",1
8227926,13,"    Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
19752106,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",0
479569,13,"    public DSoCService(int MaximumNumberOfSegmentation) {
        MAX_NUMBER_OF_SES = MaximumNumberOfSegmentation;
        Random rand = new Random();
        int RandNum = rand.nextInt(MAX_NUMBER_OF_SES + 1);
        NUMBER_OF_SES = (RandNum < 3) ? 3 : RandNum;
        hx_SES = new SES[NUMBER_OF_SES];
        sx_SES = new SES[NUMBER_OF_SES];
        NumberFormat nf = NumberFormat.getInstance();
        nf.setMinimumIntegerDigits(4);
        nf.setMaximumIntegerDigits(4);
        str_Name = ""Service"" + nf.format((long) NameSec);
        NameSec++;
        init_SESs();
    }
",1
11256091,13,"    private long getIdealLocation(IntervalSet neededBytes, long blockSize) {
        int fragmentCount = neededBytes.getNumberOfIntervals();
        if (fragmentCount >= MAX_FRAGMENTS) {
            int randomFragmentNumber = pseudoRandom.nextInt(fragmentCount + 1);
            if (randomFragmentNumber == fragmentCount) return neededBytes.getLast().getHigh() + 1; else return (neededBytes.getAllIntervalsAsList().get(randomFragmentNumber)).getLow();
        } else {
            return getRandomLocation(neededBytes.getFirst().getLow(), neededBytes.getLast().getHigh(), blockSize);
        }
    }
",1
15102847,13,"        void reset(Random random) {
            rfqAverageNumber = rfqAvgMin + random.nextInt(rfqAvgMax - rfqAvgMin);
        }
",1
1928246,13,"    protected void makeNewInterval() {
        Random randNumber = new Random();
        int string = randNumber.nextInt(6);
        int fret = randNumber.nextInt(13);
        rootMidi = FretboardObject.convertPostionToMidiNote(fret, string);
        intervalMidi = 0;
        while ((rootMidi + currentInterval) > 76) {
            string = randNumber.nextInt(6);
            fret = randNumber.nextInt(13);
            rootMidi = FretboardObject.convertPostionToMidiNote(fret, string);
        }
        switch(string) {
            case 0:
                fretboardG.positionDot(FretboardObject.convertIntToFret(fret), FretboardObject.convertIntToString(string));
                fretboardG.positionSecondDot(FretboardObject.convertIntToFret(fret + currentInterval), FretboardObject.convertIntToString(string));
                intervalMidi = rootMidi + currentInterval;
                break;
            default:
                int string2 = randNumber.nextInt(string + 1);
                String intervalNote = FretboardObject.convertPostionToString(fret + currentInterval, string);
                int fret2 = 0;
                while (!(FretboardObject.convertPostionToString(fret2, string2).equals(intervalNote)) || (FretboardObject.convertPostionToMidiNote(fret2, string2) < rootMidi)) {
                    fret2++;
                    if (fret2 > 12) {
                        string2--;
                        fret2 = 0;
                    }
                }
                intervalMidi = FretboardObject.convertPostionToMidiNote(fret2, string2);
                fretboardG.positionDot(FretboardObject.convertIntToFret(fret), FretboardObject.convertIntToString(string));
                fretboardG.positionSecondDot(FretboardObject.convertIntToFret(fret2), FretboardObject.convertIntToString(string2));
                break;
        }
        playNotes(rootMidi, intervalMidi);
    }
",1
4477236,13,"    private Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) fc = 255;
        if (bc > 255) bc = 255;
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
22801754,13,"    private void generateHauptlinie(Random rnd) {
        final int O = 3;
        final int B = 10;
        final int A = 17;
        final int F = 21;
        final int G = 21;
        final int K = 17;
        final int M = 10;
        final int L = 1;
        int wert = rnd.nextInt(100) + 1;
        wert = wert - L;
        if (wert <= 0) {
            starclass = STAR_TYP_L;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_L + 1);
            return;
        }
        wert = wert - O;
        if (wert <= 0) {
            starclass = STAR_TYP_O;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_O + 1);
            return;
        }
        wert = wert - B;
        if (wert <= 0) {
            starclass = STAR_TYP_B;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_B + 1);
            return;
        }
        wert = wert - A;
        if (wert <= 0) {
            starclass = STAR_TYP_A;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_A + 1);
            return;
        }
        wert = wert - F;
        if (wert <= 0) {
            starclass = STAR_TYP_F;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_F + 1);
            return;
        }
        wert = wert - G;
        if (wert <= 0) {
            starclass = STAR_TYP_G;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_G + 1);
            return;
        }
        wert = wert - K;
        if (wert <= 0) {
            starclass = STAR_TYP_K;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_K + 1);
            return;
        }
        wert = wert - M;
        if (wert <= 0) {
            starclass = STAR_TYP_M;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_M + 1);
            return;
        }
    }
",1
22801753,13,"    private void generateRoteRiese(Random rnd) {
        final int BIG = 30;
        final int NORMAL = 30;
        final int LITTLE = 30;
        int wert = rnd.nextInt(100) + 1;
        wert = wert - BIG;
        if (wert <= 0) {
            starclass = STAR_TYP_RIESE_0;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_R0 + 1);
            return;
        }
        wert = wert - NORMAL;
        if (wert <= 0) {
            starclass = STAR_TYP_RIESE_1;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_R1 + 1);
            return;
        }
        wert = wert - LITTLE;
        if (wert <= 0) {
            starclass = STAR_TYP_RIESE_2;
            planetcount = rnd.nextInt(MAX_PLANETS_STAR_TYP_R2 + 1);
            return;
        }
    }
",1
6310113,13,"    private Color getRandColor(int fc, int bc) {
        int fc_a = fc;
        int bc_a = bc;
        Random random = new Random();
        if (fc > 255) fc_a = 255;
        if (bc > 255) bc_a = 255;
        int r = fc + random.nextInt(bc_a - fc_a);
        int g = fc + random.nextInt(bc_a - fc_a);
        int b = fc + random.nextInt(bc_a - fc_a);
        return new Color(r, g, b);
    }
",0
9598420,13,"    public static Integer generateRandomInt(int upperLimit, boolean unique) {
        Integer randomInteger = null;
        if (unique) {
            do {
                randomInteger = generator.nextInt(upperLimit + 1);
            } while (set.contains(randomInteger));
            set.add(randomInteger);
        } else {
            randomInteger = generator.nextInt(upperLimit + 1);
        }
        return randomInteger;
    }
",1
5037689,13,"    private void workForRandomPeriod(int minDuration, int maxDuration) {
        Random random = new Random();
        int period = minDuration + random.nextInt(maxDuration - minDuration);
        long start = Process.getElapsedCpuTime();
        while (Process.getElapsedCpuTime() - start < period) {
            for (int i = 0, temp = 0; i < 50; i++) {
                temp += i;
            }
        }
    }
",0
11355676,13,"    public void init() {
        Random random = new Random();
        for (int i = 0; i < numPlayers; ++i) {
            int x;
            int y;
            do {
                x = 1 + random.nextInt(size - 1);
                y = 1 + random.nextInt(size - 1);
            } while (alreadyPicked(i, x, y));
            playerCoords[i] = new SectorCoords(x, y);
        }
    }
",1
9414360,13,"    private static void testForRemovalStress(Class<? extends ExtendedSet<Integer>> c) {
        ExtendedSet<Integer> previousBits = empty(c);
        ExtendedSet<Integer> currentBits = empty(c);
        TreeSet<Integer> currentItems = new TreeSet<Integer>();
        Random rnd = new MersenneTwister();
        currentBits.add((1 << MatrixIntSet.COL_POW) * 5 - 1);
        currentBits.complement();
        currentItems.addAll(currentBits);
        if (currentItems.size() != (1 << MatrixIntSet.COL_POW) * 5 - 1) {
            System.out.println(""Unexpected error!"");
            System.out.println(currentBits.size());
            System.out.println(currentItems.size());
            return;
        }
        for (int i = 0; i < 100000 & !currentBits.isEmpty(); i++) {
            int item = rnd.nextInt(10000 + 1);
            previousBits = currentBits;
            currentBits = currentBits.clone();
            System.out.format(""Removing %d...\n"", item);
            boolean itemExistsBefore = currentItems.contains(item);
            boolean itemRemoved = currentItems.remove(item);
            boolean itemExistsAfter = currentItems.contains(item);
            boolean bitExistsBefore = currentBits.contains(item);
            boolean bitRemoved = currentBits.remove(item);
            boolean bitExistsAfter = currentBits.contains(item);
            if (itemRemoved ^ bitRemoved) {
                System.out.println(""wrong remove() result"");
                return;
            }
            if (itemExistsBefore ^ bitExistsBefore) {
                System.out.println(""wrong contains() before"");
                return;
            }
            if (itemExistsAfter ^ bitExistsAfter) {
                System.out.println(""wrong contains() after"");
                return;
            }
            if (!checkContent(currentBits, currentItems)) {
                System.out.println(""remove() error"");
                System.out.println(""Same elements: "" + (currentItems.toString().equals(currentBits.toString())));
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            ExtendedSet<Integer> otherBits = empty(c);
            otherBits.addAll(currentItems);
            if (otherBits.hashCode() != currentBits.hashCode()) {
                System.out.println(""Representation error"");
                System.out.println(currentBits.debugInfo());
                System.out.println(otherBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
            ExtendedSet<Integer> singleBitSet = empty(c);
            singleBitSet.add(item);
            if (currentItems.size() != currentBits.differenceSize(singleBitSet)) {
                System.out.println(""Size error"");
                System.out.println(""Original: "" + currentItems);
                System.out.println(currentBits.debugInfo());
                System.out.println(previousBits.debugInfo());
                return;
            }
        }
        System.out.println(""Final"");
        System.out.println(currentBits.debugInfo());
        System.out.println();
        System.out.println(IntSetStatistics.summary());
    }
",1
5024007,13,"    public synchronized net.sourceforge.huntforgold.model.Ship createShip(int index, int nationality) {
        net.sourceforge.huntforgold.xml.Ship result = (net.sourceforge.huntforgold.xml.Ship) shipMap.get(new Integer(index));
        if (result != null) {
            counter = counter + 1;
            int uniqueId = counter;
            String name = result.getName();
            String pngImage = result.getPngImage();
            int typicalCrew = result.getTypicalCrew();
            int maxCrew = result.getMaxCrew();
            int maxCargo = result.getMaxCargo();
            int maxHitPoints = result.getMaxHitPoints();
            int maxSpeed = result.getMaxSpeed();
            int typicalCannons = result.getTypicalCannons();
            int maxCannons = result.getMaxCannons();
            double turnSpeed = result.getTurnSpeed();
            net.sourceforge.huntforgold.model.Ship ship = new net.sourceforge.huntforgold.model.Ship(uniqueId, name, pngImage, typicalCrew, maxCrew, maxCargo, maxHitPoints, maxSpeed, typicalCannons, maxCannons, turnSpeed, nationality);
            int crew = random.nextInt(maxCrew + 1);
            if (crew < 8) {
                crew = 8;
            }
            ship.setCrew(crew);
            ship.setCaptain(""Enemy captain"");
            ship.setFood(0);
            ship.setGoods(0);
            ship.setSugar(0);
            int cannons = random.nextInt(maxCannons + 1);
            if (cannons % 2 == 1) {
                cannons -= 1;
            }
            ship.setCannons(cannons);
            int gold = random.nextInt(51) * 20;
            ship.setGold(gold);
            return ship;
        } else {
            return null;
        }
    }
",1
19466131,13,"    private static Color getRandColor(int fc, int bc) {
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + RandomUtil.nextInt(bc - fc);
        int g = fc + RandomUtil.nextInt(bc - fc);
        int b = fc + RandomUtil.nextInt(bc - fc);
        return new Color(r, g, b);
    }
",1
5540027,13,"    private static int buildDeadEnds(int x0, int maxLength) {
        int floor = height - 2 - globalRandom.nextInt(2);
        int length = 0;
        int preDeadEndLength = 7 + globalRandom.nextInt(10);
        int rHeight = floor - 1;
        int separatorY = 3 + globalRandom.nextInt(rHeight - 7);
        length += buildStraight(x0, preDeadEndLength, true, floor, INFINITE_FLOOR_HEIGHT);
        if (globalRandom.nextInt(3) == 0 && isLadder) {
            int ladderX = x0 + globalRandom.nextInt(length - 1) + 1;
            if (ladderX > x0 + length) ladderX = x0 + length;
            buildLadder(ladderX, floor, floor - separatorY);
        } else buildBlocks(x0, x0 + preDeadEndLength, floor, true, 0, 0, true, true);
        globalRandom.nextInt();
        int k = globalRandom.nextInt(5);
        boolean direction = globalRandom.nextInt(k + 1) != 1;
        int separatorHeight = 2 + globalRandom.nextInt(2);
        int nx = x0 + length;
        int depth = globalRandom.nextInt(levelDifficulty + 1) + 2 * (1 + levelDifficulty);
        if (depth + length > maxLength) {
            while (depth + length > maxLength - 1) {
                depth--;
            }
        }
        int tLength = 0;
        int bSpace = floor - (separatorY + separatorHeight);
        if (bSpace < 4) {
            while (bSpace < 4) {
                separatorY -= 1;
                bSpace = floor - (separatorY + separatorHeight);
            }
        }
        int wallWidth = 2 + globalRandom.nextInt(3);
        while (tLength < depth) {
            tLength += buildZone(nx + tLength, depth - tLength, separatorY - 1, separatorY, separatorHeight);
        }
        tLength = 0;
        while (tLength < depth) {
            tLength += buildZone(nx + tLength, depth - tLength, bSpace, floor, INFINITE_FLOOR_HEIGHT);
        }
        boolean wallFromBlocks = false;
        for (int x = nx; x < nx + depth; x++) {
            for (int y = 0; y < height; y++) {
                if (x - nx >= depth - wallWidth) {
                    if (direction) {
                        if (y <= separatorY) {
                            if (wallFromBlocks) level.setBlock(x, y, (byte) (0 + 1 * 16)); else level.setBlock(x, y, (byte) (1 + 9 * 16));
                        }
                    } else {
                        if (y >= separatorY) {
                            if (wallFromBlocks) level.setBlock(x, y, (byte) (0 + 1 * 16)); else level.setBlock(x, y, (byte) (1 + 9 * 16));
                        }
                    }
                }
            }
        }
        return length + tLength;
    }
",1
17800886,13,"    public void testIsSameBits() {
        Random rand = new Random(0L);
        for (int size = 0; size < 100; size++) {
            int[] ints = new int[(size + 7) / 8];
            IntArrayBitWriter w = new IntArrayBitWriter(ints, size);
            for (int i = 0; i < size; i++) w.writeBoolean(rand.nextBoolean());
            IntArrayBitReader r = new IntArrayBitReader(ints, size);
            IntArrayBitReader s = new IntArrayBitReader(ints, size);
            assertTrue(BitStreams.isSameBits(r, s));
            r.setPosition(0);
            s.setPosition(0);
            assertTrue(BitStreams.isSameBits(r, s));
            if (size > 0) {
                s.setPosition(0);
                int[] tints = ints.clone();
                int bit = rand.nextInt(size);
                int index = bit >> 5;
                int mask = 1 << (31 - (bit & 31));
                tints[index] ^= mask;
                IntArrayBitReader t = new IntArrayBitReader(tints, size);
                assertFalse(BitStreams.isSameBits(s, t));
                s.setPosition(0);
                t.setPosition(0);
                assertFalse(BitStreams.isSameBits(t, s));
                if (size > 2) {
                    int sub = 1 + rand.nextInt(size - 1);
                    s.setPosition(0);
                    t = new IntArrayBitReader(ints, size - sub);
                    assertFalse(BitStreams.isSameBits(s, t));
                    s.setPosition(0);
                    t.setPosition(0);
                    assertFalse(BitStreams.isSameBits(t, s));
                }
            }
        }
    }
",1
12409601,13,"    @Override
    protected void setUp() throws Exception {
        super.setUp();
        context = new ContextStack();
        List<String> randomStrings = new ArrayList<String>();
        Random random = new Random();
        for (int i = 0, num = random.nextInt(100); i < num; ++i) {
            int minChar = 32, maxChar = 126;
            int stringSize = random.nextInt(30);
            StringBuilder buf = new StringBuilder();
            for (int j = 0; j < stringSize; ++j) {
                int charId = minChar + random.nextInt(maxChar - minChar);
                buf.append((char) charId);
            }
            randomStrings.add(buf.toString());
        }
        context.put(""name"", ""Tom"");
        context.put(""randomStrings"", randomStrings);
        context.put(""intArray"", intArray);
        context.put(""intList"", TemplateUtils.objectToCollection(intArray));
        context.put(""doubleArray"", doubleArray);
        context.put(""doubleList"", TemplateUtils.objectToCollection(doubleArray));
    }
",1
19828158,13,"    public void buildClassifier(Instances data) throws Exception {
        getCapabilities().testWithFail(data);
        data = new Instances(data);
        data.deleteWithMissingClass();
        Random random = data.getRandomNumberGenerator(m_Seed);
        if (!m_hashtablegiven) {
            m_classifiers = new Hashtable();
        }
        int[] indices = new int[data.numClasses()];
        for (int i = 0; i < indices.length; i++) {
            indices[i] = i;
        }
        for (int i = indices.length - 1; i > 0; i--) {
            int help = indices[i];
            int index = random.nextInt(i + 1);
            indices[i] = indices[index];
            indices[index] = help;
        }
        m_ndtree = new NDTree();
        m_ndtree.insertClassIndexAtNode(indices[0]);
        for (int i = 1; i < indices.length; i++) {
            int nodeIndex = random.nextInt(2 * i - 1);
            NDTree node = m_ndtree.locateNode(nodeIndex, new int[1]);
            node.insertClassIndex(indices[i]);
        }
        m_ndtree.unifyTree();
        buildClassifierForNode(m_ndtree, data);
    }
",0
11866933,13,"    public void doSomething() {
        String clientIdentifier = this.getClientIdentifier();
        if (!this.isRegisteredAtCoordinator()) {
            try {
                this.registerAtCoordinator();
            } catch (ParticipantException e) {
                System.out.println(""ConcreteService1 exception: "" + e.getLocalizedMessage());
            }
        }
        Random randomGenerator = new Random();
        int r = randomGenerator.nextInt(PROCESSINGTIME_MAX + 1);
        long sleepTimeMilli = 1000;
        if (r < PROCESSINGTIME_MIN) {
            sleepTimeMilli *= PROCESSINGTIME_MIN;
        } else {
            sleepTimeMilli *= r;
        }
        try {
            Thread.sleep(sleepTimeMilli);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        r = randomGenerator.nextInt(101);
        if (r <= FAILURE_PROBABILITY) {
            System.out.println(""Concrete Service 1 - Request failed: "" + clientIdentifier);
            try {
                MessageContext messageContext = MessageContext.getCurrentContext();
                Message request = messageContext.getRequestMessage();
                AttributedURI messageID = HeaderProcessing.getMessageID(request);
                this.sendFault(""Internal service error. The request could not be processed correctly."", messageID);
            } catch (Exception e) {
                System.out.println(""ConcreteService1 exception: "" + e.getLocalizedMessage());
            }
            StatisticsManager.getInstance().addFinishedService(false);
        } else {
            StatisticsManager.getInstance().addFinishedService(true);
        }
    }
",1
17989783,13,"    private static Color getRandColor(int fc, int bc) {
        Random random = new Random();
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int red = fc + random.nextInt(bc - fc);
        int green = fc + random.nextInt(bc - fc);
        int blue = fc + random.nextInt(bc - fc);
        return new Color(red, green, blue);
    }
",1
2973245,13,"    public static long[][] getBinomialDistribution(int min, int max, long total) {
        Random rand = new Random(System.currentTimeMillis());
        int n = max - min;
        long[][] ret = new long[2][n + 1];
        int mean = (n + 1) / 2;
        float p = 1;
        if (n > 0) {
            p = (float) mean / (float) n;
        }
        long count = 0;
        for (int i = 0; i <= n; i++) {
            double p_i = MathUtil.combination(n, i) * Math.pow(p, i) * Math.pow((1 - p), (n - i));
            long count_i = (long) (total * p_i);
            ret[0][i] = i + min;
            ret[1][i] = count_i;
            count += count_i;
        }
        while (count < total) {
            int i = rand.nextInt(n + 1);
            ret[1][i]++;
            count++;
        }
        return ret;
    }
",1
7305283,13,"    public Vector makeCorridor(int x, int y, byte direction, int max_length) throws Exception {
        Vector v = new Vector();
        int r;
        v.x = x;
        v.y = y;
        if (direction == Individual.EAST) {
            if (x + max_length > SIZE - 1) {
                max_length = SIZE - x - 1;
            }
        } else if (direction == Individual.SOUTH) {
            if (y + max_length > SIZE - 1) {
                max_length = SIZE - y - 1;
            }
        } else if (direction == Individual.WEST) {
            if (x - max_length < 0) {
                max_length = x - 1;
            }
        } else if (direction == Individual.NORTH) {
            if (y - max_length < 0) {
                max_length = y - 1;
            }
        }
        if (direction == Individual.EAST) {
            int count = 0;
            if (max_length > 2) r = 2 + rand.nextInt(max_length - 2); else r = max_length;
            do {
                v.x += 1;
                this.writeCase(EMPTY_FIELD, v.x, v.y);
                count++;
            } while (count < r);
        }
        if (direction == Individual.WEST) {
            int count = 0;
            if (max_length > 2) r = 2 + rand.nextInt(max_length - 2); else r = max_length;
            do {
                v.x -= 1;
                this.writeCase(EMPTY_FIELD, v.x, v.y);
                count++;
            } while (count < r);
        }
        if (direction == Individual.NORTH) {
            int count = 0;
            if (max_length > 2) r = 2 + rand.nextInt(max_length - 2); else r = max_length;
            do {
                v.y -= 1;
                this.writeCase(EMPTY_FIELD, v.x, v.y);
                count++;
            } while (count < r);
        }
        if (direction == Individual.SOUTH) {
            int count = 0;
            if (max_length > 2) r = 2 + rand.nextInt(max_length - 2); else r = max_length;
            do {
                v.y += 1;
                this.writeCase(EMPTY_FIELD, v.x, v.y);
                count++;
            } while (count < r);
        }
        if (v.y == SIZE - 2) {
            v.y += 1;
            this.writeCase(EMPTY_FIELD, v.x, v.y);
        } else if (v.x == SIZE - 2) {
            v.x += 1;
            this.writeCase(EMPTY_FIELD, v.x, v.y);
        } else if (v.y == 1) {
            v.y -= 1;
            this.writeCase(EMPTY_FIELD, v.x, v.y);
        } else if (v.x == 1) {
            v.x -= 1;
            this.writeCase(EMPTY_FIELD, v.x, v.y);
        }
        return v;
    }
",1
14485003,13,"        private ZoomInfo createRandomZoomInfo() {
            int angle = MIN_ROTATION + RANDOM.nextInt(MAX_ROTATION - MIN_ROTATION);
            if (RANDOM.nextBoolean()) {
                angle = -angle;
            }
            final float offsetX = MIN_OFFSET + RANDOM.nextFloat() * (MAX_OFFSET - MIN_OFFSET);
            final float offsetY = MIN_OFFSET + RANDOM.nextFloat() * (MAX_OFFSET - MIN_OFFSET);
            int driftAngle = (int) (Math.atan2(offsetY, offsetX) * 180 / Math.PI);
            return new ZoomInfo(MIN_SCALE + RANDOM.nextFloat() * (MAX_SCALE - MIN_SCALE), offsetX, offsetY, angle, RANDOM.nextBoolean(), DRIFT_AMOUNT, DRIFT_TIME, driftAngle);
        }
",0
5093132,13,"    public static int getRandomNum(int startNum, int endNum) {
        int randomNum = 0;
        try {
            SecureRandom rnd = new SecureRandom();
            do {
                randomNum = rnd.nextInt(endNum + 1);
            } while (randomNum < startNum);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return randomNum;
    }
",1
2884218,13,"    public static XTrace createTrace(int minLength, int maxLength) {
        XTrace trace = factory.createTrace();
        addAttributes(trace, 0.9, 3, 50);
        int length = minLength + random.nextInt(maxLength - minLength);
        for (int i = 0; i < length; i++) {
            trace.add(createEvent());
        }
        NUM_TRACES++;
        return trace;
    }
",1
8008369,13,"    private Object generateValue(int parentLevel) {
        int maxValueType = V_ARRAY;
        if (parentLevel >= maxLevel && nodeCount >= minNodeCount) maxValueType = V_NULL;
        int valueType = random.nextInt(maxValueType + 1);
        nodeCount++;
        switch(valueType) {
            case V_STRING:
                return generateString();
            case V_INT:
                return generateInt();
            case V_DOUBLE:
                return generateDouble();
            case V_BOOLEAN:
                return generateBoolean();
            case V_NULL:
                return null;
            case V_OBJECT:
                return generateObjectMeta(parentLevel + 1);
            case V_ARRAY:
                return generateArrayMeta(parentLevel + 1);
        }
        return null;
    }
",0
5272381,13,"    public void generate(int SEsize, int type) throws Exception {
        this.createDatabase();
        int[] quotas = new int[QuotaScheduler.NUMBER_OF_USERS];
        int quota = SEsize / QuotaScheduler.NUMBER_OF_USERS;
        int newQuota = quota + (quota * 70) / 100;
        int diffQuota = quota - (quota * 30) / 100;
        int id = 1;
        int count = 0;
        int dataId = 1;
        try {
            while (true) {
                random = new Random(System.nanoTime());
                int userId = 1 + random.nextInt(QuotaScheduler.NUMBER_OF_USERS);
                int tasks = MIN_TASKS + random.nextInt(MAX_TASKS - MIN_TASKS);
                int submitTime = 0 + random.nextInt(90000);
                int dataSize = MIN_DATA_SIZE + random.nextInt(MAX_DATA_SIZE - MIN_DATA_SIZE);
                taskfor: for (int i = 0; i < tasks; i++) {
                    int userQuota = quotas[userId - 1];
                    switch(type) {
                        case 1:
                            if (userQuota < quota && quota - userQuota >= dataSize) {
                                this.addStat(id++, submitTime, dataId, dataSize, userId);
                            } else {
                                break taskfor;
                            }
                            break;
                        case 2:
                            if (userQuota < newQuota && newQuota - userQuota >= dataSize) {
                                this.addStat(id++, submitTime, dataId, dataSize, userId);
                            } else {
                                break taskfor;
                            }
                            break;
                        case 3:
                            if (userId == 1) {
                                if (userQuota < newQuota && newQuota - userQuota >= dataSize) {
                                    this.addStat(id++, submitTime, dataId, dataSize, userId);
                                } else {
                                    break taskfor;
                                }
                            } else if (userQuota < diffQuota && diffQuota - userQuota >= dataSize) {
                                this.addStat(id++, submitTime, dataId, dataSize, userId);
                            } else {
                                break taskfor;
                            }
                            break;
                    }
                }
                if (count++ >= 1024) {
                    stat.executeBatch();
                    conn.commit();
                    count = 0;
                }
                quotas[userId - 1] += dataSize;
                dataId++;
                boolean finished = true;
                finishFor: for (int i = 0; i < QuotaScheduler.NUMBER_OF_USERS; i++) {
                    switch(type) {
                        case 1:
                            if (quotas[i] < quota - MIN_DATA_SIZE) {
                                finished = false;
                                break finishFor;
                            }
                            break;
                        case 2:
                            if (quotas[i] < newQuota - MIN_DATA_SIZE) {
                                finished = false;
                                break finishFor;
                            }
                            break;
                        case 3:
                            if (i == 0 && quotas[0] < newQuota - MAX_DATA_SIZE) {
                                finished = false;
                                break finishFor;
                            } else if (quotas[i] < diffQuota - MAX_DATA_SIZE) {
                                finished = false;
                                break finishFor;
                            }
                            break;
                    }
                }
                if (finished) {
                    break;
                }
            }
        } catch (SQLException sqlException) {
            sqlException.printStackTrace();
        }
        this.close();
    }
",1
2884219,13,"    public static XLog createLog(int minTraces, int maxTraces, int minTraceLength, int maxTraceLength) {
        XLog log = factory.createLog();
        addAttributes(log, 0.9, 3, 50);
        int length = minTraces + random.nextInt(maxTraces - minTraces);
        for (int i = 0; i < length; i++) {
            log.add(createTrace(minTraceLength, maxTraceLength));
        }
        return log;
    }
",1
1181596,13,"    private boolean generateSubElements(File root, int depth) {
        int subElementsNumber = random.nextInt(maxSubElements + 1);
        if (depth > 0) {
            for (int i = 1; i <= subElementsNumber; i++) {
                if (random.nextInt(100) >= 50) {
                    if (!generateFile(root)) {
                        return false;
                    }
                    if (--elementsNumber <= 0) {
                        return true;
                    }
                } else {
                    if (!generateDir(root, generateName(), depth - 1)) {
                        return false;
                    }
                }
            }
        } else {
            for (int i = 1; i <= subElementsNumber; i++) {
                if (!generateFile(root)) {
                    return false;
                }
                if (--elementsNumber <= 0) {
                    return true;
                }
            }
        }
        return true;
    }
",1
2408138,13,"    public static int getRandomNum(int startNum, int endNum) {
        int randomNum = 0;
        try {
            SecureRandom rnd = new SecureRandom();
            do {
                randomNum = rnd.nextInt(endNum + 1);
            } while (randomNum < startNum);
        } catch (Exception e) {
            Logger.getLogger(EgovStringUtil.class).debug(e);
        }
        return randomNum;
    }
",0
2403,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
2747,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
7762,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
10733,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
12936,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
13477,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
28136,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
28335,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
45592,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
53657,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
53723,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
59201,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
63418,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
65494,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
80862,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
103830,44,"    public static void main(String[] args) {
        Hashtable nueva = new Hashtable();
        nueva.put('A', 'A');
        nueva.put('E', '3');
        nueva.put('H', 'H');
        nueva.put('I', 'I');
        nueva.put('J', 'L');
        nueva.put('L', 'J');
        nueva.put('M', 'M');
        nueva.put('O', 'O');
        nueva.put('S', '2');
        nueva.put('T', 'T');
        nueva.put('U', 'U');
        nueva.put('V', 'V');
        nueva.put('W', 'W');
        nueva.put('X', 'X');
        nueva.put('Y', 'Y');
        nueva.put('Z', '5');
        nueva.put('1', '1');
        nueva.put('2', 'S');
        nueva.put('3', 'E');
        nueva.put('5', 'Z');
        nueva.put('8', '8');
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line = """";
        boolean palin;
        boolean mirror;
        try {
            while ((line = br.readLine()) != null) {
                palin = isPalindrome(line);
                mirror = isMirrorString(line, nueva);
                if (!palin && !mirror) {
                    System.out.println(line + "" -- is not a palindrome.\n"");
                }
                if (!palin && mirror) {
                    System.out.println(line + "" -- is a mirrored string.\n"");
                }
                if (palin && !mirror) {
                    System.out.println(line + "" -- is a regular palindrome.\n"");
                }
                if (palin && mirror) {
                    System.out.println(line + "" -- is a mirrored palindrome.\n"");
                }
            }
        } catch (IOException ex) {
            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
",1
106154,44,"    public static boolean isPalindrome(BigInteger number) {
        return number.toString().equals(new StringBuffer(number.toString()).reverse().toString());
    }
",1
106155,44,"    public static boolean isLychrel(BigInteger number) {
        BigInteger numberTemp = number;
        for (int i = 0; i < 50; i++) {
            BigInteger sum = numberTemp.add(new BigInteger(new StringBuffer(numberTemp.toString()).reverse().toString()));
            if (isPalindrome(sum)) {
                System.out.println(number + "" "" + sum);
                return false;
            } else {
                numberTemp = sum;
            }
        }
        return true;
    }
",1
111979,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
116120,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
120779,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
124389,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
128027,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
128737,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
136069,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
136939,44,"    public static void main(String[] args) {
        String line = readLn();
        while (line != null) {
            int i = process(line);
            System.out.println(""The string '"" + line + ""' contains "" + i + "" palindromes."");
            line = readLn();
        }
    }
",1
136940,44,"    private static int process(String line) {
        HashMap<String, String> isPalindrome = new HashMap<String, String>();
        for (int k = 0; k < line.length(); k++) {
            for (int j = k + 1; j <= line.length(); j++) {
                String sub = line.substring(k, j);
                if (isPalindrome.get(sub) == null) {
                    if (isPalindrome(sub)) {
                        isPalindrome.put(sub, sub);
                    }
                }
            }
        }
        return isPalindrome.size();
    }
",1
147669,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
147994,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
157747,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
157779,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
160206,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
162829,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
165908,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
174088,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
177744,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
187829,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
193054,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
193561,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
202152,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
202243,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
203114,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
207272,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
211686,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
217751,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
224088,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
227073,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
230247,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
234584,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
235427,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
238321,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
241852,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
242006,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
244234,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
245666,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
250689,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
259444,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
278440,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
279856,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
281238,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
281393,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
286790,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
292891,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
296923,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
298518,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
299390,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
305473,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
311167,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
314562,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
334119,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
345909,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
351291,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
353069,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
357577,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
359837,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
361552,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
370548,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
379081,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
383566,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
396829,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
403117,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
428051,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
454282,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
454858,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
461152,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
469062,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
469342,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
473027,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
474317,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
487414,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
489467,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
497857,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
512228,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
513247,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
518707,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
520194,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
531921,44,"    public static void main(String[] args) {
        int largestPalindrome = 0;
        for (int i = 100; i < 1000; i++) {
            for (int j = 100; j < 1000; j++) {
                int product = i * j;
                if (isPalindrome(String.valueOf(product))) {
                    System.out.println(product);
                    if (product > largestPalindrome) {
                        largestPalindrome = product;
                    }
                }
            }
        }
        System.out.println(largestPalindrome);
    }
",1
541802,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
546907,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
563745,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
590961,44,"    private static void process(String line) {
        StringBuffer sb = new StringBuffer();
        for (int k = 0; k < line.length(); k++) {
            char c = line.charAt(k);
            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
                if ((c >= 'a' && c <= 'z')) {
                    int n = c - 'a';
                    c = (char) (n + 'A');
                }
                sb.append(c);
            }
        }
        if (isPalindrome(sb.toString())) {
            System.out.println(""You won't be eaten!"");
        } else {
            System.out.println(""Uh oh.."");
        }
    }
",1
592518,44,"    public void testIsPalindrome() {
        System.out.println(""isPalindrome"");
        assertEquals(Algorithms.isPalindrome(""A""), true);
        assertEquals(Algorithms.isPalindrome(""BA""), false);
        assertEquals(Algorithms.isPalindrome(""BB""), true);
        assertEquals(Algorithms.isPalindrome(""BAB""), true);
        assertEquals(Algorithms.isPalindrome(""BAA""), false);
        assertEquals(Algorithms.isPalindrome(""ABB""), false);
    }
",1
605830,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
631363,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
640610,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
646741,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
652691,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
661981,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
670346,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
673503,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
681080,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
682347,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
689533,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
694025,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
695352,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
695791,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
714207,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
718538,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
725502,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
739815,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
741290,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
745912,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
748155,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
755768,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
775736,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
776781,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
789020,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
801170,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
801888,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
812841,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
820540,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
820623,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
821504,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
843065,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
847424,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
853458,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
858383,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
863589,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
881840,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
891391,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
892628,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
910480,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
910690,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
911775,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
912098,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
913384,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
916275,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
927502,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
928485,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
932293,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
935196,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
935810,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",0
936425,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
939306,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
946512,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
947102,44,"    public void testPalindrome() {
        assertFalse(isPalindrome(""abcdef""));
        assertFalse(isPalindrome(""abccda""));
        assertTrue(isPalindrome(""abccba""));
        assertFalse(isPalindrome(""abcxba""));
        assertTrue(isPalindrome(""a""));
        assertTrue(isPalindrome(""aa""));
        assertFalse(isPalindrome(""ab""));
        assertTrue(isPalindrome(""""));
        assertTrue(isPalindrome(""aaa""));
        assertTrue(isPalindrome(""aba""));
        assertTrue(isPalindrome(""abbba""));
        assertTrue(isPalindrome(""abba""));
        assertFalse(isPalindrome(""abbaa""));
        assertFalse(isPalindrome(""abcda""));
    }
",1
950312,44,"    public static void main(String[] args) {
        int cases = Integer.parseInt(readLn1());
        for (int caseNumber = 0; caseNumber < cases; caseNumber++) {
            System.out.println(""Case #"" + (caseNumber + 1) + "":"");
            String line = readLn();
            int k = (int) Math.sqrt(line.length());
            if (k * k != line.length()) System.out.print(""No magic :(""); else {
                if (!checkPalindrome(line)) {
                    System.out.print(""No magic :("");
                } else {
                    StringBuilder sb = new StringBuilder();
                    for (int j = 0; j < k; j++) {
                        for (int l = 0; l < k; l++) {
                            sb.append(line.charAt(l * k + j));
                        }
                    }
                    if (!sb.toString().equals(line)) {
                        System.out.print(""No magic :("");
                    } else {
                        System.out.print(k);
                    }
                }
            }
            System.out.println();
        }
    }
",1
2044209,44,"    protected void collectSites(RestrictionEnzyme re, Vector new_positions, Vector all_positions, int strand) {
        int match_cnt = new_positions.size();
        for (int i = 0; i < match_cnt; i++) {
            int[] match_positions = (int[]) new_positions.elementAt(i);
            int cut_count = all_positions.size();
            boolean palindrome = false;
            for (int j = 0; j < cut_count && !palindrome; j++) {
                CutSite cutsite = (CutSite) all_positions.elementAt(j);
                palindrome = (match_positions[0] == cutsite.getLow() && match_positions[1] == cutsite.getHigh());
            }
            if (!palindrome) {
                CutSite match = (strand == 1 ? new CutSite(match_positions[0], match_positions[1], re) : new CutSite(match_positions[1], match_positions[0], re));
                match.setRefSequence(re.getRefSequence());
                all_positions.add(match);
                SeqFeatureUtil.sort(all_positions, 1);
            }
        }
    }
",1
3868944,44,"    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        FifteenEight.blank(""Is \""radar\"" a palindrome, True or False? "" + isPalindrome(""radar""));
        FifteenEight.blank();
        FifteenEight.blank(""Is \""dogs and cats\"" a palindrome, True or False? "" + isPalindrome(""dogs and cats""));
        FifteenEight.blank();
        FifteenEight.blank(""Please enter a word or phrase to check for palindromishness: "");
        String temp = (in.readLine());
        if (isPalindrome(temp) == false) FifteenEight.blank(""That is not a palindrome.""); else FifteenEight.blank(""Yes! That is a palindrome!"");
        FifteenEight.blank();
        FifteenEight.blank(""Thank you for playing! eop."");
    }
",1
4750695,44,"    protected void createJobScriptAndConfigurationFiles(FileWriter writer) throws Exception {
        BarcodeDesignerTask barcodeDesignerTask = (BarcodeDesignerTask) task;
        BarcodeDesignResultNode tmpResultNode = (BarcodeDesignResultNode) resultFileNode;
        File configFile = new File(getSGEConfigurationDirectory() + File.separator + CONFIG_PREFIX + ""1"");
        boolean fileSuccess = configFile.createNewFile();
        if (!fileSuccess) {
            throw new ServiceException(""Unable to create a config file for the 16S pipeline."");
        }
        File tmpConfigFile = new File(tmpResultNode.getDirectoryPath() + File.separator + ""454Barcode.config"");
        FileWriter configWriter = new FileWriter(tmpConfigFile);
        try {
            configWriter.write(""[Barcode_Rules]\n"");
            configWriter.write(""barcodeLength="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_barcodeLength) + ""\n"");
            configWriter.write(""fivePrimeClamp="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_fivePrimeClamp) + ""\n"");
            configWriter.write(""maxFlows="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_maxFlows) + ""\n"");
            configWriter.write(""flowSequence="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_flowSequence) + ""\n"");
            configWriter.write(""keyChar="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_keyChar) + ""\n"");
            configWriter.write(""minEditDistance="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_minEditDistance) + ""\n\n"");
            configWriter.write(""[Barcode_wPrimer_Rules]\n"");
            configWriter.write(""palindromeBin="" + SystemConfigurationProperties.getString(""BarcodeDesign.PalindromeBin"") + ""\n"");
            configWriter.write(""minPalindromeHBonds="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_minPalindromeHBonds) + ""\n"");
            configWriter.write(""maxPalindromeMateDistance="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_maxPalindromeMateDistance) + ""\n"");
            configWriter.write(""palindromeTempDirectory="" + SystemConfigurationProperties.getString(""BarcodeDesign.PalindromeTempDir"") + ""\n"");
            configWriter.write(""intDimerMaxScore="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_intDimerMaxScore) + ""\n"");
            configWriter.write(""endDimerMaxScore="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_endDimerMaxScore) + ""\n\n"");
            configWriter.write(""[Synthesis_Requirements]\n"");
            configWriter.write(""forwardPrimerAdapterSequence="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_forwardPrimerAdapterSequence) + ""\n"");
            configWriter.write(""reversePrimerAdapterSequence="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_reversePrimerAdapterSequence) + ""\n"");
            configWriter.write(""attachBarcodeToForwardPrimer="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_attachBarcodeToForwardPrimer) + ""\n"");
            configWriter.write(""attachBarcodeToReversePrimer="" + barcodeDesignerTask.getParameter(BarcodeDesignerTask.PARAM_attachBarcodeToReversePrimer) + ""\n"");
        } finally {
            configWriter.flush();
            configWriter.close();
        }
        String perlPath = SystemConfigurationProperties.getString(""Perl.Path"");
        String basePath = SystemConfigurationProperties.getString(""Perl.ModuleBase"");
        String pipelineCmd = perlPath + "" "" + basePath + SystemConfigurationProperties.getString(""BarcodeDesign.Cmd"");
        SystemConfigurationProperties properties = SystemConfigurationProperties.getInstance();
        String tmpDirectoryName = properties.getProperty(""Upload.ScratchDir"");
        List<String> inputPrimerFiles = Task.listOfStringsFromCsvString(task.getParameter(BarcodeDesignerTask.PARAM_primerFile));
        List<String> inputAmpliconFiles = Task.listOfStringsFromCsvString(task.getParameter(BarcodeDesignerTask.PARAM_ampliconsFile));
        String fullCmd = pipelineCmd + "" -c "" + tmpConfigFile.getAbsolutePath() + "" -p "" + tmpDirectoryName + File.separator + inputPrimerFiles.get(0) + "" -a "" + tmpDirectoryName + File.separator + inputAmpliconFiles.get(0) + "" -o "" + tmpResultNode.getDirectoryPath() + "" -n "" + task.getParameter(BarcodeDesignerTask.PARAM_numBarcodesPerPrimerPair);
        StringBuffer script = new StringBuffer();
        fullCmd = ""export PATH=$PATH:"" + basePath + "";export PERL5LIB=$PERL5LIB:"" + basePath + "";"" + fullCmd;
        script.append(fullCmd).append(""\n"");
        writer.write(script.toString());
        setJobIncrementStop(1);
    }
",1
6465770,44,"    public void testIsPalindrome() {
        assertTrue(PalindromeChecker.test(""123321""));
        assertFalse(PalindromeChecker.test(""123421""));
        assertTrue(PalindromeChecker.test(""1234321""));
        assertTrue(PalindromeChecker.test(""racecar""));
    }
",1
6465771,44,"    public void testReverse() {
        assertEquals(""dog"", PalindromeChecker.reverse(""god""));
    }
",1
6917038,44,"    private Hashtable setupLabels() {
        Hashtable labels = new Hashtable();
        labels.put(""file"", GT._(""&File""));
        labels.put(""newwin"", GT._(""New""));
        labels.put(""open"", GT._(""&Open""));
        labels.put(""openurl"", GT._(""Open &URL""));
        labels.put(""script"", GT._(""Scrip&t...""));
        labels.put(""atomsetchooser"", GT._(""AtomSetChooser...""));
        labels.put(""saveas"", GT._(""&Save As...""));
        labels.put(""exportMenu"", GT._(""&Export""));
        labels.put(""export"", GT._(""Export Image...""));
        labels.put(""povray"", GT._(""Render in pov-ray...""));
        labels.put(""pdf"", GT._(""Export PDF...""));
        labels.put(""print"", GT._(""&Print...""));
        labels.put(""close"", GT._(""Close""));
        labels.put(""exit"", GT._(""E&xit""));
        labels.put(""recentFiles"", GT._(""Recent Files...""));
        labels.put(""edit"", GT._(""&Edit""));
        labels.put(""makecrystal"", GT._(""Make crystal...""));
        labels.put(""selectall"", GT._(""Select All""));
        labels.put(""deselectall"", GT._(""Deselect All""));
        labels.put(""copyImage"", GT._(""Copy Image""));
        labels.put(""prefs"", GT._(""&Preferences...""));
        labels.put(""editSelectAllScript"", GT._(""Select All""));
        labels.put(""selectMenu"", GT._(""Select""));
        labels.put(""selectAllScript"", GT._(""All""));
        labels.put(""selectNoneScript"", GT._(""None""));
        labels.put(""selectHydrogenScript"", GT._(""Hydrogen""));
        labels.put(""selectCarbonScript"", GT._(""Carbon""));
        labels.put(""selectNitrogenScript"", GT._(""Nitrogen""));
        labels.put(""selectOxygenScript"", GT._(""Oxygen""));
        labels.put(""selectPhosphorusScript"", GT._(""Phosphorus""));
        labels.put(""selectSulphurScript"", GT._(""Sulphur""));
        labels.put(""selectAminoScript"", GT._(""Amino""));
        labels.put(""selectNucleicScript"", GT._(""Nucleic""));
        labels.put(""selectWaterScript"", GT._(""Water""));
        labels.put(""selectHeteroScript"", GT._(""Hetero""));
        labels.put(""display"", GT._(""&Display""));
        labels.put(""atomMenu"", GT._(""Atom""));
        labels.put(""atomNoneScript"", GT._(""None""));
        labels.put(""atom15Script"", GT._(""{0}% vanderWaals"", new Object[] { ""15"" }));
        labels.put(""atom20Script"", GT._(""{0}% vanderWaals"", new Object[] { ""20"" }));
        labels.put(""atom25Script"", GT._(""{0}% vanderWaals"", new Object[] { ""25"" }));
        labels.put(""atom100Script"", GT._(""{0}% vanderWaals"", new Object[] { ""100"" }));
        labels.put(""bondMenu"", GT._(""Bond""));
        labels.put(""bondNoneScript"", GT._(""None""));
        labels.put(""bondWireframeScript"", GT._(""Wireframe""));
        labels.put(""bond100Script"", GT._(""{0} Å"", new Object[] { ""0.10"" }));
        labels.put(""bond150Script"", GT._(""{0} Å"", new Object[] { ""0.15"" }));
        labels.put(""bond200Script"", GT._(""{0} Å"", new Object[] { ""0.20"" }));
        labels.put(""labelMenu"", GT._(""Label""));
        labels.put(""labelNoneScript"", GT._(""None""));
        labels.put(""labelSymbolScript"", GT._(""Symbol""));
        labels.put(""labelNameScript"", GT._(""Name""));
        labels.put(""labelNumberScript"", GT._(""Number""));
        labels.put(""labelCenteredScript"", GT._(""Centered""));
        labels.put(""labelUpperRightScript"", GT._(""Upper right""));
        labels.put(""vectorMenu"", GT._(""Vector""));
        labels.put(""vectorOffScript"", GT._(""None""));
        labels.put(""vectorOnScript"", GT._(""On""));
        labels.put(""vector3Script"", GT._(""{0} pixels"", new Object[] { ""3"" }));
        labels.put(""vector005Script"", GT._(""{0} Å"", new Object[] { ""0.05"" }));
        labels.put(""vector01Script"", GT._(""{0} Å"", new Object[] { ""0.1"" }));
        labels.put(""vectorScale02Script"", GT._(""Scale {0}"", new Object[] { ""0.2"" }));
        labels.put(""vectorScale05Script"", GT._(""Scale {0}"", new Object[] { ""0.5"" }));
        labels.put(""vectorScale1Script"", GT._(""Scale {0}"", new Object[] { ""1"" }));
        labels.put(""vectorScale2Script"", GT._(""Scale {0}"", new Object[] { ""2"" }));
        labels.put(""vectorScale5Script"", GT._(""Scale {0}"", new Object[] { ""5"" }));
        labels.put(""zoomMenu"", GT._(""Zoom""));
        labels.put(""zoom100Script"", GT._(""{0}%"", new Object[] { ""100"" }));
        labels.put(""zoom150Script"", GT._(""{0}%"", new Object[] { ""150"" }));
        labels.put(""zoom200Script"", GT._(""{0}%"", new Object[] { ""200"" }));
        labels.put(""zoom400Script"", GT._(""{0}%"", new Object[] { ""400"" }));
        labels.put(""zoom800Script"", GT._(""{0}%"", new Object[] { ""800"" }));
        labels.put(""perspectiveCheck"", GT._(""Perspective Depth""));
        labels.put(""axesCheck"", GT._(""Axes""));
        labels.put(""boundboxCheck"", GT._(""Bounding Box""));
        labels.put(""hydrogensCheck"", GT._(""&Hydrogens""));
        labels.put(""vectorsCheck"", GT._(""&Vectors""));
        labels.put(""measurementsCheck"", GT._(""&Measurements""));
        labels.put(""view"", GT._(""&View""));
        labels.put(""front"", GT._(""Front""));
        labels.put(""top"", GT._(""Top""));
        labels.put(""bottom"", GT._(""Bottom""));
        labels.put(""right"", GT._(""Right""));
        labels.put(""left"", GT._(""Left""));
        labels.put(""transform"", GT._(""Transform...""));
        labels.put(""definecenter"", GT._(""Define Center""));
        labels.put(""tools"", GT._(""&Tools""));
        labels.put(""viewMeasurementTable"", GT._(""Measurements...""));
        labels.put(""distanceUnitsMenu"", GT._(""Distance Units""));
        labels.put(""distanceNanometersScript"", GT._(""Nanometers 1E-9""));
        labels.put(""distanceAngstromsScript"", GT._(""Angstroms 1E-10""));
        labels.put(""distancePicometersScript"", GT._(""Picometers 1E-12""));
        labels.put(""animateMenu"", GT._(""Animate...""));
        labels.put(""vibrateMenu"", GT._(""Vibrate...""));
        labels.put(""graph"", GT._(""&Graph...""));
        labels.put(""chemicalShifts"", GT._(""Calculate chemical &shifts...""));
        labels.put(""crystprop"", GT._(""&Crystal Properties""));
        labels.put(""animateOnceScript"", GT._(""Once""));
        labels.put(""animateLoopScript"", GT._(""Loop""));
        labels.put(""animatePalindromeScript"", GT._(""Palindrome""));
        labels.put(""animateStopScript"", GT._(""Stop animation""));
        labels.put(""animateRewindScript"", GT._(""Rewind to first frame""));
        labels.put(""animateNextScript"", GT._(""Go to next frame""));
        labels.put(""animatePrevScript"", GT._(""Go to previous frame""));
        labels.put(""vibrateStartScript"", GT._(""Start vibration""));
        labels.put(""vibrateStopScript"", GT._(""Stop vibration""));
        labels.put(""vibrateRewindScript"", GT._(""First frequency""));
        labels.put(""vibrateNextScript"", GT._(""Next frequency""));
        labels.put(""vibratePrevScript"", GT._(""Previous frequency""));
        labels.put(""help"", GT._(""&Help""));
        labels.put(""about"", GT._(""About Jmol""));
        labels.put(""uguide"", GT._(""User Guide""));
        labels.put(""whatsnew"", GT._(""What's New""));
        labels.put(""console"", GT._(""Jmol Console""));
        labels.put(""Prefs.showHydrogens"", GT._(""Hydrogens""));
        labels.put(""Prefs.showMeasurements"", GT._(""Measurements""));
        labels.put(""Prefs.perspectiveDepth"", GT._(""Perspective Depth""));
        labels.put(""Prefs.showAxes"", GT._(""Axes""));
        labels.put(""Prefs.showBoundingBox"", GT._(""Bounding Box""));
        labels.put(""Prefs.axesOrientationRasmol"", GT._(""RasMol/Chime compatible axes orientation/rotations""));
        labels.put(""Prefs.openFilePreview"", GT._(""File Preview (needs restarting Jmol)""));
        labels.put(""Prefs.isLabelAtomColor"", GT._(""Use Atom Color""));
        labels.put(""Prefs.isBondAtomColor"", GT._(""Use Atom Color""));
        labels.put(""openTip"", GT._(""Open a file.""));
        labels.put(""exportTip"", GT._(""Export view to an image file.""));
        labels.put(""povrayTip"", GT._(""Render in pov-ray.""));
        labels.put(""printTip"", GT._(""Print view.""));
        labels.put(""rotateTip"", GT._(""Rotate molecule.""));
        labels.put(""pickTip"", GT._(""Select an atom or region.""));
        labels.put(""viewMeasurementTableTip"", GT._(""View measurement table.""));
        labels.put(""homeTip"", GT._(""Return molecule to home position.""));
        labels.put(""animateRewindScriptTip"", GT._(""Rewind to first frame""));
        labels.put(""animateNextScriptTip"", GT._(""Go to next frame""));
        labels.put(""animatePrevScriptTip"", GT._(""Go to previous frame""));
        return labels;
    }
",1
7003180,44,"    @Override
    protected String[] getWordContents() {
        boolean wasTranslating = GT.getDoTranslate();
        GT.setDoTranslate(true);
        String[] words = new String[] { ""modelSetMenu"", GT._(""No atoms loaded""), ""configurationComputedMenu"", GT._(""Configurations""), ""elementsComputedMenu"", GT._(""Element""), ""FRAMESbyModelComputedMenu"", GT._(""Model/Frame""), ""languageComputedMenu"", GT._(""Language""), ""PDBaaResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBnucleicResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBcarboResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBheteroComputedMenu"", GT._(""By HETATM""), ""surfMoComputedMenuText"", GT._(""Molecular Orbitals ({0})""), ""SYMMETRYSelectComputedMenu"", GT._(""Symmetry""), ""SYMMETRYShowComputedMenu"", GT._(""Space Group""), ""SYMMETRYhide"", GT._(""Hide Symmetry""), ""hiddenModelSetText"", GT._(""Model information""), ""selectMenuText"", GT._(""Select ({0})""), ""allModelsText"", GT._(""All {0} models""), ""configurationMenuText"", GT._(""Configurations ({0})""), ""modelSetCollectionText"", GT._(""Collection of {0} models""), ""atomsText"", GT._(""atoms: {0}""), ""bondsText"", GT._(""bonds: {0}""), ""groupsText"", GT._(""groups: {0}""), ""chainsText"", GT._(""chains: {0}""), ""polymersText"", GT._(""polymers: {0}""), ""modelMenuText"", GT._(""model {0}""), ""viewMenuText"", GT._(""View {0}""), ""mainMenuText"", GT._(""Main Menu""), ""biomoleculesMenuText"", GT._(""Biomolecules""), ""biomoleculeText"", GT._(""biomolecule {0} ({1} atoms)""), ""loadBiomoleculeText"", GT._(""load biomolecule {0} ({1} atoms)""), ""selectAll"", GT._(""All""), ""selectNone"", GT._(""None""), ""hideNotSelectedCB"", GT._(""Display Selected Only""), ""invertSelection"", GT._(""Invert Selection""), ""viewMenu"", GT._(""View""), ""front"", GT._(""Front""), ""left"", GT._(""Left""), ""right"", GT._(""Right""), ""top"", TextFormat.split(GT._(""Top[as in \""view from the top, from above\"" - (translators: remove this bracketed part]""), '[')[0], ""bottom"", GT._(""Bottom""), ""back"", GT._(""Back""), ""PDBproteinMenu"", GT._(""Protein""), ""allProtein"", GT._(""All""), ""proteinBackbone"", GT._(""Backbone""), ""proteinSideChains"", GT._(""Side Chains""), ""polar"", GT._(""Polar Residues""), ""nonpolar"", GT._(""Nonpolar Residues""), ""positiveCharge"", GT._(""Basic Residues (+)""), ""negativeCharge"", GT._(""Acidic Residues (-)""), ""noCharge"", GT._(""Uncharged Residues""), ""PDBnucleicMenu"", GT._(""Nucleic""), ""allNucleic"", GT._(""All""), ""DNA"", GT._(""DNA""), ""RNA"", GT._(""RNA""), ""nucleicBackbone"", GT._(""Backbone""), ""nucleicBases"", GT._(""Bases""), ""atPairs"", GT._(""AT pairs""), ""gcPairs"", GT._(""GC pairs""), ""auPairs"", GT._(""AU pairs""), ""PDBheteroMenu"", GT._(""Hetero""), ""allHetero"", GT._(""All PDB \""HETATM\""""), ""Solvent"", GT._(""All Solvent""), ""Water"", GT._(""All Water""), ""nonWaterSolvent"", GT._(""Nonaqueous Solvent"") + "" (solvent and not water)"", ""exceptWater"", GT._(""Nonaqueous HETATM"") + "" (hetero and not water)"", ""Ligand"", GT._(""Ligand""), ""allCarbo"", GT._(""All""), ""PDBcarboMenu"", GT._(""Carbohydrate""), ""PDBnoneOfTheAbove"", GT._(""None of the above""), ""renderMenu"", GT._(""Style""), ""renderSchemeMenu"", GT._(""Scheme""), ""renderCpkSpacefill"", GT._(""CPK Spacefill""), ""renderBallAndStick"", GT._(""Ball and Stick""), ""renderSticks"", GT._(""Sticks""), ""renderWireframe"", GT._(""Wireframe""), ""PDBrenderCartoonsOnly"", GT._(""Cartoon""), ""PDBrenderTraceOnly"", GT._(""Trace""), ""atomMenu"", GT._(""Atoms""), ""atomNone"", GT._(""Off""), ""atom15"", GT._(""{0}% van der Waals"", ""15""), ""atom20"", GT._(""{0}% van der Waals"", ""20""), ""atom25"", GT._(""{0}% van der Waals"", ""25""), ""atom50"", GT._(""{0}% van der Waals"", ""50""), ""atom75"", GT._(""{0}% van der Waals"", ""75""), ""atom100"", GT._(""{0}% van der Waals"", ""100""), ""bondMenu"", GT._(""Bonds""), ""bondNone"", GT._(""Off""), ""bondWireframe"", GT._(""On""), ""bond100"", GT._(""{0} Å"", ""0.10""), ""bond150"", GT._(""{0} Å"", ""0.15""), ""bond200"", GT._(""{0} Å"", ""0.20""), ""bond250"", GT._(""{0} Å"", ""0.25""), ""bond300"", GT._(""{0} Å"", ""0.30""), ""hbondMenu"", GT._(""Hydrogen Bonds""), ""hbondNone"", GT._(""Off""), ""hbondCalc"", GT._(""Calculate""), ""hbondWireframe"", GT._(""On""), ""PDBhbondSidechain"", GT._(""Set H-Bonds Side Chain""), ""PDBhbondBackbone"", GT._(""Set H-Bonds Backbone""), ""hbond100"", GT._(""{0} Å"", ""0.10""), ""hbond150"", GT._(""{0} Å"", ""0.15""), ""hbond200"", GT._(""{0} Å"", ""0.20""), ""hbond250"", GT._(""{0} Å"", ""0.25""), ""hbond300"", GT._(""{0} Å"", ""0.30""), ""ssbondMenu"", GT._(""Disulfide Bonds""), ""ssbondNone"", GT._(""Off""), ""ssbondWireframe"", GT._(""On""), ""PDBssbondSidechain"", GT._(""Set SS-Bonds Side Chain""), ""PDBssbondBackbone"", GT._(""Set SS-Bonds Backbone""), ""ssbond100"", GT._(""{0} Å"", ""0.10""), ""ssbond150"", GT._(""{0} Å"", ""0.15""), ""ssbond200"", GT._(""{0} Å"", ""0.20""), ""ssbond250"", GT._(""{0} Å"", ""0.25""), ""ssbond300"", GT._(""{0} Å"", ""0.30""), ""PDBstructureMenu"", GT._(""Structures""), ""structureNone"", GT._(""Off""), ""backbone"", GT._(""Backbone""), ""cartoon"", GT._(""Cartoon""), ""cartoonRockets"", GT._(""Cartoon Rockets""), ""ribbons"", GT._(""Ribbons""), ""rockets"", GT._(""Rockets""), ""strands"", GT._(""Strands""), ""trace"", GT._(""Trace""), ""VIBRATIONMenu"", GT._(""Vibration""), ""vibrationOff"", GT._(""Off""), ""vibrationOn"", GT._(""On""), ""VIBRATIONvectorMenu"", GT._(""Vectors""), ""spectraMenu"", GT._(""Spectra""), ""hnmrMenu"", GT._(""1H-NMR""), ""cnmrMenu"", GT._(""13C-NMR""), ""vectorOff"", GT._(""Off""), ""vectorOn"", GT._(""On""), ""vector3"", GT._(""{0} pixels"", ""3""), ""vector005"", GT._(""{0} Å"", ""0.05""), ""vector01"", GT._(""{0} Å"", ""0.10""), ""vectorScale02"", GT._(""Scale {0}"", ""0.2""), ""vectorScale05"", GT._(""Scale {0}"", ""0.5""), ""vectorScale1"", GT._(""Scale {0}"", ""1""), ""vectorScale2"", GT._(""Scale {0}"", ""2""), ""vectorScale5"", GT._(""Scale {0}"", ""5""), ""stereoMenu"", GT._(""Stereographic""), ""stereoNone"", GT._(""None""), ""stereoRedCyan"", GT._(""Red+Cyan glasses""), ""stereoRedBlue"", GT._(""Red+Blue glasses""), ""stereoRedGreen"", GT._(""Red+Green glasses""), ""stereoCrossEyed"", GT._(""Cross-eyed viewing""), ""stereoWallEyed"", GT._(""Wall-eyed viewing""), ""labelMenu"", GT._(""Labels""), ""labelNone"", GT._(""None""), ""labelSymbol"", GT._(""With Element Symbol""), ""labelName"", GT._(""With Atom Name""), ""labelNumber"", GT._(""With Atom Number""), ""labelPositionMenu"", GT._(""Position Label on Atom""), ""labelCentered"", GT._(""Centered""), ""labelUpperRight"", GT._(""Upper Right""), ""labelLowerRight"", GT._(""Lower Right""), ""labelUpperLeft"", GT._(""Upper Left""), ""labelLowerLeft"", GT._(""Lower Left""), ""colorMenu"", GT._(""Color""), ""[color_atoms]Menu"", GT._(""Atoms""), ""schemeMenu"", GT._(""By Scheme""), ""cpk"", GT._(""Element (CPK)""), ""altloc#PDB"", GT._(""Alternative Location""), ""molecule"", GT._(""Molecule""), ""formalcharge"", GT._(""Formal Charge""), ""partialcharge#CHARGE"", GT._(""Partial Charge""), ""relativeTemperature#BFACTORS"", GT._(""Temperature (Relative)""), ""fixedTemperature#BFACTORS"", GT._(""Temperature (Fixed)""), ""amino#PDB"", GT._(""Amino Acid""), ""structure#PDB"", GT._(""Secondary Structure""), ""chain#PDB"", GT._(""Chain""), ""group#PDB"", GT._(""Group""), ""monomer#PDB"", GT._(""Monomer""), ""shapely#PDB"", GT._(""Shapely""), ""none"", GT._(""Inherit""), ""black"", GT._(""Black""), ""white"", GT._(""White""), ""cyan"", GT._(""Cyan""), ""red"", GT._(""Red""), ""orange"", GT._(""Orange""), ""yellow"", GT._(""Yellow""), ""green"", GT._(""Green""), ""blue"", GT._(""Blue""), ""indigo"", GT._(""Indigo""), ""violet"", GT._(""Violet""), ""salmon"", GT._(""Salmon""), ""olive"", GT._(""Olive""), ""maroon"", GT._(""Maroon""), ""gray"", GT._(""Gray""), ""slateblue"", GT._(""Slate Blue""), ""gold"", GT._(""Gold""), ""orchid"", GT._(""Orchid""), ""opaque"", GT._(""Make Opaque""), ""translucent"", GT._(""Make Translucent""), ""[color_bonds]Menu"", GT._(""Bonds""), ""[color_hbonds]Menu"", GT._(""Hydrogen Bonds""), ""[color_ssbonds]Menu"", GT._(""Disulfide Bonds""), ""colorPDBStructuresMenu"", GT._(""Structures""), ""[color_backbone]Menu"", GT._(""Backbone""), ""[color_trace]Menu"", GT._(""Trace""), ""[color_cartoon]sMenu"", GT._(""Cartoon""), ""[color_ribbon]sMenu"", GT._(""Ribbons""), ""[color_rockets]Menu"", GT._(""Rockets""), ""[color_strands]Menu"", GT._(""Strands""), ""[color_labels]Menu"", GT._(""Labels""), ""[color_background]Menu"", GT._(""Background""), ""[color_isosurface]Menu"", GT._(""Surfaces""), ""[color_vectors]Menu"", GT._(""Vectors""), ""[color_axes]Menu"", GT._(""Axes""), ""[color_boundbox]Menu"", GT._(""Boundbox""), ""[color_UNITCELL]Menu"", GT._(""Unit cell""), ""zoomMenu"", GT._(""Zoom""), ""zoom50"", ""50%"", ""zoom100"", ""100%"", ""zoom150"", ""150%"", ""zoom200"", ""200%"", ""zoom400"", ""400%"", ""zoom800"", ""800%"", ""zoomIn"", GT._(""Zoom In""), ""zoomOut"", GT._(""Zoom Out""), ""spinMenu"", GT._(""Spin""), ""spinOn"", GT._(""On""), ""spinOff"", GT._(""Off""), ""[set_spin_X]Menu"", GT._(""Set X Rate""), ""[set_spin_Y]Menu"", GT._(""Set Y Rate""), ""[set_spin_Z]Menu"", GT._(""Set Z Rate""), ""[set_spin_FPS]Menu"", GT._(""Set FPS""), ""s0"", ""0"", ""s5"", ""5"", ""s10"", ""10"", ""s20"", ""20"", ""s30"", ""30"", ""s40"", ""40"", ""s50"", ""50"", ""FRAMESanimateMenu"", GT._(""Animation""), ""animModeMenu"", GT._(""Animation Mode""), ""onceThrough"", GT._(""Play Once""), ""palindrome"", GT._(""Palindrome""), ""loop"", GT._(""Loop""), ""play"", GT._(""Play""), ""pause"", GT._(""Pause""), ""resume"", GT._(""Resume""), ""stop"", GT._(""Stop""), ""nextframe"", GT._(""Next Frame""), ""prevframe"", GT._(""Previous Frame""), ""rewind"", GT._(""Rewind""), ""playrev"", GT._(""Reverse""), ""restart"", GT._(""Restart""), ""FRAMESanimFpsMenu"", GT._(""Set FPS""), ""animfps5"", ""5"", ""animfps10"", ""10"", ""animfps20"", ""20"", ""animfps30"", ""30"", ""animfps50"", ""50"", ""measureMenu"", GT._(""Measurements""), ""measureOff"", GT._(""Double-Click begins and ends all measurements""), ""measureDistance"", GT._(""Click for distance measurement""), ""measureAngle"", GT._(""Click for angle measurement""), ""measureTorsion"", GT._(""Click for torsion (dihedral) measurement""), ""PDBmeasureSequence"", GT._(""Click two atoms to display a sequence in the console""), ""measureDelete"", GT._(""Delete measurements""), ""measureList"", GT._(""List measurements""), ""distanceNanometers"", GT._(""Distance units nanometers""), ""distanceAngstroms"", GT._(""Distance units Angstroms""), ""distancePicometers"", GT._(""Distance units picometers""), ""pickingMenu"", GT._(""Set picking""), ""pickOff"", GT._(""Off""), ""pickCenter"", GT._(""Center""), ""pickIdent"", GT._(""Identity""), ""pickLabel"", GT._(""Label""), ""pickAtom"", GT._(""Select atom""), ""PDBpickChain"", GT._(""Select chain""), ""pickElement"", GT._(""Select element""), ""PDBpickGroup"", GT._(""Select group""), ""pickMolecule"", GT._(""Select molecule""), ""SYMMETRYpickSite"", GT._(""Select site""), ""SYMMETRYpickSymmetry"", GT._(""Show symmetry operation""), ""pickSpin"", GT._(""Spin""), ""showMenu"", GT._(""Show""), ""showConsole"", GT._(""Console""), ""showFile"", GT._(""File Contents""), ""showFileHeader"", GT._(""File Header""), ""showHistory"", GT._(""History""), ""showIsosurface"", GT._(""Isosurface JVXL data""), ""showMeasure"", GT._(""Measurements""), ""showMo"", GT._(""Molecular orbital JVXL data""), ""showModel"", GT._(""Model""), ""showOrient"", GT._(""Orientation""), ""showSpacegroup"", GT._(""Space group""), ""SYMMETRYshowSymmetry"", GT._(""Symmetry""), ""showState"", GT._(""Current state""), ""fileMenu"", GT._(""File""), ""reload"", GT._(""Reload""), ""SIGNEDloadPdb"", GT._(""Open from PDB""), ""SIGNEDloadFileOrUrl"", GT._(""Open file or URL""), ""SIGNEDloadFileUnitCell"", GT._(""Load full unit cell""), ""SIGNEDloadScript"", GT._(""Open script""), ""writeFileTextVARIABLE"", GT._(""Save a copy of {0}""), ""writeState"", GT._(""Save script with state""), ""writeHistory"", GT._(""Save script with history""), ""SIGNEDwriteJpg"", GT._(""Export {0} image"", ""JPG""), ""SIGNEDwritePng"", GT._(""Export {0} image"", ""PNG""), ""SIGNEDwritePngJmol"", GT._(""Export {0} image"", ""PNG+JMOL""), ""SIGNEDwriteGif"", GT._(""Export {0} image"", ""GIF""), ""SIGNEDwritePovray"", GT._(""Export {0} image"", ""POV-Ray""), ""SIGNEDwriteJmol"", GT._(""Save all as JMOL file (zip)""), ""SIGNEDwriteIsosurface"", GT._(""Save JVXL isosurface""), ""SIGNEDwriteVrml"", GT._(""Export {0} 3D model"", ""VRML""), ""SIGNEDwriteX3d"", GT._(""Export {0} 3D model"", ""X3D""), ""SIGNEDwriteIdtf"", GT._(""Export {0} 3D model"", ""IDTF""), ""SIGNEDwriteMaya"", GT._(""Export {0} 3D model"", ""Maya""), ""computationMenu"", GT._(""Computation""), ""minimize"", GT._(""Optimize structure""), ""modelkit"", GT._(""Model kit""), ""UNITCELLshow"", GT._(""Unit cell""), ""extractMOL"", GT._(""Extract MOL data""), ""surfaceMenu"", GT._(""Surfaces""), ""surfDots"", GT._(""Dot Surface""), ""surfVDW"", GT._(""van der Waals Surface""), ""surfMolecular"", GT._(""Molecular Surface""), ""surfSolvent14"", GT._(""Solvent Surface ({0}-Angstrom probe)"", ""1.4""), ""surfSolventAccessible14"", GT._(""Solvent-Accessible Surface (VDW + {0} Angstrom)"", ""1.4""), ""CHARGEsurfMEP"", GT._(""Molecular Electrostatic Potential""), ""surfOpaque"", GT._(""Make Opaque""), ""surfTranslucent"", GT._(""Make Translucent""), ""surfOff"", GT._(""Off""), ""FILEUNITMenu"", GT._(""Symmetry""), ""FILEMOLload"", GT._(""Reload {0}"", ""(molecular)""), ""FILEUNITone"", GT._(""Reload {0}"", ""{1 1 1}""), ""FILEUNITnine"", GT._(""Reload {0}"", ""{444 666 1}""), ""FILEUNITnineRestricted"", GT._(""Reload {0} + Display {1}"", new Object[] { ""{444 666 1}"", ""555"" }), ""FILEUNITninePoly"", GT._(""Reload + Polyhedra""), ""[set_axes]Menu"", GT._(""Axes""), ""[set_boundbox]Menu"", GT._(""Boundbox""), ""[set_UNITCELL]Menu"", GT._(""Unit cell""), ""off#axes"", GT._(""Hide""), ""dotted"", GT._(""Dotted""), ""byPixelMenu"", GT._(""Pixel Width""), ""1p"", GT._(""{0} px"", ""1""), ""3p"", GT._(""{0} px"", ""3""), ""5p"", GT._(""{0} px"", ""5""), ""10p"", GT._(""{0} px"", ""10""), ""byAngstromMenu"", GT._(""Angstrom Width""), ""10a"", GT._(""{0} Å"", ""0.10""), ""20a"", GT._(""{0} Å"", ""0.20""), ""25a"", GT._(""{0} Å"", ""0.25""), ""50a"", GT._(""{0} Å"", ""0.50""), ""100a"", GT._(""{0} Å"", ""1.0""), ""showSelectionsCB"", GT._(""Selection Halos""), ""showHydrogensCB"", GT._(""Show Hydrogens""), ""showMeasurementsCB"", GT._(""Show Measurements""), ""perspectiveDepthCB"", GT._(""Perspective Depth""), ""showBoundBoxCB"", GT._(""Boundbox""), ""showAxesCB"", GT._(""Axes""), ""showUNITCELLCB"", GT._(""Unit cell""), ""colorrasmolCB"", GT._(""RasMol Colors""), ""aboutComputedMenu"", GT._(""About...""), ""APPLETjmolUrl"", ""http://www.jmol.org"", ""APPLETmouseManualUrl"", GT._(""Mouse Manual""), ""APPLETtranslationUrl"", GT._(""Translations"") };
        GT.setDoTranslate(wasTranslating);
        return words;
    }
",1
7171043,44,"    @Test
    public void palindromeTest() {
        assertEquals(0, 1 / 2);
        assertTrue(LlqUtil.isPalindrome(""""));
        assertTrue(LlqUtil.isPalindrome(""a""));
        assertTrue(LlqUtil.isPalindrome(""aa""));
        assertTrue(LlqUtil.isPalindrome(""aaa""));
        assertTrue(LlqUtil.isPalindrome(""aaaa""));
        assertTrue(LlqUtil.isPalindrome(""aba""));
        assertTrue(LlqUtil.isPalindrome(""abba""));
        assertTrue(LlqUtil.isPalindrome(""abcba""));
        assertTrue(LlqUtil.isPalindrome(""abccba""));
        assertFalse(LlqUtil.isPalindrome(""ab""));
        assertFalse(LlqUtil.isPalindrome(""abc""));
        assertFalse(LlqUtil.isPalindrome(""abca""));
        assertFalse(LlqUtil.isPalindrome(""abab""));
        assertFalse(LlqUtil.isPalindrome(""abb""));
        assertFalse(LlqUtil.isPalindrome(""abbaa""));
        assertFalse(LlqUtil.isPalindrome(""abcdef""));
    }
",1
8972525,44,"    public static void main(String args[]) {
        String strOne = ""ABCDEEDCBA"";
        String strTwo = ""Madam, I'm Adam."";
        System.out.println(""strOne is palindrome:"" + isPalindrome(strOne));
        System.out.println(""strTwo is palindrome:"" + isPalindrome(strTwo));
    }
",1
9755673,44,"    public int getMaximum(String[] front, int[] back) {
        int N = front.length;
        Item[] items = new Item[N];
        for (int i = 0; i < N; i++) {
            items[i] = new Item(front[i], back[i]);
        }
        Arrays.sort(items);
        int result = 0;
        boolean[] used = new boolean[N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (i != j && !used[i] && !used[j] && isPalindrome(items[i].word + items[j].word)) {
                    used[i] = true;
                    used[j] = true;
                    result += items[i].cost + items[j].cost;
                }
            }
        }
        for (int i = 0; i < N; i++) {
            Item item = items[i];
            if (!used[i] && isPalindrome(item.word)) {
                result += items[i].cost;
                break;
            }
        }
        return result;
    }
",1
9755676,44,"    public static void main(String[] args) {
        ExampleRunner.eq(1, 10, new PalindromeGame().getMaximum(new String[] { ""topcoder"", ""redcoder"", ""redocpot"" }, new int[] { 7, 5, 3 }));
        ExampleRunner.eq(2, 0, new PalindromeGame().getMaximum(new String[] { ""rabbit"" }, new int[] { 1000000 }));
        ExampleRunner.eq(3, 499, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 24, 7, 63, 222, 190 }));
        ExampleRunner.eq(4, 482, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""def"", ""abc"", ""fed"" }, new int[] { 24, 7, 63, 222, 190 }));
        ExampleRunner.eq(5, 1, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 1 }));
        ExampleRunner.eq(6, 24, new PalindromeGame().getMaximum(new String[] { ""xyx"", ""xyx"", ""xyx"", ""zzz"", ""zzz"", ""zzz"" }, new int[] { 5, 7, 2, 1, 6, 4 }));
        ExampleRunner.eq(7, 474854, new PalindromeGame().getMaximum(new String[] { ""aaaaaaaaaaaa"", ""nopalindrome"", ""steponnopets"", ""emordnilapon"", ""aaaaaaaaaaaa"", ""steponnopets"", ""nopalindrome"", ""steponnopets"", ""nopalindrome"", ""bbbbbbbbbbbb"", ""cannotbeused"", ""cannotbeused"", ""steponnopets"", ""aaaaaaaaaaaa"", ""nopalindrome"", ""aaaaaaaaaaaa"", ""nopalindrome"", ""emordnilapon"", ""steponnopets"", ""nopalindrome"" }, new int[] { 4096, 131072, 64, 262144, 512, 1024, 65536, 2048, 32768, 1, 524288, 16384, 32, 4, 16, 2, 8, 128, 8192, 256 }));
        ExampleRunner.eq(8, 0, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydog"" }, new int[] { 1000000 }));
        ExampleRunner.eq(9, 95, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydog"", ""godyzalehtrevospmujxofnworbkciuqeht"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(10, 0, new PalindromeGame().getMaximum(new String[] { ""fhequickbrownfoxjumpsoverthelazydog"", ""godyzalehtrevospmujxofnworbkciuqeht"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(11, 0, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydoq"", ""godyzalehtrevospmujxofnworbkciuqeht"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(12, 0, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydog"", ""qodyzalehtrevospmujxofnworbkciuqeht"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(13, 0, new PalindromeGame().getMaximum(new String[] { ""thequickbrownfoxjumpsoverthelazydog"", ""godyzalehtrevospmujxofnworbkciuqehf"" }, new int[] { 19, 76 }));
        ExampleRunner.eq(14, 499, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(15, 0, new PalindromeGame().getMaximum(new String[] { ""dhiswillbealongpalindromemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(16, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindronemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(17, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromenordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(18, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromemordnilapgnolaeblliwsihd"" }, new int[] { 499 }));
        ExampleRunner.eq(19, 499, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromeemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(20, 0, new PalindromeGame().getMaximum(new String[] { ""phiswillbealongpalindromeemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(21, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromoemordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(22, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromeomordnilapgnolaeblliwsiht"" }, new int[] { 499 }));
        ExampleRunner.eq(23, 0, new PalindromeGame().getMaximum(new String[] { ""thiswillbealongpalindromeemordnilapgnolaeblliwsihp"" }, new int[] { 499 }));
        ExampleRunner.eq(24, 50000000, new PalindromeGame().getMaximum(new String[] { ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""lfctktrygedlpmbooatphlicywlfybdiuaxxogkpeujgeiasft"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""lastcjhxwdxxilxdbxawfaxtkjyfeucaticrrevixwthwwkute"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""etukwwhtwxiverrcitacuefyjktxafwaxbdxlixxdwxhjctsal"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""ixzlnswijawcksnthxwggjsjdznfgrqetphgxmcjofuhyaqobg"", ""ziiavkadexabdiwxhqjbhgyzddzyghbjqhxwidbaxedakvaiiz"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""hjmyuwwkrxnfmqgeebeoapezsdzspmqcxjtgdyxkrpvmwmmpmp"", ""tfsaiegjuepkgoxxauidbyflwycilhptaoobmpldegyrtktcfl"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""pmpmmwmvprkxydgtjxcqmpszdszepaoebeegqmfnxrkwwuymjh"", ""ziiavkadexabdiwxhqjbhgyzddzyghbjqhxwidbaxedakvaiiz"", ""gboqayhufojcmxghpteqrgfnzdjsjggwxhtnskcwajiwsnlzxi"" }, new int[] { 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000 }));
        ExampleRunner.eq(25, 5949, new PalindromeGame().getMaximum(new String[] { ""bptjtizbjdfmukyxxbmileaksskaelimbxxykumfdjbzitjtpb"", ""rbjavldthitldfowirhhruatggtaurhhriwofdltihtdlvajbr"", ""shxbxtidyjofgpqrnabgdknittinkdgbanrqpgfojyditxbxhs"", ""cmfllyppaymgdgfwvvvpjncqhhqcnjpvvvwfgdgmyappyllfmc"", ""xuaukuhwruwvtdajqopxhacjxxjcahxpoqjadtvwurwhukuaux"", ""vqohkuovpmxoxeveypmwbwfziizfwbwmpyevexoxmpvoukhoqv"", ""zedvmxsfhhoslqlukxgoavchvvhcvaogxkulqlsohhfsxmvdez"", ""dvgyloealfpunupqkwlqctlullultcqlwkqpunupflaeolygvd"", ""pliywrbgdwbxvtdlgtxlhahcnnchahlxtgldtvxbwdgbrwyilp"", ""ppkbyxahzbgizpsprwjwiymmxxmmyiwjwrpspzigbzhaxybkpp"", ""iznckjdrhiujhpemagerzwhavvahwzregamephjuihrdjkcnzi"", ""dbqxptyyvxfvicehzhqchghqaaqhghcqhzhecivfxvyytpxqbd"", ""aaigsxhhuvarwdfkpistrdevhhvedrtsipkfdwravuhhxsgiaa"", ""kgomneqlahxgkgcxlhvykmkfllfkmkyvhlxcgkgxhalqenmogk"", ""xyhqrpletzpmpmebilnlhavokkovahlnlibempmpztelprqhyx"", ""alutlssyaxalnmmtxmeeyrubmmburyeemxtmmnlaxayssltula"", ""fjwtavbkqcnaaanhzafpwcsrhhrscwpfazhnaaancqkbvatwjf"", ""jasdhqycfutuswyzyodvpbsxyyxsbpvdoyzywsutufcyqhdsaj"", ""qhuueksvynyimboqjlhdjfhdnndhfjdhljqobmiynyvskeuuhq"", ""wbruxzbvoualqdqlrqdjweupllpuewjdqrlqdqlauovbzxurbw"", ""ityexmrfylrjshcpctlmkswassawskmltcpchsjrlyfrmxeyti"", ""werngnsyixujjtygzizhhycfjjfcyhhzizgytjjuxiysngnrew"", ""kolhcsckjzypplxyblitgphvkkvhpgtilbyxlppyzjkcschlok"", ""jlgpfexzsfhttjklvlbxpacessecapxblvlkjtthfszxefpglj"", ""klbamhvcwhqchtaymjmklckgkkgkclkmjmyathcqhwcvhmablk"", ""lfhpellbxhhukpnktlvuhmmzhhzmmhuvltknpkuhhxbllephfl"", ""rxyqsxuepfcymcegbjsukzzovvozzkusjbgecmycfpeuxsqyxr"", ""lmdvlfxyqrshiswkwozybijujjujibyzowkwsihsrqyxflvdml"", ""pbehptugjdabeyqhxktqyesgzzgseyqtkxhqyebadjgutphebp"", ""lbymvxgkabtqmoktunltddyilliyddtlnutkomqtbakgxvmybl"", ""kcunlniqeissjsfpnmxwcdznaanzdcwxmnpfsjssieqinlnuck"", ""ebufnclmvzqwzwhyxgsgcvmaeeamvcgsgxyhwzwqzvmlcnfube"", ""yeofsydykuvviihkihkvtuzmttmzutvkhikhiivvukydysfoey"", ""jmgmmopcwybediwosomgrnrryyrrnrgmosowidebywcpommgmj"", ""qjbbdsgmomenpbidlntcbwevxxvewbctnldibpnemomgsdbbjq"", ""ujqcthnokczyugjkwgrtmsywbbwysmtrgwkjguyzckonhtcqju"", ""nbocykjrjysvxpxvhbqhtaryggyrathqbhvxpxvsyjrjkycobn"", ""lwvhylvxpxjjtxdatfcrgmtauuatmgrcftadxtjjxpxvlyhvwl"", ""jpnkoqvdcmlbuzyfiyeukznrggrnzkueyifyzublmcdvqoknpj"", ""dbgcnntfjdyfjzvwuaycisxhjjhxsicyauwvzjfydjftnncgbd"", ""xcylfwhgwqhxefrgbnozadmsiismdazonbgrfexhqwghwflycx"", ""grqwyonfygheejgbtfoljycwwwwcyjloftbgjeehgyfnoywqrg"", ""ygckjbbrpxizzpyjifokscekzzkecskofijypzzixprbbjkcgy"", ""skyeyftvldfdgvqvxcbietaxffxateibcxvqvgdfdlvtfyeyks"", ""ovzvklydseowcevrstbbeyhgjjghyebbtsrvecwoesdylkvzvo"", ""eattvzichqilhfydzpfkqyquaauqyqkfpzdyfhliqhcizvttae"", ""vhsfkwdopjawpuosgtgtbxpfhhfpxbtgtgsoupwajpodwkfshv"", ""nfnizinzdduumtnkwiybfvugllguvfbyiwkntmuuddznizinfn"", ""uzfbzudusdawgvftkgkszmupccpumzskgktfvgwadsuduzbfzu"", ""zivihsufyoxsdvbeqojhugerhhreguhjoqebvdsxoyfushiviz"" }, new int[] { 3530, 4030, 1276, 4088, 3075, 3861, 1366, 2181, 3283, 3353, 4611, 4688, 5093, 2999, 1579, 5323, 4052, 4931, 616, 1822, 5209, 5200, 5949, 1531, 3436, 3357, 2676, 1999, 2938, 3105, 863, 1705, 177, 5458, 1276, 3137, 5779, 3530, 479, 4236, 5909, 180, 3780, 174, 5410, 4598, 1390, 3192, 2276, 437 }));
        ExampleRunner.eq(26, 34956, new PalindromeGame().getMaximum(new String[] { ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"", ""vtampzmroiijokmzbxsqpclkmmklcpqsxbzmkojiiormzpmatv"" }, new int[] { 427, 756, 992, 241, 370, 692, 621, 723, 989, 587, 994, 284, 660, 531, 1022, 707, 597, 840, 308, 597, 840, 681, 242, 992, 421, 1021, 943, 681, 621, 810, 640, 1022, 840, 958, 692, 663, 588, 835, 876, 663, 810, 513, 707, 979, 694, 958, 274, 421, 733, 900 }));
        ExampleRunner.eq(27, 0, new PalindromeGame().getMaximum(new String[] { ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"", ""efiezjynivqjmbgcmmmylpdqvkfdbqiybegqcbieyyphjoasqx"" }, new int[] { 76229, 227374, 133120, 84094, 230319, 154315, 223494, 251667, 166774, 245312, 172504, 67485, 75771, 139727, 230319, 154315, 230351, 253235, 288866, 184067, 302578, 193146, 139727, 144578, 231766, 308253, 262335, 230228, 144578, 153813, 227374, 184067, 210948, 227930, 186982, 363168, 302578, 288866, 338220, 193146, 317461, 212743, 313755, 318635, 200688, 26395, 270839, 251667, 105055, 266022 }));
        ExampleRunner.eq(28, 902, new PalindromeGame().getMaximum(new String[] { ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""tpekppxqtpigriasudscmlwxbbaaeoxxcnyepmsmrylafawlsv"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"", ""vslwafalyrmsmpeyncxxoeaabbxwlmcsdusairgiptqxppkept"" }, new int[] { 1, 5, 8, 10, 42, 38, 36, 33, 48, 28, 26, 36, 25, 43, 50, 16, 31, 5, 36, 24, 20, 36, 39, 39, 34, 26, 31, 6, 34, 15, 21, 20, 32, 31, 11, 8, 41, 16, 29, 30, 47, 12, 47, 37, 38, 31, 17, 32, 4, 32 }));
        ExampleRunner.eq(29, 71086, new PalindromeGame().getMaximum(new String[] { ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""lhfmufqdtawfkilsewisiheqvqsfgjdyqxskqnfmbsritrskkd"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"", ""dkksrtirsbmfnqksxqydjgfsqvqehisiweslikfwatdqfumfhl"" }, new int[] { 1861, 2376, 1125, 86, 797, 2613, 2140, 1679, 1421, 2034, 92, 2111, 412, 2445, 772, 628, 23, 249, 1733, 847, 2649, 1239, 2347, 211, 2218, 1111, 1401, 1688, 2406, 397, 2693, 1025, 842, 197, 2670, 2068, 1143, 1769, 2226, 973, 2673, 1767, 738, 750, 920, 213, 1998, 2667, 936, 1707 }));
        ExampleRunner.eq(30, 575048, new PalindromeGame().getMaximum(new String[] { ""mcjqdteeuimiqltjsmjvegkfidgdqpqxjvifarrdmcfayypjcg"", ""ubzirkuiexmubaqytnulztupdawsxrkrfjbzmrehsesssydfls"", ""lkgbuvmsvwwrphxfvnfusvdoonumpwgvubcnwnawhyuntiiivt"", ""cuvbpkbdqxspgwtioefmlvtwwfgpxqgplwhmsobmcahfusqtho"", ""lkgbuvmsvwwrphxfvnfusvdoonumpwgvubcnwnawhyuntiiivt"", ""cuvbpkbdqxspgwtioefmlvtwwfgpxqgplwhmsobmcahfusqtho"", ""lkgbuvmsvwwrphxfvnfusvdoonumpwgvubcnwnawhyuntiiivt"", ""mcjqdteeuimiqltjsmjvegkfidgdqpqxjvifarrdmcfayypjcg"", ""rssovkmhdaskeufcraevaftjzsijkdbczhvcwkzwdbjazpdmxz"", ""wcuzmjojsvalacrvimunavxtmbcmqfjxjnkjebfsvpjryfvtif"", ""najkhodrphvlyrbhfslncfxmpkfnzjmtpdbegxsbhubvwwbskk"", ""gcjpyyafcmdrrafivjxqpqdgdifkgevjmsjtlqimiueetdqjcm"", ""wcgwyvvbmnaozccdcffdqbaqlprtpngyesrlwmjevlnhvvnjhl"", ""tviiitnuyhwanwncbuvgwpmunoodvsufnvfxhprwwvsmvubgkl"", ""hfndgkhltykeqkkdoikiplsoysgvdnrajnlpqavjadehtfpzxz"", ""lhjnvvhnlvejmwlrseygnptrplqabqdffcdcczoanmbvvywgcw"", ""fitvfyrjpvsfbejknjxjfqmcbmtxvanumivrcalavsjojmzucw"", ""slfdyssseshermzbjfrkrxswadputzluntyqabumxeiukrizbu"", ""lkgbuvmsvwwrphxfvnfusvdoonumpwgvubcnwnawhyuntiiivt"", ""ubzirkuiexmubaqytnulztupdawsxrkrfjbzmrehsesssydfls"", ""fitvfyrjpvsfbejknjxjfqmcbmtxvanumivrcalavsjojmzucw"", ""kksbwwvbuhbsxgebdptmjznfkpmxfcnlsfhbrylvhprdohkjan"", ""rssovkmhdaskeufcraevaftjzsijkdbczhvcwkzwdbjazpdmxz"", ""najkhodrphvlyrbhfslncfxmpkfnzjmtpdbegxsbhubvwwbskk"", ""hfndgkhltykeqkkdoikiplsoysgvdnrajnlpqavjadehtfpzxz"", ""ubzirkuiexmubaqytnulztupdawsxrkrfjbzmrehsesssydfls"", ""ubzirkuiexmubaqytnulztupdawsxrkrfjbzmrehsesssydfls"", ""cuvbpkbdqxspgwtioefmlvtwwfgpxqgplwhmsobmcahfusqtho"", ""rssovkmhdaskeufcraevaftjzsijkdbczhvcwkzwdbjazpdmxz"", ""ohtqsufhacmbosmhwlpgqxpgfwwtvlmfeoitwgpsxqdbkpbvuc"", ""wcgwyvvbmnaozccdcffdqbaqlprtpngyesrlwmjevlnhvvnjhl"", ""nfrizjawupejbwtvlhuncilmruhssifycgkmpxqobbxvffnhfv"", ""nfrizjawupejbwtvlhuncilmruhssifycgkmpxqobbxvffnhfv"", ""wcgwyvvbmnaozccdcffdqbaqlprtpngyesrlwmjevlnhvvnjhl"", ""zxzpfthedajvaqplnjarndvgsyoslpikiodkkqekytlhkgdnfh"", ""hfndgkhltykeqkkdoikiplsoysgvdnrajnlpqavjadehtfpzxz"", ""najkhodrphvlyrbhfslncfxmpkfnzjmtpdbegxsbhubvwwbskk"", ""fitvfyrjpvsfbejknjxjfqmcbmtxvanumivrcalavsjojmzucw"", ""hfndgkhltykeqkkdoikiplsoysgvdnrajnlpqavjadehtfpzxz"", ""nfrizjawupejbwtvlhuncilmruhssifycgkmpxqobbxvffnhfv"", ""cuvbpkbdqxspgwtioefmlvtwwfgpxqgplwhmsobmcahfusqtho"", ""fitvfyrjpvsfbejknjxjfqmcbmtxvanumivrcalavsjojmzucw"", ""mcjqdteeuimiqltjsmjvegkfidgdqpqxjvifarrdmcfayypjcg"", ""najkhodrphvlyrbhfslncfxmpkfnzjmtpdbegxsbhubvwwbskk"", ""zxmdpzajbdwzkwcvhzcbdkjiszjtfavearcfueksadhmkvossr"", ""vfhnffvxbboqxpmkgcyfisshurmlicnuhlvtwbjepuwajzirfn"", ""wcgwyvvbmnaozccdcffdqbaqlprtpngyesrlwmjevlnhvvnjhl"", ""rssovkmhdaskeufcraevaftjzsijkdbczhvcwkzwdbjazpdmxz"", ""mcjqdteeuimiqltjsmjvegkfidgdqpqxjvifarrdmcfayypjcg"", ""nfrizjawupejbwtvlhuncilmruhssifycgkmpxqobbxvffnhfv"" }, new int[] { 35479, 12818, 21951, 7816, 9694, 320, 29268, 21147, 28796, 22306, 21846, 42032, 27962, 39742, 37303, 25620, 23571, 33623, 10552, 29268, 22484, 15191, 18531, 26313, 29336, 15582, 25376, 26489, 26928, 24365, 10905, 10998, 21901, 27943, 24104, 35586, 33310, 24104, 40601, 27062, 29434, 2121, 26928, 21846, 20830, 21951, 8372, 19310, 6194, 21901 }));
        ExampleRunner.eq(31, 3565, new PalindromeGame().getMaximum(new String[] { ""jjnneixpabakgnuvvancfggfcnavvungkabapxiennjj"" }, new int[] { 3565 }));
        ExampleRunner.eq(32, 0, new PalindromeGame().getMaximum(new String[] { ""nzmnxzanbwypdtkamqeemwsbakpcxjcfkdlk"" }, new int[] { 6626 }));
        ExampleRunner.eq(33, 60404, new PalindromeGame().getMaximum(new String[] { ""apwcwpa"", ""apwcwpa"" }, new int[] { 19542, 40862 }));
        ExampleRunner.eq(34, 1038, new PalindromeGame().getMaximum(new String[] { ""kpguhwkvwzrvjrvgppgvrjvrzwvkwhugpk"", ""epkemelzgbcdhqpwxxwpqhdcbgzlemekpe"" }, new int[] { 589, 1038 }));
        ExampleRunner.eq(35, 8867, new PalindromeGame().getMaximum(new String[] { ""prffwfiphkrsaoacuucaoasrkhpifwffrp"", ""qbvvxewxxzwprwxwzdsyvxibsabldfzmgt"" }, new int[] { 8867, 49314 }));
        ExampleRunner.eq(36, 0, new PalindromeGame().getMaximum(new String[] { ""zkxzpofixooclx"", ""zkxzpofixooclx"" }, new int[] { 13480, 13818 }));
        ExampleRunner.eq(37, 219377, new PalindromeGame().getMaximum(new String[] { ""vtplaawtsxovadnvzcgmsnqweamkiaastxbkse"", ""eskbxtsaaikmaewqnsmgczvndavoxstwaalptv"" }, new int[] { 206564, 12813 }));
        ExampleRunner.eq(38, 63723, new PalindromeGame().getMaximum(new String[] { ""xvvenxcbirkjuxr"", ""nzojtskdkstjozn"" }, new int[] { 10894, 63723 }));
        ExampleRunner.eq(39, 0, new PalindromeGame().getMaximum(new String[] { ""lbnqtifwxbgwdtwyrlulgbbictvwpn"", ""dysykadagjmyxsmialibycsdynkual"" }, new int[] { 742, 1843 }));
        ExampleRunner.eq(40, 1357408, new PalindromeGame().getMaximum(new String[] { ""gxsyzyhiqnvzuftfuzvnqihyzysxg"", ""gxsyzyhiqnvzuftfuzvnqihyzysxg"", ""gxsyzyhiqnvzuftfuzvnqihyzysxg"" }, new int[] { 238851, 755008, 363549 }));
        ExampleRunner.eq(41, 95410, new PalindromeGame().getMaximum(new String[] { ""lgzfuzuppsbswenvkkvnewsbsppuzufzgl"", ""lgzfuzuppsbswenvkkvnewsbsppuzufzgl"", ""deqtbzyoctxfodyappaydofxtcoyzbtqed"" }, new int[] { 57108, 25434, 12868 }));
        ExampleRunner.eq(42, 87817, new PalindromeGame().getMaximum(new String[] { ""wzsugerxatesnnsetaxreguszw"", ""wzsugerxatesnnsetaxreguszw"", ""djnboriqnhlnmvemxrlqtmxcls"" }, new int[] { 37791, 50026, 56212 }));
        ExampleRunner.eq(43, 27213, new PalindromeGame().getMaximum(new String[] { ""shhsgdtfadwiubadjeimuycggcyumiejdabuiwdaftdgshhs"", ""nungkwsoivpworqqgynxqssqqssqxnygqqrowpvioswkgnun"", ""shhsgdtfadwiubadjeimuycggcyumiejdabuiwdaftdgshhs"" }, new int[] { 12674, 3574, 10965 }));
        ExampleRunner.eq(44, 317115, new PalindromeGame().getMaximum(new String[] { ""bznvskvwplrezvgiqigvzerlpwvksvnzb"", ""mkkhyjvpizfjeegxhxgeejfzipvjyhkkm"", ""mkkhyjvpizfjeegxhxgeejfzipvjyhkkm"" }, new int[] { 82542, 195879, 38694 }));
        ExampleRunner.eq(45, 121368, new PalindromeGame().getMaximum(new String[] { ""hpcivkfpkwpbijrzukbxgcjjcgxbkuzrjibpwkpfkvicph"", ""zwfcmuqjwjvztvhkdjdreqvvqerdjdkhvtzvjwjqumcfwz"", ""hlcplrstcnkbrshsbyzezjbbjzezybshsrbknctsrlpclh"" }, new int[] { 100511, 69338, 121368 }));
        ExampleRunner.eq(46, 378287, new PalindromeGame().getMaximum(new String[] { ""dieosmjjgsaasgjjmsoeid"", ""qdhpxukhokffkohkuxphdq"", ""ezshxtzieiphpecrwyerbu"" }, new int[] { 378287, 277267, 70267 }));
        ExampleRunner.eq(47, 2658, new PalindromeGame().getMaximum(new String[] { ""zjbcflhwdshsaashsdwhlfcbjz"", ""rztretkxcusbhmckzsgmfzrcff"", ""zjbcflhwdshsaashsdwhlfcbjz"" }, new int[] { 2448, 1503, 210 }));
        ExampleRunner.eq(48, 6236, new PalindromeGame().getMaximum(new String[] { ""zvtgdwxxwdgtvz"", ""jdqfusznfflnha"", ""jdqfusznfflnha"" }, new int[] { 6236, 3738, 15029 }));
        ExampleRunner.eq(49, 16734, new PalindromeGame().getMaximum(new String[] { ""bdjuqwihyqnggnqyhiwqujdb"", ""rytwphmyvtkcrdihmmcpvozx"", ""xzovpcmmhidrcktvymhpwtyr"" }, new int[] { 4948, 8311, 3475 }));
        ExampleRunner.eq(50, 33416, new PalindromeGame().getMaximum(new String[] { ""bmtlupfeoliknonkiloefpultmb"", ""atxwfacwivkztissdirjnxmpusk"", ""pimhenglknuavovaunklgnehmip"" }, new int[] { 3837, 5841, 33416 }));
        ExampleRunner.eq(51, 3059, new PalindromeGame().getMaximum(new String[] { ""sybwstztswbys"", ""nagydkhftghcy"", ""cnwcgnvhdcanb"" }, new int[] { 3059, 16854, 22962 }));
        ExampleRunner.eq(52, 0, new PalindromeGame().getMaximum(new String[] { ""ndozzquvvyjzblzsuynvczkcusvpilineecs"", ""ndozzquvvyjzblzsuynvczkcusvpilineecs"", ""ndozzquvvyjzblzsuynvczkcusvpilineecs"" }, new int[] { 4604, 18894, 26435 }));
        ExampleRunner.eq(53, 8948, new PalindromeGame().getMaximum(new String[] { ""kbfgojlmzccjlhsaydbomssrwpnuosrkmidvpowe"", ""kbfgojlmzccjlhsaydbomssrwpnuosrkmidvpowe"", ""ewopvdimkrsounpwrssmobdyashljcczmljogfbk"" }, new int[] { 3934, 1188, 5014 }));
        ExampleRunner.eq(54, 7397, new PalindromeGame().getMaximum(new String[] { ""tjjtcjqwht"", ""tjjtcjqwht"", ""ykqussuqky"" }, new int[] { 4600, 3451, 7397 }));
        ExampleRunner.eq(55, 0, new PalindromeGame().getMaximum(new String[] { ""gtlsyunntlceu"", ""gtlsyunntlceu"", ""zevijutpvtvnj"" }, new int[] { 22572, 7437, 36102 }));
        ExampleRunner.eq(56, 10146, new PalindromeGame().getMaximum(new String[] { ""zmtrifcoqswcbkaolqkslzkozoprjkzffwokasgigo"", ""ogigsakowffzkjrpozokzlskqloakbcwsqocfirtmz"", ""zmtrifcoqswcbkaolqkslzkozoprjkzffwokasgigo"" }, new int[] { 4454, 5121, 5025 }));
        ExampleRunner.eq(57, 110536, new PalindromeGame().getMaximum(new String[] { ""lpzwoocquwta"", ""atwuqcoowzpl"", ""atwuqcoowzpl"" }, new int[] { 37988, 26565, 72548 }));
        ExampleRunner.eq(58, 278350, new PalindromeGame().getMaximum(new String[] { ""askmj"", ""jmksa"", ""wipiw"" }, new int[] { 98889, 84196, 95265 }));
        ExampleRunner.eq(59, 637022, new PalindromeGame().getMaximum(new String[] { ""mbdfucznlwqrllurlttietigwxufkuqtfihjwjgwpfrrfia"", ""aifrrfpwgjwjhiftqukfuxwgiteittlrullrqwlnzcufdbm"", ""obphcqwxkrfboyzyyqkueglyynkzycgzngfbauepwcfqifj"" }, new int[] { 408535, 228487, 174836 }));
        ExampleRunner.eq(60, 48080, new PalindromeGame().getMaximum(new String[] { ""fjxmkgvtfntbcrrhwxe"", ""dyxsuhiususuihusxyd"", ""fjxmkgvtfntbcrrhwxe"" }, new int[] { 10581, 48080, 31717 }));
        ExampleRunner.eq(61, 24130, new PalindromeGame().getMaximum(new String[] { ""rvptkrqbhmrcvqrnlovdbwjwqrqymyfauoblrwdpxfprak"", ""mwhzgkimzgeibdynxhzqcthhtcqzhxnydbiegzmikgzhwm"", ""karpfxpdwrlbouafymyqrqwjwbdvolnrqvcrmhbqrktpvr"" }, new int[] { 65, 13375, 10690 }));
        ExampleRunner.eq(62, 57896, new PalindromeGame().getMaximum(new String[] { ""blpztdsptxarfdel"", ""incgvsjffjsvgcni"", ""incgvsjffjsvgcni"" }, new int[] { 41441, 10543, 47353 }));
        ExampleRunner.eq(63, 14116, new PalindromeGame().getMaximum(new String[] { ""yotblftphklamyyfdm"", ""ifcvfsmjjjjmsfvcfi"", ""mcwpflywvvwylfpwcm"" }, new int[] { 105843, 1074, 14116 }));
        ExampleRunner.eq(64, 19160, new PalindromeGame().getMaximum(new String[] { ""rhthtqlcwfvrvxzcopunixtdgpybbisdpulwjursjaazwkadhx"", ""wuickozwtnffredorvunzzbfssfbzznuvroderffntwzokciuw"", ""uzlxobsnjwaieyzffyvnujhdvmnuxdeatspcumxmkkeahlwiaq"" }, new int[] { 23837, 19160, 22751 }));
        ExampleRunner.eq(65, 0, new PalindromeGame().getMaximum(new String[] { ""rheivwppdwxvvnq"", ""lnbzctxqawqngvn"", ""rheivwppdwxvvnq"" }, new int[] { 2065, 2103, 580 }));
        ExampleRunner.eq(66, 4393, new PalindromeGame().getMaximum(new String[] { ""jopdcsufcezogczpqpbjxlhoqgcaldoxqmjyegijidqgtuq"", ""cbvyphypajtcgohyvyikxfnnbluneumtxofafzbtanurdhp"", ""qutgqdijigeyjmqxodlacgqohlxjbpqpzcgozecfuscdpoj"" }, new int[] { 1157, 1983, 3236 }));
        ExampleRunner.eq(67, 0, new PalindromeGame().getMaximum(new String[] { ""rlemxgusgucogotjeihsfx"", ""yingnnxuafffmcbiavlbjm"", ""yingnnxuafffmcbiavlbjm"" }, new int[] { 19297, 77245, 55762 }));
        ExampleRunner.eq(68, 49227, new PalindromeGame().getMaximum(new String[] { ""rvlo"", ""ckek"", ""kekc"" }, new int[] { 26379, 30373, 18854 }));
        ExampleRunner.eq(69, 1596, new PalindromeGame().getMaximum(new String[] { ""sfnztgydadkcxsszydmvjemqbbweedjnqpdsspc"", ""whmgccuxymeyoxfjoifcbgrtdgsrbeesshrtpvp"", ""laazzutbyzrgeojizgvrvgzijoegrzybtuzzaal"" }, new int[] { 5377, 7809, 1596 }));
        ExampleRunner.eq(70, 0, new PalindromeGame().getMaximum(new String[] { ""pfmoxenvxhhcawabitabsmlkqsschmqsw"", ""ybrdmybmxwmedkdngguzthgtcrffkrbbv"", ""xbcqzpwazbhiovhisovlgackkqulfsacx"" }, new int[] { 60487, 54222, 88005 }));
        ExampleRunner.eq(71, 1343981, new PalindromeGame().getMaximum(new String[] { ""wnteftexemkrrjxzj"", ""wnteftexemkrrjxzj"", ""dyfvdlrancofegpiz"", ""uvfbsitwewtisbfvu"", ""nsyrjtwpjikskybyh"", ""lvuhskvdojqmcrrny"", ""yepsnwwjzrqyznkjf"", ""qdgdzymwhbzpmvmri"", ""nqrxagfpbvclcalam"", ""wnteftexemkrrjxzj"", ""dyfvdlrancofegpiz"", ""uvfbsitwewtisbfvu"", ""noepfvsjeuilfgues"", ""nsyrjtwpjikskybyh"", ""hldzgqapnpaqgzdlh"", ""noepfvsjeuilfgues"", ""ynrrcmqjodvkshuvl"", ""hldzgqapnpaqgzdlh"", ""uvfbsitwewtisbfvu"", ""uvfbsitwewtisbfvu"", ""ebfgktggoucjoping"", ""rrcribarwrabircrr"", ""ebfgktggoucjoping"", ""qdgdzymwhbzpmvmri"", ""noepfvsjeuilfgues"", ""uvfbsitwewtisbfvu"", ""nsyrjtwpjikskybyh"", ""rrcribarwrabircrr"", ""rrcribarwrabircrr"", ""lvuhskvdojqmcrrny"", ""dyfvdlrancofegpiz"", ""rrcribarwrabircrr"", ""nqrxagfpbvclcalam"", ""lvuhskvdojqmcrrny"", ""uvfbsitwewtisbfvu"", ""rrcribarwrabircrr"", ""nqrxagfpbvclcalam"", ""yepsnwwjzrqyznkjf"", ""hiqdwkmvkbefxmsen"", ""hiqdwkmvkbefxmsen"", ""yepsnwwjzrqyznkjf"", ""wnteftexemkrrjxzj"", ""hldzgqapnpaqgzdlh"", ""hldzgqapnpaqgzdlh"", ""rrcribarwrabircrr"", ""hiqdwkmvkbefxmsen"", ""gkjgyvtkqlamdbnrf"", ""dyfvdlrancofegpiz"", ""noepfvsjeuilfgues"", ""rrcribarwrabircrr"" }, new int[] { 95590, 90328, 21769, 25048, 29486, 97060, 108874, 99847, 47341, 108055, 36140, 50195, 78855, 31181, 104654, 60673, 41362, 37118, 109227, 104059, 101993, 84665, 59520, 23106, 82062, 54236, 8923, 103851, 69384, 82972, 71920, 95356, 35312, 43247, 106662, 59956, 64851, 16140, 56913, 34866, 105514, 27253, 78742, 68776, 49788, 37132, 12637, 55634, 9549, 3842 }));
        ExampleRunner.eq(72, 820747, new PalindromeGame().getMaximum(new String[] { ""jlouxawxfaumdipkgejxelpvmnecubgzywknbjhdhtbnse"", ""oglwoxvkgqvogymmtejdcztkfowqohxqrocutxkmqpztds"", ""xesmlclsuphyoewtvpaknrwwrnkapvtweoyhpuslclmsex"", ""dhhxjjssmylgwqhrffzczejhvpyzlamkxsndhdmqavocjm"", ""xesmlclsuphyoewtvpaknrwwrnkapvtweoyhpuslclmsex"", ""jlouxawxfaumdipkgejxelpvmnecubgzywknbjhdhtbnse"", ""negfotpmqovnddaofenmcxcehnezdccfkmpxplchdnlvth"", ""dhhxjjssmylgwqhrffzczejhvpyzlamkxsndhdmqavocjm"", ""liocyuhguizvwxugdizckollokczidguxwvziughuycoil"", ""mjcovaqmdhdnsxkmalzypvhjezczffrhqwglymssjjxhhd"" }, new int[] { 145092, 152341, 180204, 143143, 152341, 138284, 146548, 198511, 146548, 143143 }));
        ExampleRunner.eq(73, 56020, new PalindromeGame().getMaximum(new String[] { ""gfkdwurtcbitxxtibctruwdkfg"", ""eigqalzpsqdzmmzdqspzlaqgie"", ""tuhamotccvxhbbhxvcctomahut"", ""zrsierjkdidqyyqdidkjreisrz"", ""ovylherqshxzppzxhsqrehlyvo"", ""etxmjvaifgolyylogfiavjmxte"", ""vnrtzrakqfobxxbofqkarztrnv"", ""ieyfnjpfbclddbfhqhqkjtxbrv"", ""xvnkhhzlhwsdvvdswhlzhhknvx"", ""gnpybizztuvnoonvutzzibypng"", ""aemikttbbzfmeemfzbbttkimea"", ""bcobjejewijbaabjiwejejbocb"", ""suslhrgqenilrygvupxaqfudmh"", ""cmeekoagehvlwibenkcczuyywx"", ""tuhamotccvxhbbhxvcctomahut"", ""ruimegefdtguoougtdfegemiur"", ""vosicbqqtqefggfeqtqqbcisov"", ""rqgwhznkoxceddecxoknzhwgqr"", ""ekbgcbajmwndkkdnwmjabcgbke"", ""xvnkhhzlhwsdvvdswhlzhhknvx"", ""vrbxtjkqhqhfbddlcbfpjnfyei"", ""sqxnmilbnaezttzeanblimnxqs"", ""vholqbmgcdcloolcdcgmbqlohv"", ""rqgwhznkoxceddecxoknzhwgqr"", ""vnrtzrakqfobxxbofqkarztrnv"" }, new int[] { 8558, 3523, 3227, 709, 6739, 7601, 3815, 6109, 4641, 6073, 7479, 5004, 6682, 7585, 5287, 4905, 4055, 2763, 859, 1968, 8799, 6218, 2974, 3147, 7706 }));
        ExampleRunner.eq(74, 73111, new PalindromeGame().getMaximum(new String[] { ""zpdifnukixi"", ""zpdifnukixi"", ""wtmqcvcqmtw"", ""wtmqcvcqmtw"", ""wtmqcvcqmtw"", ""wtmqcvcqmtw"", ""wtmqcvcqmtw"", ""sjmunhwlmpv"", ""sjmunhwlmpv"", ""sjmunhwlmpv"", ""sdlkriyxqcs"", ""sdlkriyxqcs"", ""scqxyirklds"", ""scqxyirklds"", ""scqxyirklds"", ""omucwtwcumo"", ""omucwtwcumo"", ""omucwtwcumo"", ""omucwtwcumo"", ""omucwtwcumo"", ""omucwtwcumo"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mvuhgpghuvm"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""mgbhjkegzef"", ""lpgelklegpl"", ""lpgelklegpl"", ""lpgelklegpl"", ""ixikunfidpz"", ""ixikunfidpz"", ""ixikunfidpz"", ""ixikunfidpz"", ""ixikunfidpz"", ""fezgekjhbgm"", ""fezgekjhbgm"", ""fezgekjhbgm"", ""fezgekjhbgm"", ""fezgekjhbgm"" }, new int[] { 2837, 2087, 4551, 1455, 313, 4408, 210, 1369, 4089, 4265, 4553, 2934, 539, 1548, 885, 3196, 452, 2559, 453, 2182, 403, 3952, 3287, 1542, 237, 1093, 473, 533, 518, 968, 159, 3854, 931, 1005, 2545, 1196, 1907, 2521, 1539, 3589, 1359, 1741, 3132, 1055, 611, 3512 }));
        ExampleRunner.eq(75, 23252828, new PalindromeGame().getMaximum(new String[] { ""twtteevjzoumciixdnfcksbnethnfub"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""twtteevjzoumciixdnfcksbnethnfub"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""twtteevjzoumciixdnfcksbnethnfub"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""cojwmxcttecsyjxrxjyscettcxmwjoc"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""cojwmxcttecsyjxrxjyscettcxmwjoc"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""twtteevjzoumciixdnfcksbnethnfub"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""cojwmxcttecsyjxrxjyscettcxmwjoc"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""bufnhtenbskcfndxiicmuozjveettwt"", ""twtteevjzoumciixdnfcksbnethnfub"", ""cojwmxcttecsyjxrxjyscettcxmwjoc"", ""twtteevjzoumciixdnfcksbnethnfub"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""fwtqfwsnyojlasmnguwrtdjwzbosbpi"", ""dbjtbkcdsiaxsfnwnfsxaisdckbtjbd"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""ipbsobzwjdtrwugnmsaljoynswfqtwf"", ""twtteevjzoumciixdnfcksbnethnfub"", ""twtteevjzoumciixdnfcksbnethnfub"" }, new int[] { 973668, 914559, 140599, 300625, 824221, 230480, 389527, 66722, 177642, 563778, 50591, 344152, 952389, 681607, 709703, 637522, 526735, 12274, 948668, 930438, 872964, 536625, 351472, 345157, 815463, 841718, 727927, 314638, 569295, 172013, 142069, 213481, 174480, 482335, 503419, 592771, 535587, 413773, 4333, 855242, 674163, 504927, 398529, 99888, 696670, 692392, 468622, 55432, 369067, 517274 }));
        ExampleRunner.eq(76, 35311, new PalindromeGame().getMaximum(new String[] { ""kibcqdpmlweccpjmfcwiojgzcwzgvaienxnidxjlamsqvv"", ""emcumbcvoabqhnxympctkiggiktcpmyxnhqbaovcbmucme"", ""rtynrqfkqiehmhyurjankqtumzfjwysiqgiuqjmsttjlpe"", ""tesnathynatyaygkxjsyijkmkwkxaupkwkxrbyeyhhxhec"", ""gpoupunryfalskhiuniifmxghmvofchbshykvftqogcqhg"", ""xirytgajpgrnpyizfovkdxivsvdfwzisjazrcnuakuvrzz"", ""rtynrqfkqiehmhyurjankqtumzfjwysiqgiuqjmsttjlpe"", ""sogqfykcvppdikillubxngfmnqdmskjtkiuftqoryxwegj"", ""oimnyofaexstemceqepgzyhpkqsvbbnkylofjkkxjacgyr"", ""sxudmqletsicytaeuaanedjrqncmocljnpfyoiynjbgwxz"", ""kqmjfktfxtwgsachykanvfcbcpsttniujbgznawznkapzq"", ""ejpetvhqsdhljmlwhwdpsriyoaorhuehtdkdznmsjvhwfn"", ""jbrrcrnnwbkgmppbtxgjcgnubawkrowpkznefzppuwwkle"", ""zgdarnqhvxlruhdkeryqdprjrnuzzgvfiuuubwyzbrowfo"", ""ghqcgoqtfvkyhsbhcfovmhgxmfiinuihkslafyrnupuopg"", ""tesnathynatyaygkxjsyijkmkwkxaupkwkxrbyeyhhxhec"", ""pllytrxnezkhwjvrspgogewtdtslmefzblirgqzdqsznob"", ""pllytrxnezkhwjvrspgogewtdtslmefzblirgqzdqsznob"", ""eicjejjwgejipspvwcxantiitnaxcwvpspijegwjjejcie"", ""fqtxstqwwgkjdopoxpsambjilssfpkfudrlgsfkwelawaw"", ""jelwfympzrvtjfjcecuoerppndszffsnwoeotyonycyigc"", ""oimnyofaexstemceqepgzyhpkqsvbbnkylofjkkxjacgyr"", ""ejpetvhqsdhljmlwhwdpsriyoaorhuehtdkdznmsjvhwfn"", ""sxudmqletsicytaeuaanedjrqncmocljnpfyoiynjbgwxz"", ""recbvgajoywpxiqivthntydpxcodclnknilquwtvnprjzp"", ""ghqcgoqtfvkyhsbhcfovmhgxmfiinuihkslafyrnupuopg"", ""eicjejjwgejipspvwcxantiitnaxcwvpspijegwjjejcie"", ""fqtxstqwwgkjdopoxpsambjilssfpkfudrlgsfkwelawaw"", ""fqtxstqwwgkjdopoxpsambjilssfpkfudrlgsfkwelawaw"", ""kibcqdpmlweccpjmfcwiojgzcwzgvaienxnidxjlamsqvv"" }, new int[] { 9956, 10376, 4683, 3306, 9880, 6789, 8832, 3564, 12548, 5517, 9893, 5155, 2486, 6726, 4672, 10028, 6577, 5227, 9612, 4929, 7411, 1938, 3196, 7172, 13347, 3597, 771, 11692, 3471, 2335 }));
        ExampleRunner.eq(77, 42407, new PalindromeGame().getMaximum(new String[] { ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""trcnfrnorsrosocnjzubazgzdfbfrhdrur"", ""tpremyjgqzgvhxopllpoxhvgzqgjymerpt"", ""tpremyjgqzgvhxopllpoxhvgzqgjymerpt"", ""tpremyjgqzgvhxopllpoxhvgzqgjymerpt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""rurdhrfbfdzgzabuzjncosorsronrfncrt"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""pxuevgoymjtpgrwyaaywrgptjmyogveuxp"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cwkmfjerzqbirweyelwsnjagwryulicwfc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"", ""cfwciluyrwgajnswleyewribqzrejfmkwc"" }, new int[] { 592, 770, 855, 987, 629, 1299, 819, 218, 770, 702, 1204, 855, 1565, 479, 643, 846, 980, 727, 1307, 477, 702, 1112, 984, 500, 829, 471, 1400, 1220, 1112, 980, 562, 1242, 683, 846, 1242, 611, 1025, 1039, 477, 506, 1186, 819, 302, 1053, 921, 1557, 1046, 1420, 1333, 786 }));
        ExampleRunner.eq(78, 17338697, new PalindromeGame().getMaximum(new String[] { ""pobsyhohxupuxhohysbop"", ""mjxzwtqyltfcjgultqdiu"", ""mjxzwtqyltfcjgultqdiu"", ""pobsyhohxupuxhohysbop"", ""uidqtlugjcftlyqtwzxjm"", ""mjxzwtqyltfcjgultqdiu"", ""mwdpkssbzcqmdupryzzsf"", ""mjxzwtqyltfcjgultqdiu"", ""mwdpkssbzcqmdupryzzsf"", ""uidqtlugjcftlyqtwzxjm"", ""uidqtlugjcftlyqtwzxjm"", ""kewjmsztyujuytzsmjwek"", ""uidqtlugjcftlyqtwzxjm"", ""kewjmsztyujuytzsmjwek"", ""fszzyrpudmqczbsskpdwm"", ""pobsyhohxupuxhohysbop"", ""mjxzwtqyltfcjgultqdiu"", ""mjxzwtqyltfcjgultqdiu"", ""uidqtlugjcftlyqtwzxjm"", ""mjxzwtqyltfcjgultqdiu"", ""uidqtlugjcftlyqtwzxjm"", ""mjxzwtqyltfcjgultqdiu"", ""mwdpkssbzcqmdupryzzsf"", ""fszzyrpudmqczbsskpdwm"", ""mjxzwtqyltfcjgultqdiu"", ""kewjmsztyujuytzsmjwek"", ""uidqtlugjcftlyqtwzxjm"", ""mwdpkssbzcqmdupryzzsf"", ""mjxzwtqyltfcjgultqdiu"", ""uidqtlugjcftlyqtwzxjm"", ""fszzyrpudmqczbsskpdwm"", ""uidqtlugjcftlyqtwzxjm"", ""mjxzwtqyltfcjgultqdiu"", ""uidqtlugjcftlyqtwzxjm"", ""fszzyrpudmqczbsskpdwm"", ""uidqtlugjcftlyqtwzxjm"", ""kewjmsztyujuytzsmjwek"", ""kewjmsztyujuytzsmjwek"", ""mwdpkssbzcqmdupryzzsf"", ""kewjmsztyujuytzsmjwek"", ""mwdpkssbzcqmdupryzzsf"", ""mjxzwtqyltfcjgultqdiu"", ""fszzyrpudmqczbsskpdwm"", ""mwdpkssbzcqmdupryzzsf"", ""mwdpkssbzcqmdupryzzsf"", ""mwdpkssbzcqmdupryzzsf"", ""mwdpkssbzcqmdupryzzsf"", ""fszzyrpudmqczbsskpdwm"", ""mjxzwtqyltfcjgultqdiu"", ""pobsyhohxupuxhohysbop"" }, new int[] { 390281, 312240, 270429, 303257, 210175, 594465, 332025, 360307, 625927, 599978, 211672, 570374, 635361, 247817, 345107, 385285, 621545, 420631, 390381, 242304, 292295, 163222, 44112, 46604, 589644, 133538, 605457, 39962, 644497, 368355, 543119, 462574, 548031, 22471, 31851, 318115, 392193, 60788, 585525, 195274, 631467, 202852, 454688, 10393, 282224, 601320, 83485, 652567, 175372, 603687 }));
        ExampleRunner.eq(79, 2225181, new PalindromeGame().getMaximum(new String[] { ""ucaadvpcfwri"", ""mvuduttuduvm"", ""sjeqyddyqejs"", ""xogngjjgngox"", ""sccnygcvowbw"", ""fiixevvexiif"", ""ooeunmmnueoo"", ""bhiihpphiihb"", ""gicfyffyfcig"", ""ucaadvpcfwri"", ""oluktcctkulo"", ""ztfqdgulbdaf"", ""xogngjjgngox"", ""gvzmkkkkmzvg"", ""xgxfdioqxxne"", ""twzdvxxvdzwt"", ""ggsrjzzjrsgg"", ""lcrsqrrqsrcl"", ""drhkpddpkhrd"", ""tuexzxrayxrg"", ""lmxilgmmblgm"", ""ovdehtthedvo"", ""nmszoyyozsmn"", ""udorvuuvrodu"", ""muyfvcmexhgq"", ""sfuugaaguufs"", ""hgtgfyyfgtgh"", ""nozholdswkyv"", ""vpykjcqwzjye"", ""svekzrrzkevs"", ""naakdhhdkaan"", ""ooeunmmnueoo"", ""kbzoqffqozbk"", ""lfiayrohclxo"", ""dmnudiidunmd"", ""gaqgiffigqag"", ""qnhcossochnq"", ""ubhbqzzqbhbu"", ""ujjzzcczzjju"", ""vpykjcqwzjye"", ""epmpcjjcpmpe"", ""cxdasccsadxc"", ""gggzautkciev"", ""vcuwttttwucv"", ""prlxqeeqxlrp"", ""gsnjhcchjnsg"" }, new int[] { 557394, 346623, 334763, 330961, 623522, 287120, 612231, 466003, 108951, 325922, 457228, 297309, 134821, 495627, 352930, 590817, 144763, 4857, 421751, 278947, 402401, 454570, 291555, 81988, 579098, 245385, 588440, 34703, 400799, 21196, 147823, 509416, 157271, 279843, 134458, 334258, 324528, 307907, 100365, 575037, 414250, 357632, 536179, 89445, 143634, 637752 }));
        ExampleRunner.eq(80, 11704520, new PalindromeGame().getMaximum(new String[] { ""xmsthissssihtsmx"", ""jneqjxwqqwxjqenj"", ""hhzlnfdiidfnlzhh"", ""skselrjppjrlesks"", ""ykpqiwlrrlwiqpky"", ""nfoyoiazzaioyofn"", ""ykpqiwlrrlwiqpky"", ""hucchjmttoaiakrs"", ""kjltofprrpfotljk"", ""hhzlnfdiidfnlzhh"", ""skselrjppjrlesks"", ""ppfhvyuqquyvhfpp"", ""xmsthissssihtsmx"", ""mjhrznguzdwjspns"", ""hucchjmttoaiakrs"", ""ebynqfednnmihqws"", ""mqjnzeyzzyeznjqm"", ""swqhimnndefqnybe"", ""drnnotfzzftonnrd"", ""tyvuqbmhhmbquvyt"", ""kqlmbzjkkjzbmlqk"", ""nujkjafoofajkjun"", ""kjltofprrpfotljk"", ""drnnotfzzftonnrd"", ""jneqjxwqqwxjqenj"", ""nujkjafoofajkjun"", ""swqhimnndefqnybe"", ""tyvuqbmhhmbquvyt"", ""kqlmbzjkkjzbmlqk"", ""jneqjxwqqwxjqenj"", ""xpzgwxxggxxwgzpx"", ""vwkfhdlufeetbvzs"", ""wyoilvawwavlioyw"", ""szvbteefuldhfkwv"", ""okjwdxmjjmxdwjko"", ""okjwdxmjjmxdwjko"", ""xmsthissssihtsmx"", ""hhzlnfdiidfnlzhh"", ""hgjjqrkstcpdgzwn"", ""nwzgdpctskrqjjgh"", ""ptdoljqbbqjlodtp"", ""ppfhvyuqquyvhfpp"", ""skselrjppjrlesks"", ""swqhimnndefqnybe"" }, new int[] { 116218, 543416, 516519, 306926, 360922, 327080, 400802, 190507, 341548, 206553, 129776, 624598, 680579, 396840, 94419, 12898, 262421, 81924, 409250, 528435, 542795, 228145, 317353, 92653, 455496, 383432, 195452, 34344, 564691, 322107, 237401, 540513, 444995, 51093, 72889, 394922, 273479, 444288, 382931, 386818, 334063, 529793, 403086, 434911 }));
        ExampleRunner.eq(81, 469713, new PalindromeGame().getMaximum(new String[] { ""yljetsktoxqksxuujfjuuxskqxotkstejly"", ""wumaunvtfyigpdjcrpztheqytovrmoqctxr"", ""wumaunvtfyigpdjcrpztheqytovrmoqctxr"", ""vvjfzlobvhpckxefnggcbznipfkbpftnbpe"", ""vsknpebkkucxnohvjbjvhonxcukkbepnksv"", ""vopqrqfnmouaeejclqlcjeeauomnfqrqpov"", ""vnwyusubxakvmfyhqtpwjchofxxourpoqsr"", ""vdpdgqtwbisfwxuvhdpvdqcxmcbuhtsnvzm"", ""vdpdgqtwbisfwxuvhdpvdqcxmcbuhtsnvzm"", ""uteenvglamvmtqbzaaazbqtmvmalgvneetu"", ""ruetqyorvwbneooxmqsuqkcumeweohlmkpl"", ""rkbarjwbifqducftkemtxxdsqmrehdeeskn"", ""rkbarjwbifqducftkemtxxdsqmrehdeeskn"", ""qyjjydqohzxjmmplstslpmmjxzhoqdyjjyq"", ""pqzkrkfjfhigtbuxgagxubtgihfjfkrkzqp"", ""npdnsfrbnzymcuwyqcqywucmyznbrfsndpn"", ""nkseedhermqsdxxtmektfcudqfibwjrabkr"", ""kwiclzwqapgwedjzgdgzjdewgpaqwzlciwk"", ""kwiclzwqapgwedjzgdgzjdewgpaqwzlciwk"", ""jvicdvmnqicwmfuqwgwqufmwciqnmvdcivj"", ""jvicdvmnqicwmfuqwgwqufmwciqnmvdcivj"", ""janzgyxtlbftcuuqctsbuipzsqgggozzroy"", ""janzgyxtlbftcuuqctsbuipzsqgggozzroy"", ""isrbnxmgiejgrpnrefernprgjeigmxnbrsi"", ""isrbnxmgiejgrpnrefernprgjeigmxnbrsi"", ""iosvzwsxgdwheztzaaztvznjnifejtdcrhu"", ""iosvzwsxgdwheztzaaztvznjnifejtdcrhu"", ""iosvzwsxgdwheztzaaztvznjnifejtdcrhu"", ""hzygigdtsacyqsrgsasgrsqycastdgigyzh"", ""hzygigdtsacyqsrgsasgrsqycastdgigyzh"", ""epbntfpbkfpinzbcggnfexkcphvbolzfjvv"", ""djdudasnssdstbenypynebtsdssnsadudjd"", ""djdudasnssdstbenypynebtsdssnsadudjd"", ""anhntnpmilatzqigqbqgiqztalimpntnhna"", ""anhntnpmilatzqigqbqgiqztalimpntnhna"", ""anhntnpmilatzqigqbqgiqztalimpntnhna"" }, new int[] { 17138, 36372, 27852, 27852, 45337, 18607, 23170, 28919, 45494, 26089, 40852, 10952, 37117, 28242, 28919, 7590, 28242, 27859, 24998, 21988, 41836, 22951, 19403, 28786, 16815, 30972, 21316, 38542, 36838, 37878, 27859, 4845, 21847, 14618, 14618, 24998 }));
        ExampleRunner.eq(82, 626665, new PalindromeGame().getMaximum(new String[] { ""blmdsltipfw"", ""blmdsltipfw"", ""kbnfyvyobyr"", ""afphpobziix"", ""afphpobziix"", ""uogfjtjfgou"", ""afphpobziix"", ""afphpobziix"", ""tovxbjdmqrf"", ""afphpobziix"", ""blmdsltipfw"", ""fbqhyyjooiq"", ""wfpitlsdmlb"", ""kbnfyvyobyr"", ""uogfjtjfgou"", ""frqmdjbxvot"", ""qioojyyhqbf"", ""fbqhyyjooiq"", ""frqmdjbxvot"", ""kbnfyvyobyr"", ""uogfjtjfgou"", ""tovxbjdmqrf"" }, new int[] { 7312, 17059, 51411, 69598, 68944, 23078, 53983, 91104, 85673, 40468, 69196, 74185, 89251, 83564, 72477, 14741, 58602, 48925, 30190, 87137, 58804, 50468 }));
        ExampleRunner.eq(83, 62589, new PalindromeGame().getMaximum(new String[] { ""femnjowaaeae"", ""drywdwwdwyrd"", ""rdkgzoozgkdr"", ""drywdwwdwyrd"", ""rnzshtacblvc"", ""fhfzyrryzfhf"", ""rnzshtacblvc"", ""rdkgzoozgkdr"", ""rdkgzoozgkdr"", ""pvvxbllbxvvp"", ""femnjowaaeae"", ""ckwpbbbbpwkc"", ""cvlbcathsznr"", ""lkxslsslsxkl"", ""fhfzyrryzfhf"", ""xmyohddhoymx"", ""guzoetqtmdij"", ""myoumrrmuoym"", ""ajpjnccnjpja"", ""pvvxbllbxvvp"", ""ckwpbbbbpwkc"", ""guzoetqtmdij"", ""ndnzussuzndn"", ""tnyzxhhxzynt"", ""yqxubttbuxqy"", ""dzkiyeeyikzd"", ""ndnzussuzndn"", ""ndnzussuzndn"", ""myoumrrmuoym"", ""qtibgllgbitq"", ""ajpjnccnjpja"", ""pjxgqbbqgxjp"", ""jidmtqteozug"", ""lkxslsslsxkl"", ""myoumrrmuoym"", ""rnzshtacblvc"", ""gakkooookkag"", ""yqxubttbuxqy"", ""pjxgqbbqgxjp"", ""gakkooookkag"", ""lkxslsslsxkl"", ""fhfzyrryzfhf"", ""tnyzxhhxzynt"" }, new int[] { 1364, 2817, 1291, 758, 3255, 1559, 2014, 292, 885, 3295, 2989, 2560, 3107, 2919, 2372, 3371, 1721, 3275, 1780, 1915, 2827, 810, 592, 212, 1559, 1383, 1119, 898, 2626, 2940, 2306, 911, 2405, 1022, 1511, 2710, 204, 2338, 2074, 1303, 3252, 2667, 567 }));
        ExampleRunner.eq(84, 50313, new PalindromeGame().getMaximum(new String[] { ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""darpflzfnlcnqvasljnzjnodpulom"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""darpflzfnlcnqvasljnzjnodpulom"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""ivrdccxqsrbdciaicdbrsqxccdrvi"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"", ""lbqrjiznoitwbqnqvuvsmolwqprca"", ""yiiplbcmrsfjfpgsimlrkawrqzjhb"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""acrpqwlomsvuvqnqbwtionzijrqbl"", ""bhjzqrwakrlmisgpfjfsrmcblpiiy"" }, new int[] { 2979, 2770, 1745, 831, 125, 1960, 1630, 574, 1615, 461, 1740, 2575, 2855, 1461, 2495, 14, 2888, 3644, 3432, 2568, 1997, 581, 581, 3511, 333, 2393, 1942, 1427, 893, 1442, 3466, 608 }));
        ExampleRunner.eq(85, 136876, new PalindromeGame().getMaximum(new String[] { ""ogfb"", ""ceec"", ""aytd"", ""epxk"", ""szmx"", ""dtya"", ""tonc"", ""adda"", ""ceec"", ""dfmi"", ""riir"", ""icci"", ""anwq"", ""nzrr"", ""gntj"", ""adda"", ""oxve"", ""riir"", ""pwwp"", ""mttm"", ""cnot"", ""oiio"", ""mttm"", ""diid"", ""ywrf"", ""frwy"", ""kuuk"", ""imfd"", ""jtcv"", ""atqc"", ""kuuk"", ""anwq"", ""jtcv"", ""duud"", ""jynn"", ""gevx"", ""dvlq"", ""oiio"", ""cnot"", ""kuuk"", ""nzrr"", ""mppm"", ""kxpe"", ""arra"", ""qjlz"", ""dztx"", ""qwna"" }, new int[] { 8465, 6903, 7900, 7597, 7898, 426, 3358, 1261, 4471, 3608, 5527, 1610, 1546, 9321, 1209, 5090, 5527, 8725, 8574, 9612, 4421, 3507, 5774, 8850, 589, 8686, 3824, 237, 5537, 2150, 5894, 8083, 670, 2929, 5525, 4503, 5100, 7940, 6079, 8662, 1651, 6879, 1425, 4276, 2083, 1333, 6672 }));
        ExampleRunner.eq(86, 11894427, new PalindromeGame().getMaximum(new String[] { ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""heekgkeeh"", ""kfloccjxw"", ""kfloccjxw"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""sriwijxrx"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wwnpppnww"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""wxjccolfk"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"", ""xrxjiwirs"" }, new int[] { 291588, 88674, 186593, 345840, 343186, 195482, 287926, 323387, 370054, 521861, 260649, 370542, 438425, 255232, 130545, 355120, 322060, 322060, 79525, 108357, 370054, 281733, 109072, 323387, 389235, 344385, 343186, 44636, 75598, 102926, 222961, 389235, 186219, 516416, 186219, 64975, 545366, 10930, 318182, 13873, 222961, 10930, 264829, 344385, 68727, 418499, 263223, 358667, 79525, 430346 }));
        ExampleRunner.eq(87, 1522621, new PalindromeGame().getMaximum(new String[] { ""cmzwyjyxlnsfgkwrbhlprflcmqpxiuyj"", ""cmzwyjyxlnsfgkwrbhlprflcmqpxiuyj"", ""djkzgyfopotaemgodwuctaprrpqnntoi"", ""dyralguuxdgakqwmmwqkagdxuuglaryd"", ""dyralguuxdgakqwmmwqkagdxuuglaryd"", ""fnohkqwgbabqyiipvxxekjqygrwbkdnp"", ""hluflnqdgfpvzadcgaihfacbrnzyyfqx"", ""hwwcbopfzpwrywyvwcyajernopiexohg"", ""iotnnqprrpatcuwdogmeatopofygzkjd"", ""jyuixpqmclfrplhbrwkgfsnlxyjywzmc"", ""lauvvxlwowszjofmmfojzswowlxvvual"", ""mslcwsheidjrnaewcxnhydtxdqrrfnlu"", ""oemrtlibirzckkoxkphcybjwhhgxawvl"", ""pndkbwrgyqjkexxvpiiyqbabgwqkhonf"", ""smcdtnyjzfdsidzddzdisdfzjyntdcms"", ""smcdtnyjzfdsidzddzdisdfzjyntdcms"", ""viquqzrblirtbkcwwckbtrilbrzquqiv"", ""viquqzrblirtbkcwwckbtrilbrzquqiv"" }, new int[] { 190268, 109231, 158715, 180967, 143667, 65850, 78186, 142888, 150816, 7550, 142387, 220028, 2856, 10889, 200326, 18329, 33399, 219458 }));
        ExampleRunner.eq(88, 607080, new PalindromeGame().getMaximum(new String[] { ""zsnbmrmplplpmrmbnsz"", ""yznrijxgkjmdnoxwvim"", ""yvubnsqtadzgnwzxete"", ""yljzmxkofimhtebjoze"", ""yfrpussjgbvypnhjvop"", ""xrvaavzjlltdyhzdcix"", ""xcfoqkhxpapxhkqofcx"", ""wxlswakuixealioqkms"", ""vvggjwomghmzahsdzfv"", ""vlctnuiqlbdrpepxrbi"", ""shsbdjlzcwczljdbshs"", ""rtllbcfakxeqhybbiig"", ""reygnbnwkuntluxhakz"", ""ppjzfgsiztzisgfzjpp"", ""onfddtzceqgqmwggflq"", ""occdjthynqgqxiugevg"", ""nrmabbpxiptifxjzvuf"", ""nfcrmvijfmfjivmrcfn"", ""kzrsmqmkdjiobbhkqef"", ""khplhlckhbcailbdguc"", ""jwbasqklruqufumwdnk"", ""jqyieymkutvehxscgrg"", ""irlrrvfwxyoufpiqecy"", ""irfdcjktodkejyagpll"", ""imqvvjnunzakridvrgm"", ""ijmagrxbjbqltpertln"", ""grgcsxhevtukmyeiyqj"", ""ebsbquqwapbtgcjzmyv"", ""eaemnohdduddhonmeae"", ""dfzirqcmnkjsnyglrlx"", ""dewjotroiegexqrrxha"", ""dekfiyyokakoyyifked"", ""cpkpstzlfnflztspkpc"", ""aybejfkeoagozyobpog"", ""avvymvdsntfylpmpobm"", ""amlbianyciuvjattvhl"" }, new int[] { 44597, 44863, 98628, 215813, 82394, 180514, 144563, 96161, 4932, 82707, 243511, 53869, 223450, 268414, 165252, 130637, 29569, 280986, 136911, 2330, 42303, 116948, 256209, 157799, 269801, 207606, 209146, 235683, 204049, 262055, 218947, 58113, 3001, 66931, 112577, 97114 }));
        ExampleRunner.eq(89, 459736, new PalindromeGame().getMaximum(new String[] { ""obviwimtyqgptlydmzroa"", ""socdvghvhrlxpvnkmrdev"", ""dovgyjqfddhcteixcrfiy"", ""hxtsillmmxitisirwvwlj"", ""nvlyjyklvypyvlkyjylvn"", ""xhpdbwmdhsqshdmwbdphx"", ""hxtsillmmxitisirwvwlj"", ""jlwvwrisitixmmllistxh"", ""uehtutisyvmgkxlbomcbv"", ""snrjwjevnrsdnyljnbksz"", ""zyekxeefiztzifeexkeyz"", ""zyekxeefiztzifeexkeyz"", ""sxoapnliqnvnqilnpaoxs"", ""uehtutisyvmgkxlbomcbv"", ""jlwvwrisitixmmllistxh"", ""socdvghvhrlxpvnkmrdev"", ""xsztxcwxggjvkxuplxzqy"", ""hxtsillmmxitisirwvwlj"", ""mploknwelhfslqmxoxvis"", ""dovgyjqfddhcteixcrfiy"" }, new int[] { 77729, 99477, 66238, 49028, 66238, 54747, 107287, 36484, 55720, 38183, 38451, 55720, 41679, 99277, 96351, 41679, 54834, 59205, 75314, 44906 }));
        ExampleRunner.eq(90, 68897, new PalindromeGame().getMaximum(new String[] { ""rzppjimqangxrsmtkxrprle"", ""hzsxtmjulckgkclujmtxszh"", ""quhcbaagsvxriekposknpft"", ""rozhsqkdzcdavqhgybcnfoa"", ""ozlxvrqzjkssskjzqrvxlzo"", ""hzbsqdiywxwdtwvkfstyrev"", ""icdwpezugigvetnkvpemdwj"", ""uwhhjeqltgjkraeuhlpdftz"", ""cilikkssohcjyconfdalrmj"", ""jwdmepvkntevgiguzepwdci"", ""eipshyeertzaztreeyhspie"" }, new int[] { 3974, 3571, 1447, 1149, 12077, 6467, 21022, 22121, 23934, 28268, 19607 }));
        ExampleRunner.eq(91, 3725832, new PalindromeGame().getMaximum(new String[] { ""yuqewzbelrrumvmcsdrpikzdnekqcitthgbnimgkcaqrkueqo"", ""sjxnnyplhofzwgkeotbbiuwxftmhgafininmwihyojgvbwtwd"", ""yuqewzbelrrumvmcsdrpikzdnekqcitthgbnimgkcaqrkueqo"", ""yuqewzbelrrumvmcsdrpikzdnekqcitthgbnimgkcaqrkueqo"", ""ruyohhlbmpwtipeuogyjgdjutujdgjygouepitwpmblhhoyur"", ""dnorjjryjqwywozwsqzfdfztxopeudrrdrdmjvsjdffbrxyfj"", ""dnorjjryjqwywozwsqzfdfztxopeudrrdrdmjvsjdffbrxyfj"", ""jfyxrbffdjsvjmdrdrrduepoxtzfdfzqswzowywqjyrjjrond"", ""jfyxrbffdjsvjmdrdrrduepoxtzfdfzqswzowywqjyrjjrond"", ""vqsejyhtrhloerpsozupyzxtfoddsopzsuvblfxwzpouabmqf"", ""ruyohhlbmpwtipeuogyjgdjutujdgjygouepitwpmblhhoyur"", ""jfyxrbffdjsvjmdrdrrduepoxtzfdfzqswzowywqjyrjjrond"", ""jfyxrbffdjsvjmdrdrrduepoxtzfdfzqswzowywqjyrjjrond"", ""dnorjjryjqwywozwsqzfdfztxopeudrrdrdmjvsjdffbrxyfj"", ""dnorjjryjqwywozwsqzfdfztxopeudrrdrdmjvsjdffbrxyfj"", ""vqsejyhtrhloerpsozupyzxtfoddsopzsuvblfxwzpouabmqf"" }, new int[] { 464972, 445821, 496340, 343981, 478941, 480323, 619306, 153655, 91508, 89100, 300720, 524909, 367976, 259538, 448956, 612620 }));
        ExampleRunner.eq(92, 8654, new PalindromeGame().getMaximum(new String[] { ""wgojhrzwvxa"", ""qlifppldqta"", ""qnemcpsouha"", ""zirmlrniyac"", ""hksyixoshvd"", ""mqpcygrgvoy"", ""grbrwublqbk"", ""dknbuwubnkd"", ""mygzlwsaryk"", ""wmfnusuxkly"", ""kjxtppptxjk"", ""wgojhrzwvxa"", ""rswtwjycqxx"", ""ybhwzzunbhd"", ""euwoirhetjw"", ""yvvctujpxxm"", ""gwferdrefwg"", ""kyoflxlfoyk"", ""dhbnuzzwhby"", ""lvlgwgmnlbw"", ""plvmlrfhuvy"", ""pigbefniuxs"", ""zmybbbbbymz"", ""matcdfqdxho"", ""imldklqldgw"", ""jalbeqojwsk"", ""rswtwjycqxx"", ""gahiydlufsn"", ""opdaeneadpo"", ""iwbzoeghocn"", ""euwoirhetjw"", ""pgpqaxaqpgp"", ""benkwywkneb"", ""zmybbbbbymz"", ""axvwzrhjogw"", ""yvuhfrlmvlp"", ""wbswnznwsbw"", ""bjllfuflljb"", ""cpzdgvojkgt"", ""bydqzqzqdyb"", ""hzrwfsfwrzh"", ""tgjipmnmuzz"", ""mzqqruszudm"", ""tgjipmnmuzz"", ""dvhsoxiyskh"", ""zzumnmpijgt"", ""plvmlrfhuvy"", ""hksyixoshvd"", ""rmfionfpujv"", ""premvzwjtsf"" }, new int[] { 921, 98, 143, 130, 736, 677, 863, 854, 637, 466, 458, 621, 1033, 248, 150, 394, 789, 1022, 555, 764, 664, 831, 357, 380, 998, 694, 15, 870, 848, 293, 103, 221, 308, 599, 842, 289, 656, 745, 724, 526, 1015, 991, 603, 41, 169, 931, 994, 664, 116, 19 }));
        ExampleRunner.eq(93, 1860, new PalindromeGame().getMaximum(new String[] { ""baxbfmatowvkzursiflar"", ""njrpmmbshhdwjhisyttrj"", ""yymqubrlpeyrbbmhgurdc"", ""njrpmmbshhdwjhisyttrj"", ""baxbfmatowvkzursiflar"", ""njrpmmbshhdwjhisyttrj"", ""ekkjzzugowrwoguzzjkke"", ""yymqubrlpeyrbbmhgurdc"", ""ekkjzzugowrwoguzzjkke"", ""baxbfmatowvkzursiflar"" }, new int[] { 102, 243, 30, 418, 283, 507, 1056, 1429, 804, 98 }));
        ExampleRunner.eq(94, 499, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 24, 7, 63, 222, 190 }));
        ExampleRunner.eq(95, 1, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 1 }));
        ExampleRunner.eq(96, 10, new PalindromeGame().getMaximum(new String[] { ""topcoder"", ""redcoder"", ""redocpot"" }, new int[] { 7, 5, 3 }));
        ExampleRunner.eq(97, 50000000, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"" }, new int[] { 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000 }));
        ExampleRunner.eq(98, 150, new PalindromeGame().getMaximum(new String[] { ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"", ""bdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdbbdcaffacdb"" }, new int[] { 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 }));
        ExampleRunner.eq(99, 11, new PalindromeGame().getMaximum(new String[] { ""aba"" }, new int[] { 11 }));
        ExampleRunner.eq(100, 10, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 10 }));
        ExampleRunner.eq(101, 7, new PalindromeGame().getMaximum(new String[] { ""cac"", ""bab"" }, new int[] { 7, 6 }));
        ExampleRunner.eq(102, 9, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"", ""a"" }, new int[] { 1, 2, 3, 4 }));
        ExampleRunner.eq(103, 34, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""b"", ""c"", ""d"" }, new int[] { 1, 12, 14, 8, 5 }));
        ExampleRunner.eq(104, 1, new PalindromeGame().getMaximum(new String[] { ""aba"" }, new int[] { 1 }));
        ExampleRunner.eq(105, 50, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aba"" }, new int[] { 50, 12 }));
        ExampleRunner.eq(106, 1000, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 1000 }));
        ExampleRunner.eq(107, 11, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 11 }));
        ExampleRunner.eq(108, 3000, new PalindromeGame().getMaximum(new String[] { ""topcoderaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""abaabaabaabaabaabaabaabaabaabaabaaba"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaredocpot"" }, new int[] { 1000, 1000, 1000 }));
        ExampleRunner.eq(109, 9, new PalindromeGame().getMaximum(new String[] { ""aaaa"", ""cbbc"", ""aaaa"", ""aaaa"", ""dawg"" }, new int[] { 1, 2, 4, 3, 100 }));
        ExampleRunner.eq(110, 11012, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ab"", ""ab"", ""ba"", ""ba"", ""ba"", ""ba"" }, new int[] { 1, 2, 3, 4, 1000, 6, 10000 }));
        ExampleRunner.eq(111, 9, new PalindromeGame().getMaximum(new String[] { ""aba"", ""fef"", ""aba"", ""aba"" }, new int[] { 1, 4, 2, 3 }));
        ExampleRunner.eq(112, 10, new PalindromeGame().getMaximum(new String[] { ""aba"" }, new int[] { 10 }));
        ExampleRunner.eq(113, 111, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aaa"", ""aaa"" }, new int[] { 100, 10, 1 }));
        ExampleRunner.eq(114, 6, new PalindromeGame().getMaximum(new String[] { ""ab"", ""aa"", ""ba"" }, new int[] { 2, 2, 2 }));
        ExampleRunner.eq(115, 718, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""cba"" }, new int[] { 7, 24, 63, 222, 190, 212 }));
        ExampleRunner.eq(116, 10, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 10 }));
        ExampleRunner.eq(117, 12, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ba"", ""ab"" }, new int[] { 5, 6, 6 }));
        ExampleRunner.eq(118, 5, new PalindromeGame().getMaximum(new String[] { ""aba"", ""bbc"", ""cbb"" }, new int[] { 1, 2, 2 }));
        ExampleRunner.eq(119, 441, new PalindromeGame().getMaximum(new String[] { ""abc"", ""sss"", ""cba"" }, new int[] { 3, 433, 5 }));
        ExampleRunner.eq(120, 7, new PalindromeGame().getMaximum(new String[] { ""aba"", ""ccc"", ""mmm"" }, new int[] { 5, 7, 3 }));
        ExampleRunner.eq(121, 16, new PalindromeGame().getMaximum(new String[] { ""aba"", ""cdc"", ""cdc"", ""cdc"" }, new int[] { 5, 3, 7, 4 }));
        ExampleRunner.eq(122, 1, new PalindromeGame().getMaximum(new String[] { ""abcba"" }, new int[] { 1 }));
        ExampleRunner.eq(123, 45, new PalindromeGame().getMaximum(new String[] { ""a"", ""a"", ""a"", ""b"", ""b"", ""b"" }, new int[] { 10, 10, 5, 10, 10, 3 }));
        ExampleRunner.eq(124, 10, new PalindromeGame().getMaximum(new String[] { ""abcd"", ""dcba"", ""abcd"", ""dcba"" }, new int[] { 1, 2, 3, 4 }));
        ExampleRunner.eq(125, 559, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""aba"", ""aba"", ""aba"" }, new int[] { 24, 7, 63, 222, 190, 20, 10, 30 }));
        ExampleRunner.eq(126, 72, new PalindromeGame().getMaximum(new String[] { ""abc"", ""aba"", ""cba"" }, new int[] { 23, 24, 25 }));
        ExampleRunner.eq(127, 87, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 87, 9, 1, 2, 1 }));
        ExampleRunner.eq(128, 12, new PalindromeGame().getMaximum(new String[] { ""aba"" }, new int[] { 12 }));
        ExampleRunner.eq(129, 37, new PalindromeGame().getMaximum(new String[] { ""abc"", ""eec"", ""cba"", ""cee"", ""abc"", ""ced"", ""cce"" }, new int[] { 7, 8, 9, 11, 9, 7, 8 }));
        ExampleRunner.eq(130, 4, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"" }, new int[] { 1, 2, 1 }));
        ExampleRunner.eq(131, 1002, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ba"", ""cc"", ""dd"" }, new int[] { 1, 1, 500, 1000 }));
        ExampleRunner.eq(132, 10, new PalindromeGame().getMaximum(new String[] { ""aa"", ""ab"", ""ab"", ""ba"", ""cd"", ""dc"", ""dc"" }, new int[] { 1, 1, 2, 3, 1, 2, 3 }));
        ExampleRunner.eq(133, 110, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""cba"" }, new int[] { 1, 10, 100 }));
        ExampleRunner.eq(134, 13, new PalindromeGame().getMaximum(new String[] { ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""onm"", ""lkj"", ""fed"", ""cba"", ""ihg"", ""pep"", ""mir"", ""rim"" }, new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }));
        ExampleRunner.eq(135, 6, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""ccc"" }, new int[] { 1, 2, 3 }));
        ExampleRunner.eq(136, 10, new PalindromeGame().getMaximum(new String[] { ""aba"", ""ddd"" }, new int[] { 5, 10 }));
        ExampleRunner.eq(137, 21, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"" }, new int[] { 5, 3, 4, 5, 4 }));
        ExampleRunner.eq(138, 20, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aca"" }, new int[] { 10, 20 }));
        ExampleRunner.eq(139, 1, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 1 }));
        ExampleRunner.eq(140, 30, new PalindromeGame().getMaximum(new String[] { ""aba"", ""cbc"" }, new int[] { 20, 30 }));
        ExampleRunner.eq(141, 12, new PalindromeGame().getMaximum(new String[] { ""aabbb"", ""aabaa"", ""aabaa"", ""aabaa"", ""bbbaa"", ""abbba"" }, new int[] { 2, 1, 2, 1, 2, 5 }));
        ExampleRunner.eq(142, 10, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aka"" }, new int[] { 5, 10 }));
        ExampleRunner.eq(143, 21, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""bbb"", ""aaa"", ""aba"", ""bba"", ""abb"", ""bab"", ""bba"", ""aba"", ""aab"", ""bab"", ""abb"", ""bba"", ""aba"", ""bba"", ""ada"" }, new int[] { 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3 }));
        ExampleRunner.eq(144, 4, new PalindromeGame().getMaximum(new String[] { ""aaab"", ""baaa"", ""baaa"" }, new int[] { 1, 2, 3 }));
        ExampleRunner.eq(145, 92, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""aaa"", ""aaa"", ""bbb"", ""bbb"", ""ccc"", ""ddd"", ""eee"" }, new int[] { 13, 13, 12, 11, 19, 17, 2, 7, 5 }));
        ExampleRunner.eq(146, 1000, new PalindromeGame().getMaximum(new String[] { ""aea"" }, new int[] { 1000 }));
        ExampleRunner.eq(147, 552, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 24, 77, 63, 222, 190 }));
        ExampleRunner.eq(148, 3, new PalindromeGame().getMaximum(new String[] { ""xxx"", ""xex"", ""xxx"" }, new int[] { 1, 1, 1 }));
        ExampleRunner.eq(149, 8, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""cba"" }, new int[] { 3, 2, 5 }));
        ExampleRunner.eq(150, 159, new PalindromeGame().getMaximum(new String[] { ""aa"", ""aa"", ""aa"", ""bb"", ""bb"", ""bb"", ""cc"", ""cc"", ""cc"", ""dd"", ""dd"", ""ab"", ""ba"" }, new int[] { 5, 6, 6, 10, 7, 10, 20, 6, 20, 30, 30, 10, 10 }));
        ExampleRunner.eq(151, 99, new PalindromeGame().getMaximum(new String[] { ""a"" }, new int[] { 99 }));
        ExampleRunner.eq(152, 7, new PalindromeGame().getMaximum(new String[] { ""topot"", ""reder"", ""redoc"" }, new int[] { 7, 5, 3 }));
        ExampleRunner.eq(153, 10, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""bbb"" }, new int[] { 4, 10 }));
        ExampleRunner.eq(154, 333, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"" }, new int[] { 3, 33, 333 }));
        ExampleRunner.eq(155, 5, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 5 }));
        ExampleRunner.eq(156, 0, new PalindromeGame().getMaximum(new String[] { ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"", ""absdfdasfasd"" }, new int[] { 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50 }));
        ExampleRunner.eq(157, 2499, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""aba"", ""xyx"" }, new int[] { 24, 7, 63, 222, 190, 1000, 2000 }));
        ExampleRunner.eq(158, 11, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aba"" }, new int[] { 1, 10 }));
        ExampleRunner.eq(159, 30, new PalindromeGame().getMaximum(new String[] { ""cac"", ""bab"", ""dad"", ""aaa"", ""bbb"", ""ccc"", ""aaa"", ""bbb"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8 }));
        ExampleRunner.eq(160, 49998775, new PalindromeGame().getMaximum(new String[] { ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"" }, new int[] { 1000000, 999999, 999998, 999997, 999996, 999995, 999994, 999993, 999992, 999991, 999990, 999989, 999988, 999987, 999986, 999985, 999984, 999983, 999982, 999981, 999980, 999979, 999978, 999977, 999976, 999975, 999974, 999973, 999972, 999971, 999970, 999969, 999968, 999967, 999966, 999965, 999964, 999963, 999962, 999961, 999960, 999959, 999958, 999957, 999956, 999955, 999954, 999953, 999952, 999951 }));
        ExampleRunner.eq(161, 50, new PalindromeGame().getMaximum(new String[] { ""ana"" }, new int[] { 50 }));
        ExampleRunner.eq(162, 8, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"" }, new int[] { 5, 1, 2 }));
        ExampleRunner.eq(163, 10, new PalindromeGame().getMaximum(new String[] { ""abbasabba"", ""laxmannnn"" }, new int[] { 10, 1 }));
        ExampleRunner.eq(164, 505, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""abc"" }, new int[] { 24, 7, 63, 222, 190, 30 }));
        ExampleRunner.eq(165, 14, new PalindromeGame().getMaximum(new String[] { ""bb"", ""bb"" }, new int[] { 7, 7 }));
        ExampleRunner.eq(166, 285, new PalindromeGame().getMaximum(new String[] { ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""top"", ""pot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"", ""tot"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }));
        ExampleRunner.eq(167, 6, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aba"", ""aaa"" }, new int[] { 1, 2, 3 }));
        ExampleRunner.eq(168, 9, new PalindromeGame().getMaximum(new String[] { ""abccba"", ""deffed"", ""abcdef"", ""fedcba"" }, new int[] { 1, 2, 3, 4 }));
        ExampleRunner.eq(169, 90, new PalindromeGame().getMaximum(new String[] { ""anuj"", ""adda"", ""baab"", ""baab"", ""baab"", ""juna"" }, new int[] { 5, 70, 5, 5, 5, 5 }));
        ExampleRunner.eq(170, 431, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ab"", ""cc"", ""ba"" }, new int[] { 1, 30, 400, 1 }));
        ExampleRunner.eq(171, 20, new PalindromeGame().getMaximum(new String[] { ""xyz"", ""xyz"", ""xyz"", ""aba"" }, new int[] { 1, 5, 6, 20 }));
        ExampleRunner.eq(172, 10, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"" }, new int[] { 10, 10 }));
        ExampleRunner.eq(173, 15, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"" }, new int[] { 7, 5, 3 }));
        ExampleRunner.eq(174, 1200, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"", ""c"" }, new int[] { 1000, 10, 100, 100 }));
        ExampleRunner.eq(175, 4, new PalindromeGame().getMaximum(new String[] { ""aa"", ""bb"" }, new int[] { 4, 4 }));
        ExampleRunner.eq(176, 3, new PalindromeGame().getMaximum(new String[] { ""a"", ""a"", ""a"" }, new int[] { 1, 1, 1 }));
        ExampleRunner.eq(177, 1000000, new PalindromeGame().getMaximum(new String[] { ""noon"" }, new int[] { 1000000 }));
        ExampleRunner.eq(178, 1090, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"", ""cba"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"", ""aaa"" }, new int[] { 7, 24, 63, 222, 190, 212, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12 }));
        ExampleRunner.eq(179, 4, new PalindromeGame().getMaximum(new String[] { ""top"", ""red"", ""red"", ""aba"", ""bab"" }, new int[] { 7, 5, 3, 2, 4 }));
        ExampleRunner.eq(180, 310, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""bbb"", ""aaa"", ""aaa"" }, new int[] { 50, 60, 100, 150 }));
        ExampleRunner.eq(181, 499, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 7, 24, 63, 222, 190 }));
        ExampleRunner.eq(182, 553, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""def"", ""cba"", ""fed"" }, new int[] { 24, 78, 63, 222, 190 }));
        ExampleRunner.eq(183, 2, new PalindromeGame().getMaximum(new String[] { ""abcba"" }, new int[] { 2 }));
        ExampleRunner.eq(184, 6, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""a"", ""a"" }, new int[] { 1, 2, 1, 3 }));
        ExampleRunner.eq(185, 18, new PalindromeGame().getMaximum(new String[] { ""aa"", ""ab"", ""ab"", ""ba"", ""cd"", ""dc"", ""dc"", ""as"", ""sa"", ""sa"", ""ew"", ""ew"", ""we"" }, new int[] { 1, 1, 2, 3, 1, 2, 3, 1, 3, 2, 3, 2, 1 }));
        ExampleRunner.eq(186, 15, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""cba"" }, new int[] { 1, 5, 10 }));
        ExampleRunner.eq(187, 2, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""bbb"" }, new int[] { 1, 2 }));
        ExampleRunner.eq(188, 0, new PalindromeGame().getMaximum(new String[] { ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"", ""qqqqqqqqqqqqqqqqqqqqqqqqqqqrrrgggggghhhh"" }, new int[] { 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 100000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 100000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 4353, 45, 345, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 4567, 1000000, 1000000, 1000000 }));
        ExampleRunner.eq(189, 24, new PalindromeGame().getMaximum(new String[] { ""asdsa"", ""werew"", ""qwert"", ""trewq"", ""zxcvb"", ""bvcxz"", ""qwert"", ""tgyht"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8 }));
        ExampleRunner.eq(190, 3, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aba"", ""ccc"", ""top"", ""pot"" }, new int[] { 1, 1, 1, 1, 1 }));
        ExampleRunner.eq(191, 40, new PalindromeGame().getMaximum(new String[] { ""abc"", ""cba"", ""cba"" }, new int[] { 10, 20, 30 }));
        ExampleRunner.eq(192, 5, new PalindromeGame().getMaximum(new String[] { ""a"", ""b"", ""c"" }, new int[] { 5, 5, 5 }));
        ExampleRunner.eq(193, 859, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aba"", ""xyx"", ""zyz"", ""abc"", ""cba"", ""cba"", ""def"", ""fed"", ""def"" }, new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 }));
        ExampleRunner.eq(194, 1244, new PalindromeGame().getMaximum(new String[] { ""aa"", ""bb"", ""cc"", ""dd"", ""ee"", ""aa"", ""bb"", ""cc"", ""dd"", ""ff"", ""ee"", ""ff"", ""gg"", ""hh"", ""ii"", ""jj"", ""kk"", ""ll"", ""mm"", ""nn"", ""oo"", ""pp"", ""qq"", ""rr"", ""ss"", ""tt"", ""uu"", ""vv"", ""ww"", ""xx"", ""yy"", ""gg"", ""hh"", ""ii"", ""jj"", ""kk"", ""ll"", ""mm"", ""nn"", ""oo"", ""pp"", ""qq"", ""rr"", ""ss"", ""tt"", ""uu"", ""vv"", ""ww"", ""xx"", ""zz"" }, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50 }));
        ExampleRunner.eq(195, 102, new PalindromeGame().getMaximum(new String[] { ""abc"", ""abc"", ""cba"" }, new int[] { 1, 100, 2 }));
        ExampleRunner.eq(196, 2300000, new PalindromeGame().getMaximum(new String[] { ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"", ""oooooooooooooooooooooooooooooooooooooooooooooooooo"" }, new int[] { 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 100000 }));
        ExampleRunner.eq(197, 800, new PalindromeGame().getMaximum(new String[] { ""fef"" }, new int[] { 800 }));
        ExampleRunner.eq(198, 11090531, new PalindromeGame().getMaximum(new String[] { ""abcdefghijklmnopqrstuvwxyz"", ""zyxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrqponmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdefghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrqponmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""aaaaaaaaaaaaaaaaaaaaaaaaaa"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""aaaaaaaaaaaaaaaaaaaaaaaaaa"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjhigfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjihgfedcba"", ""zyxwvutsrpqonmlkjihgfedcba"", ""ayxwvutsrqponmlkjihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""abcdfeghijklmnopqrstuvwxyz"", ""abcdefghijklmnopqrstuvwxzy"", ""yzxwvutsrqponmlkjiggfedcba"", ""bbbbbbbbbbbbbbbbbbbbbbbbbb"", ""ayxwvutsrqponmljkihgfedcbz"", ""zbcdefghijklmnopqrstuvwxya"", ""zzzzzzzzzzzzzzzzzzzzzzzzzz"", ""zzzzzzzzzzzzzzzzzzzzzzzzzz"" }, new int[] { 99, 8, 888, 1, 100000, 2, 8, 10000, 999999, 234244, 987898, 1000000, 1000000, 99, 8, 888, 1, 100000, 2, 8, 10000, 999999, 234244, 987898, 1000000, 1000000, 99, 8, 888, 1989, 100000, 2, 8, 10000, 999999, 234244, 987898, 1000000, 1000000, 99, 8, 808, 1908, 100000, 10000, 999999, 234244, 987898, 100000, 1000000 }));
        ExampleRunner.eq(199, 18, new PalindromeGame().getMaximum(new String[] { ""aaa"", ""aaa"", ""aaa"" }, new int[] { 5, 6, 7 }));
        ExampleRunner.eq(200, 23, new PalindromeGame().getMaximum(new String[] { ""aaa"" }, new int[] { 23 }));
        ExampleRunner.eq(201, 321, new PalindromeGame().getMaximum(new String[] { ""abba"", ""deed"" }, new int[] { 123, 321 }));
        ExampleRunner.eq(202, 102, new PalindromeGame().getMaximum(new String[] { ""abc"", ""aba"", ""cba"" }, new int[] { 1, 100, 1 }));
        ExampleRunner.eq(203, 103, new PalindromeGame().getMaximum(new String[] { ""ab"", ""ab"", ""ab"", ""ab"", ""ba"", ""ba"", ""ba"", ""ba"" }, new int[] { 10, 11, 12, 13, 14, 14, 14, 15 }));
        ExampleRunner.eq(204, 11, new PalindromeGame().getMaximum(new String[] { ""aba"", ""aba"" }, new int[] { 4, 7 }));
    }
",1
10067401,44,"    protected int findTheLargestPalindromeProductOfTwo3DigitNumbers() {
        int palindrome = 0;
        int max3DigitNumber = 999;
        int min3DigitNumber = 900;
        int max = max3DigitNumber * max3DigitNumber;
        int min = min3DigitNumber * min3DigitNumber;
        for (int i = max; i >= min; i--) {
            if (isPalindrome(i)) {
                for (int j = min3DigitNumber; j <= max3DigitNumber; j++) {
                    if (i % j == 0 && i / j <= max3DigitNumber) {
                        return i;
                    }
                }
            }
        }
        return palindrome;
    }
",1
10067402,44,"    protected int findTheLargestPalindromeProductOfTwo3DigitNumbers2() {
        int palindrome = 0;
        for (int a = 9; a > 0; a--) {
            for (int b = 9; b >= 0; b--) {
                for (int c = 9; c >= 0; c--) {
                    palindrome = 100001 * a + 10010 * b + 1100 * c;
                    for (int k = 90; k >= 10; k--) {
                        if (palindrome % k == 0) {
                            int n = palindrome / k / 11;
                            if (n >= 100 && n <= 999) {
                                return palindrome;
                            }
                        }
                    }
                }
            }
        }
        return palindrome;
    }
",1
10067404,44,"    public static void main(String[] args) {
        FindTheLargestPalindromeProductOfTwo3DigitNumbers sample = new FindTheLargestPalindromeProductOfTwo3DigitNumbers();
        int palindrome = sample.findTheLargestPalindromeProductOfTwo3DigitNumbers2();
        System.out.println(palindrome);
    }
",1
11560330,44,"    public boolean isPalindrome() {
        return palindrome;
    }
",0
11560331,44,"    public void setPalindromic(boolean palindrome) {
        this.palindrome = palindrome;
    }
",1
11674438,44,"    private String[] getWordContents() {
        boolean wasTranslating = GT.getDoTranslate();
        if (!wasTranslating) GT.setDoTranslate(true);
        String[] words = new String[] { ""modelSetMenu"", GT._(""No nodes loaded""), ""configurationComputedMenu"", GT._(""Configurations""), ""elementsComputedMenu"", GT._(""Element""), ""FRAMESbyModelComputedMenu"", GT._(""Model/Frame""), ""languageComputedMenu"", GT._(""Language""), ""PDBaaResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBnucleicResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBcarboResiduesComputedMenu"", GT._(""By Residue Name""), ""PDBheteroComputedMenu"", GT._(""By HETATM""), ""surfMoComputedMenu"", GT._(""Molecular Orbitals""), ""SYMMETRYComputedMenu"", GT._(""Symmetry""), ""hiddenModelSetText"", GT._(""Model information""), ""selectMenuText"", GT._(""Select ({0})""), ""allModelsText"", GT._(""All {0} models""), ""configurationMenuText"", GT._(""Configurations ({0})""), ""modelSetCollectionText"", GT._(""Collection of {0} models""), ""nodesText"", GT._(""nodes: {0}""), ""edgesText"", GT._(""edges: {0}""), ""groupsText"", GT._(""groups: {0}""), ""chainsText"", GT._(""chains: {0}""), ""polymersText"", GT._(""polymers: {0}""), ""modelMenuText"", GT._(""model {0}""), ""viewMenuText"", GT._(""View {0}""), ""mainMenuText"", GT._(""Main Menu""), ""biomoleculesMenuText"", GT._(""Biomolecules""), ""biomoleculeText"", GT._(""biomolecule {0} ({1} nodes)""), ""loadBiomoleculeText"", GT._(""load biomolecule {0} ({1} nodes)""), ""selectAll"", GT._(""All""), ""selectNone"", GT._(""None""), ""hideNotSelectedCheckbox"", GT._(""Display Selected Only""), ""invertSelection"", GT._(""Invert Selection""), ""viewMenu"", GT._(""View""), ""front"", GT._(""Front""), ""left"", GT._(""Left""), ""right"", GT._(""Right""), ""top"", GT._(""Top""), ""bottom"", GT._(""Bottom""), ""back"", GT._(""Back""), ""renderMenu"", GT._(""Style""), ""renderSchemeMenu"", GT._(""Scheme""), ""renderBallAndStick"", GT._(""Ball and Stick""), ""renderWireframe"", GT._(""Wireframe""), ""nodeMenu"", GT._(""Nodes""), ""nodeNone"", GT._(""Off""), ""node15"", GT._(""Small size"", ""15""), ""node20"", GT._(""Small size + 5%"", ""20""), ""node25"", GT._(""Small size + 10%"", ""25""), ""node50"", GT._(""Medium size"", ""50""), ""node75"", GT._(""Medium size + 25%"", ""75""), ""node100"", GT._(""Full size"", ""100""), ""edgeMenu"", GT._(""Edges""), ""edgeNone"", GT._(""Off""), ""edgeWireframe"", GT._(""On""), ""edge20"", GT._(""{0}"", ""0.02""), ""edge50"", GT._(""{0}"", ""0.05""), ""edge100"", GT._(""{0}"", ""0.10""), ""edge150"", GT._(""{0}"", ""0.15""), ""edge200"", GT._(""{0}"", ""0.20""), ""edge250"", GT._(""{0}"", ""0.25""), ""stereoMenu"", GT._(""Stereographic""), ""stereoNone"", GT._(""None""), ""stereoRedCyan"", GT._(""Red+Cyan glasses""), ""stereoRedBlue"", GT._(""Red+Blue glasses""), ""stereoRedGreen"", GT._(""Red+Green glasses""), ""stereoCrossEyed"", GT._(""Cross-eyed viewing""), ""stereoWallEyed"", GT._(""Wall-eyed viewing""), ""labelMenu"", GT._(""Labels""), ""labelNone"", GT._(""None""), ""labelName"", GT._(""With Node Name""), ""labelNumber"", GT._(""With Node Number""), ""labelPositionMenu"", GT._(""Position Label on Node""), ""labelCentered"", GT._(""Centered""), ""labelUpperRight"", GT._(""Upper Right""), ""labelLowerRight"", GT._(""Lower Right""), ""labelUpperLeft"", GT._(""Upper Left""), ""labelLowerLeft"", GT._(""Lower Left""), ""colorMenu"", GT._(""Color""), ""[color_nodes]Menu"", GT._(""Nodes""), ""none"", GT._(""Inherit""), ""black"", GT._(""Black""), ""white"", GT._(""White""), ""cyan"", GT._(""Cyan""), ""red"", GT._(""Red""), ""orange"", GT._(""Orange""), ""yellow"", GT._(""Yellow""), ""green"", GT._(""Green""), ""blue"", GT._(""Blue""), ""indigo"", GT._(""Indigo""), ""violet"", GT._(""Violet""), ""salmon"", GT._(""Salmon""), ""olive"", GT._(""Olive""), ""maroon"", GT._(""Maroon""), ""gray"", GT._(""Gray""), ""slateblue"", GT._(""Slate Blue""), ""gold"", GT._(""Gold""), ""orchid"", GT._(""Orchid""), ""opaque"", GT._(""Make Opaque""), ""translucent"", GT._(""Make Translucent""), ""[color_edges]Menu"", GT._(""Edges""), ""[color_labels]Menu"", GT._(""Labels""), ""[color_background]Menu"", GT._(""Background""), ""[color_vectors]Menu"", GT._(""Vectors""), ""[color_axes]Menu"", GT._(""Axes""), ""[color_boundbox]Menu"", GT._(""Boundbox""), ""zoomMenu"", GT._(""Zoom""), ""zoom50"", ""50%"", ""zoom100"", ""100%"", ""zoom150"", ""150%"", ""zoom200"", ""200%"", ""zoom400"", ""400%"", ""zoom800"", ""800%"", ""zoomIn"", GT._(""Zoom In""), ""zoomOut"", GT._(""Zoom Out""), ""FRAMESanimateMenu"", GT._(""Animation""), ""animModeMenu"", GT._(""Animation Mode""), ""onceThrough"", GT._(""Play Once""), ""palindrome"", GT._(""Palindrome""), ""loop"", GT._(""Loop""), ""play"", GT._(""Play""), ""pause"", GT._(""Pause""), ""resume"", GT._(""Resume""), ""stop"", GT._(""Stop""), ""nextframe"", GT._(""Next Frame""), ""prevframe"", GT._(""Previous Frame""), ""rewind"", GT._(""Rewind""), ""playrev"", GT._(""Reverse""), ""restart"", GT._(""Restart""), ""FRAMESanimFpsMenu"", GT._(""Set FPS""), ""animfps5"", ""5"", ""animfps10"", ""10"", ""animfps20"", ""20"", ""animfps30"", ""30"", ""animfps50"", ""50"", ""SIGNEDwriteMenu"", GT._(""Save""), ""writeFileTextVARIABLE"", GT._(""File {0}""), ""writeState"", GT._(""Script with state""), ""writeHistory"", GT._(""Script with history""), ""writeJpg"", GT._(""{0} Image"", ""JPG""), ""writePng"", GT._(""{0} Image"", ""PNG""), ""[set_axes]Menu"", GT._(""Axes""), ""[set_boundbox]Menu"", GT._(""Boundbox""), ""[set_UNITCELL]Menu"", GT._(""Unit cell""), ""off#axes"", GT._(""Hide""), ""dotted"", GT._(""Dotted""), ""byPixelMenu"", GT._(""Pixel Width""), ""1p"", GT._(""{0} px"", ""1""), ""3p"", GT._(""{0} px"", ""3""), ""5p"", GT._(""{0} px"", ""5""), ""10p"", GT._(""{0} px"", ""10""), ""byAngstromMenu"", GT._(""Angstrom Width""), ""10a"", GT._(""{0} Å"", ""0.10""), ""20a"", GT._(""{0} Å"", ""0.20""), ""25a"", GT._(""{0} Å"", ""0.25""), ""50a"", GT._(""{0} Å"", ""0.50""), ""100a"", GT._(""{0} Å"", ""1.0""), ""showSelectionsCheckbox"", GT._(""Selection Halos""), ""showHydrogensCheckbox"", GT._(""Show Hydrogens""), ""showMeasurementsCheckbox"", GT._(""Show Measurements""), ""perspectiveDepthCheckbox"", GT._(""Perspective Depth""), ""showBoundBoxCheckbox"", GT._(""Boundbox""), ""showAxesCheckbox"", GT._(""Axes""), ""showUNITCELLCheckbox"", GT._(""Unit cell""), ""colorrasmolCheckbox"", GT._(""RasMol Colors""), ""aboutComputedMenu"", GT._(""About Jnet"") };
        if (!wasTranslating) GT.setDoTranslate(wasTranslating);
        return words;
    }
",1
11976309,44,"    public static void main(String[] args) {
        System.out.println(""abba"".equals(new PalindromeDecoding().decode(""ab"", new int[] { 0 }, new int[] { 2 })));
        System.out.println(""Mississippi"".equals(new PalindromeDecoding().decode(""Misip"", new int[] { 2, 3, 1, 7 }, new int[] { 1, 1, 2, 2 })));
        System.out.println(""XYYXXYYXXYYXXYYXXYYXXYYXXYYXXYYX"".equals(new PalindromeDecoding().decode(""XY"", new int[] { 0, 0, 0, 0 }, new int[] { 2, 4, 8, 16 })));
    }
",1
12453210,44,"    public void testReplaceMethodOverrideWithSetterInjection() {
        DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
        reader.setValidating(true);
        reader.loadBeanDefinitions(new ClassPathResource(""delegationOverrides.xml"", getClass()));
        OverrideOneMethod oom = (OverrideOneMethod) xbf.getBean(""overrideOneMethod"");
        TestBean jenny1 = oom.getPrototypeDependency();
        assertEquals(""Jenny"", jenny1.getName());
        TestBean jenny2 = oom.getPrototypeDependency();
        assertEquals(""Jenny"", jenny2.getName());
        assertNotSame(jenny1, jenny2);
        TestBean dave1 = oom.protectedOverrideSingleton();
        assertEquals(""David"", dave1.getName());
        TestBean dave2 = oom.protectedOverrideSingleton();
        assertEquals(""David"", dave2.getName());
        assertSame(dave1, dave2);
        String str = ""woierowijeiowiej"";
        assertEquals(str, oom.echo(str));
        String s = ""this is not a palindrome"";
        String reverse = new StringBuffer(s).reverse().toString();
        assertEquals(""Should have overridden to reverse, not echo"", reverse, oom.replaceMe(s));
        assertEquals(""Should have overridden no-arg overloaded replaceMe method to return fixed value"", FixedMethodReplacer.VALUE, oom.replaceMe());
        OverrideOneMethodSubclass ooms = (OverrideOneMethodSubclass) xbf.getBean(""replaceVoidMethod"");
        DoSomethingReplacer dos = (DoSomethingReplacer) xbf.getBean(""doSomethingReplacer"");
        assertEquals(null, dos.lastArg);
        String s1 = """";
        String s2 = ""foo bar black sheep"";
        ooms.doSomething(s1);
        assertEquals(s1, dos.lastArg);
        ooms.doSomething(s2);
        assertEquals(s2, dos.lastArg);
    }
",1
13179361,44,"    void setAnimationReplayMode(int animationReplayMode, float firstFrameDelay, float lastFrameDelay) {
        this.firstFrameDelay = firstFrameDelay > 0 ? firstFrameDelay : 0;
        firstFrameDelayMs = (int) (this.firstFrameDelay * 1000);
        this.lastFrameDelay = lastFrameDelay > 0 ? lastFrameDelay : 0;
        lastFrameDelayMs = (int) (this.lastFrameDelay * 1000);
        if (animationReplayMode >= ANIMATION_ONCE && animationReplayMode <= ANIMATION_PALINDROME) this.animationReplayMode = animationReplayMode; else Logger.error(""invalid animationReplayMode:"" + animationReplayMode);
    }
",1
13179373,44,"    boolean setAnimationRelative(int direction) {
        int frameStep = this.frameStep * direction * currentDirection;
        int modelIndexNext = currentModelIndex + frameStep;
        boolean isDone = (modelIndexNext > firstModelIndex && modelIndexNext > lastModelIndex || modelIndexNext < firstModelIndex && modelIndexNext < lastModelIndex);
        if (isDone) {
            switch(animationReplayMode) {
                case ANIMATION_ONCE:
                    return false;
                case ANIMATION_LOOP:
                    modelIndexNext = (animationDirection == currentDirection ? firstModelIndex : lastModelIndex);
                    break;
                case ANIMATION_PALINDROME:
                    currentDirection = -currentDirection;
                    modelIndexNext -= 2 * frameStep;
            }
        }
        int nModels = viewer.getModelCount();
        if (modelIndexNext < 0 || modelIndexNext >= nModels) return false;
        setCurrentModelIndex(modelIndexNext);
        return true;
    }
",1
13179374,44,"    String getAnimationModeName() {
        switch(animationReplayMode) {
            case ANIMATION_LOOP:
                return ""LOOP"";
            case ANIMATION_PALINDROME:
                return ""PALINDROME"";
            default:
                return ""ONCE"";
        }
    }
",1
13839382,44,"    private int solve(int result, int[] m, int pos) {
        if (m.length == pos) {
            if (isPalindrome(m)) {
                return result;
            }
            return Integer.MAX_VALUE;
        }
        if (m[pos] == 0) {
            m[pos] = 1;
            int solve1 = solve(result + oCost, m, pos + 1);
            m[pos] = -1;
            int solve2 = solve(result + xCost, m, pos + 1);
            m[pos] = 0;
            return Math.min(solve1, solve2);
        }
        return solve(result, m, pos + 1);
    }
",0
13839384,44,"    public static void main(String[] args) {
        System.out.println(8 == new MinCostPalindrome().getMinimum(""oxo?xox?"", 3, 5));
    }
",1
14321901,44,"    public void testProblem4() {
        NaturalNumberStream naturalNumberStream = new NaturalNumberStream(1, 999);
        BaseListStream2<Integer, Integer, Integer> cartesianProduct = new BaseListStream2<Integer, Integer, Integer>(naturalNumberStream, naturalNumberStream) {

            public Integer invoke(Integer input0, Integer input1, int index) {
                return input0 * input1;
            }
        };
        ListFilterStream<Integer> filter = new BaseListFilterStream<Integer>(cartesianProduct) {

            public boolean evaluate(Integer object) {
                return palindrome(object);
            }
        };
        MaxAccumulator accumulator = new MaxAccumulator(filter);
        System.out.println(accumulator.getValue());
        assertEquals(new Integer(906609), accumulator.getValue());
    }
",1
14321903,44,"            public boolean evaluate(Integer object) {
                return palindrome(object);
            }
",0
14321904,44,"    public static boolean palindrome(int input) {
        String inputAsStreing = """" + input;
        int stringLength = inputAsStreing.length();
        for (int i = 0; i < stringLength / 2; i++) {
            if (inputAsStreing.charAt(i) != inputAsStreing.charAt(stringLength - 1 - i)) return false;
        }
        return true;
    }
",1
14321905,44,"    public void testPalindrome() {
        assertTrue(palindrome(1001));
        assertFalse(palindrome(1011));
    }
",1
14357839,44,"    @Override
    public void setUp() throws Exception {
        super.setUp();
        directory = new RAMDirectory();
        Analyzer analyzer = new Analyzer() {

            @Override
            public TokenStream tokenStream(String fieldName, Reader reader) {
                return new WhitespaceTokenizer(reader);
            }

            @Override
            public int getPositionIncrementGap(String fieldName) {
                return 100;
            }
        };
        IndexWriter writer = new IndexWriter(directory, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
        Document doc = new Document();
        doc.add(new Field(""field"", ""one two three four five"", Field.Store.YES, Field.Index.ANALYZED));
        doc.add(new Field(""repeated"", ""this is a repeated field - first part"", Field.Store.YES, Field.Index.ANALYZED));
        Fieldable repeatedField = new Field(""repeated"", ""second part of a repeated field"", Field.Store.YES, Field.Index.ANALYZED);
        doc.add(repeatedField);
        doc.add(new Field(""palindrome"", ""one two three two one"", Field.Store.YES, Field.Index.ANALYZED));
        writer.addDocument(doc);
        doc = new Document();
        doc.add(new Field(""nonexist"", ""phrase exist notexist exist found"", Field.Store.YES, Field.Index.ANALYZED));
        writer.addDocument(doc);
        doc = new Document();
        doc.add(new Field(""nonexist"", ""phrase exist notexist exist found"", Field.Store.YES, Field.Index.ANALYZED));
        writer.addDocument(doc);
        writer.optimize();
        writer.close();
        searcher = new IndexSearcher(directory, true);
        query = new PhraseQuery();
    }
",1
14357855,44,"    public void testPalyndrome2() throws Exception {
        query.setSlop(0);
        query.add(new Term(""field"", ""two""));
        query.add(new Term(""field"", ""three""));
        ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""phrase found with exact phrase scorer"", 1, hits.length);
        float score0 = hits[0].score;
        QueryUtils.check(query, searcher);
        query.setSlop(2);
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score1 = hits[0].score;
        assertEquals(""exact scorer and sloppy scorer score the same when slop does not matter"", score0, score1, SCORE_COMP_THRESH);
        QueryUtils.check(query, searcher);
        query = new PhraseQuery();
        query.setSlop(2);
        query.add(new Term(""palindrome"", ""two""));
        query.add(new Term(""palindrome"", ""three""));
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score2 = hits[0].score;
        QueryUtils.check(query, searcher);
        query = new PhraseQuery();
        query.setSlop(2);
        query.add(new Term(""palindrome"", ""three""));
        query.add(new Term(""palindrome"", ""two""));
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score3 = hits[0].score;
        QueryUtils.check(query, searcher);
    }
",1
14357856,44,"    public void testPalyndrome3() throws Exception {
        query.setSlop(0);
        query.add(new Term(""field"", ""one""));
        query.add(new Term(""field"", ""two""));
        query.add(new Term(""field"", ""three""));
        ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""phrase found with exact phrase scorer"", 1, hits.length);
        float score0 = hits[0].score;
        QueryUtils.check(query, searcher);
        query.setSlop(4);
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score1 = hits[0].score;
        assertEquals(""exact scorer and sloppy scorer score the same when slop does not matter"", score0, score1, SCORE_COMP_THRESH);
        QueryUtils.check(query, searcher);
        query = new PhraseQuery();
        query.setSlop(4);
        query.add(new Term(""palindrome"", ""one""));
        query.add(new Term(""palindrome"", ""two""));
        query.add(new Term(""palindrome"", ""three""));
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score2 = hits[0].score;
        QueryUtils.check(query, searcher);
        query = new PhraseQuery();
        query.setSlop(4);
        query.add(new Term(""palindrome"", ""three""));
        query.add(new Term(""palindrome"", ""two""));
        query.add(new Term(""palindrome"", ""one""));
        hits = searcher.search(query, null, 1000).scoreDocs;
        assertEquals(""just sloppy enough"", 1, hits.length);
        float score3 = hits[0].score;
        QueryUtils.check(query, searcher);
    }
",1
15588498,44,"    private static int tryIterations(int number, BigInteger currentSum, int iterationNumber) {
        if (iterationNumber > iterationLimit) {
            return -1;
        }
        if (PalindromeUtil.checkPalindrome(currentSum) && currentSum.compareTo(BigInteger.valueOf(9)) > 0 && iterationNumber != 1) {
            return iterationNumber;
        }
        BigInteger reverse = PalindromeUtil.reverse(currentSum);
        BigInteger reverseSum = currentSum.add(reverse);
        if (PalindromeUtil.checkPalindrome(reverseSum) && currentSum.compareTo(BigInteger.valueOf(9)) > 0) {
            return iterationNumber;
        }
        int attempt = tryIterations(number, reverseSum, iterationNumber + 1);
        if (attempt != -1) {
            if (reverseSum.compareTo(BigInteger.valueOf(10001l)) < 0) {
                int ival = reverseSum.intValue();
                attempts[ival] = (attempt - iterationNumber);
            }
        }
        return attempt;
    }
",1
16152855,44,"    public static void main(String[] args) {
        final List<Integer> temp = new ArrayList<Integer>();
        for (int i = 999; i > 1; i--) for (int j = 999; j > 1; j--) {
            final int k = i * j;
            if (isPalindrome(String.valueOf(k))) temp.add(k);
        }
        Collections.sort(temp);
        System.out.println(temp.get(temp.size() - 1));
    }
",1
16491811,44,"    public void DONT_testPalindrome3() throws CalamariException {
        doTestBooleanExamples(EXAMPLES_PALINDROME_3, EXAMPLES_PALINDROME_3);
    }
",0
16491812,44,"    public void DONT_testPalindrome4() throws CalamariException {
        doTestBooleanExamples(EXAMPLES_PALINDROME_4, EXAMPLES_PALINDROME_4);
    }
",0
16896239,44,"    public static void main(String[] args) {
        BigInt sum = BigInt.from(0L);
        for (int i = 0; i < 1000000; i++) {
            if (isDecimalPalindrome(i) && isBinaryPalindrome(i)) {
                sum = sum.plus(String.valueOf(i));
            }
        }
        System.out.println(sum);
    }
",1
16896240,44,"    private static boolean isBinaryPalindrome(Integer i) {
        return PalindromeChecker.test(Integer.toBinaryString(i));
    }
",0
16896241,44,"    private static boolean isDecimalPalindrome(Integer i) {
        return PalindromeChecker.test(i.toString());
    }
",0
18072334,44,"    private void setDefaultValues() {
        setParameter(PARAM_primerFile, """");
        setParameter(PARAM_ampliconsFile, """");
        setParameter(PARAM_numBarcodesPerPrimerPair, ""100"");
        setParameter(PARAM_barcodeLength, ""10"");
        setParameter(PARAM_fivePrimeClamp, ""CG"");
        setParameter(PARAM_maxFlows, ""5"");
        setParameter(PARAM_flowSequence, ""TACG"");
        setParameter(PARAM_keyChar, ""TCAG"");
        setParameter(PARAM_minEditDistance, ""3"");
        setParameter(PARAM_minPalindromeHBonds, ""14"");
        setParameter(PARAM_maxPalindromeMateDistance, ""11"");
        setParameter(PARAM_intDimerMaxScore, ""8"");
        setParameter(PARAM_endDimerMaxScore, ""3"");
        setParameter(PARAM_forwardPrimerAdapterSequence, """");
        setParameter(PARAM_reversePrimerAdapterSequence, """");
        setParameter(PARAM_attachBarcodeToForwardPrimer, ""false"");
        setParameter(PARAM_attachBarcodeToReversePrimer, ""false"");
        this.taskName = TASK_NAME;
    }
",1
18072335,44,"    public ParameterVO getParameterVO(String key) throws ParameterException {
        if (key == null) return null;
        String value = getParameter(key);
        if (value == null) return null;
        if (key.equals(PARAM_numBarcodesPerPrimerPair)) {
            return new DoubleParameterVO(1, 1000, 100);
        }
        if (key.equals(PARAM_barcodeLength)) {
            return new DoubleParameterVO(1, 100, 10);
        }
        if (key.equals(PARAM_maxFlows)) {
            return new DoubleParameterVO(1, 10, 5);
        }
        if (key.equals(PARAM_minEditDistance)) {
            return new DoubleParameterVO(1, 100, 3);
        }
        if (key.equals(PARAM_minPalindromeHBonds)) {
            return new DoubleParameterVO(1, 100, 14);
        }
        if (key.equals(PARAM_maxPalindromeMateDistance)) {
            return new DoubleParameterVO(1, 100, 11);
        }
        if (key.equals(PARAM_intDimerMaxScore)) {
            return new DoubleParameterVO(1, 100, 8);
        }
        if (key.equals(PARAM_endDimerMaxScore)) {
            return new DoubleParameterVO(1, 100, 3);
        }
        if (key.equals(PARAM_fivePrimeClamp) || key.equals(PARAM_flowSequence) || key.equals(PARAM_keyChar) || key.equals(PARAM_forwardPrimerAdapterSequence) || key.equals(PARAM_reversePrimerAdapterSequence)) {
            return new TextParameterVO(value);
        }
        if (key.equals(PARAM_primerFile) || key.equals(PARAM_ampliconsFile)) {
            return new MultiSelectVO(listOfStringsFromCsvString(value), listOfStringsFromCsvString(value));
        }
        if (key.equals(PARAM_attachBarcodeToForwardPrimer) || key.equals(PARAM_attachBarcodeToReversePrimer)) {
            return new BooleanParameterVO(Boolean.valueOf(value));
        }
        return null;
    }
",1
18245809,44,"    public void testConverterPalindromeClosuers() throws IOException {
        String in = ""aaaa _bb bb_ ccc *dd dd* eeee"";
        ByteArrayInputStream is = new ByteArrayInputStream(in.getBytes());
        converter.parse(is);
        checkResult(""aaaa <i>bb bb</i> ccc <strong>dd dd</strong> eeee"");
    }
",1
18245810,44,"    public void testConverterNonPalindromeClosuers() throws IOException {
        String in = ""aaaa _bb bb* ccc _dd dd* eeee"";
        ByteArrayInputStream is = new ByteArrayInputStream(in.getBytes());
        converter.parse(is);
        checkResult(""aaaa <i>bb bb<strong> ccc </i>dd dd</strong> eeee"");
    }
",1
18245811,44,"    public void testTitlePalindromeClosures() throws IOException {
        String in = ""=title one= ==title two== *bold*"";
        ByteArrayInputStream is = new ByteArrayInputStream(in.getBytes());
        converter.parse(is);
        checkResult(""<h1>title one</h1> <h2>title two</h2> <strong>bold</strong>"");
    }
",1
18245812,44,"    public void testTitleNonPalindromeClosures() throws IOException {
        String in = ""=title one== =title two== *bold*"";
        ByteArrayInputStream is = new ByteArrayInputStream(in.getBytes());
        converter.parse(is);
        checkResult(""<h1>title one</h1> <h1>title two</h1> <strong>bold</strong>"");
    }
",0
19418632,44,"        @Override
        String[] getSupportFileNames() {
            String[] fileNames = new String[9];
            String imagePath = ""org/openscience/jmol/app/images/"";
            fileNames[0] = imagePath + ""lastButton.png"";
            fileNames[1] = imagePath + ""playButton.png"";
            fileNames[2] = imagePath + ""playLoopButton.png"";
            fileNames[3] = imagePath + ""playOnceButton.png"";
            fileNames[4] = imagePath + ""playPalindromeButton.png"";
            fileNames[5] = imagePath + ""prevButton.png"";
            fileNames[6] = imagePath + ""pauseButton.png"";
            fileNames[7] = imagePath + ""nextButton.png"";
            fileNames[8] = imagePath + ""firstButton.png"";
            return (fileNames);
        }
",1
19418633,44,"        @Override
        String getJavaScript(int appletID, JmolInstance instance) {
            String jsString = ""<table id=\""AnimContrl\"" class=\""AnimContrlCSS\"">"";
            jsString += ""<tbody><tr><td>"" + GT.escapeHTML(GT._(""Animation"")) + ""</td></tr><tr><td><table><tbody>"";
            jsString += ""<tr><td><button title=\"""" + GT.escapeHTML(GT._(""First Frame"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame rewind\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""firstButton.png\""></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Previous Frame"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame previous\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""prevButton.png\"" ></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Play"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame play\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""playButton.png\""></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Next Frame"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame next\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""nextButton.png\""></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Pause"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame pause\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""pauseButton.png\""></button></td>"";
            jsString += ""<td><button title=\"""" + GT.escapeHTML(GT._(""Last Frame"")) + ""\"" onclick=\""void(jmolScriptWait(\'frame last\',"" + appletID + ""));\"">"";
            jsString += ""<img src = \""lastButton.png\""></button></td>"";
            jsString += ""</tr></tbody></table><table><tbody><tr><td>"" + GT.escapeHTML(GT._(""Mode:"")) + ""</td>"";
            jsString += ""<td id=\""jmol_loop_"" + appletID + ""\""><button title=\"""" + GT.escapeHTML(GT._(""Loop"")) + ""\"" onclick=\""jmol_animationmode(\'loop\',"" + appletID + "");\"">"";
            jsString += ""<img src = \""playLoopButton.png\"" ></button></td>"";
            jsString += ""<td id=\""jmol_palindrome_"" + appletID + ""\""><button title=\"""" + GT.escapeHTML(GT._(""Palindrome"")) + ""\"" onclick=\""jmol_animationmode(\'palindrome\', "" + appletID + "");\"">"";
            jsString += ""<img src = \""playPalindromeButton.png\"" ></button></td>"";
            jsString += ""<td id=\""jmol_playOnce_"" + appletID + ""\"" style=\""background:blue;\""><button title=\"""" + GT.escapeHTML(GT._(""Play Once"")) + ""\"" style=\""font-size:0px\"" onclick=\""jmol_animationmode(\'playOnce\', "" + appletID + "");\"">"";
            jsString += ""<img src = \""playOnceButton.png\"" ></button></td></tr></tbody></table></td></tr></tbody></table>"";
            return (jsString);
        }
",1
19692114,44,"    protected int slideWindow(StringBuffer s) {
        StringBuffer r = new StringBuffer(s);
        r.reverse();
        int max_count = 0;
        int max_i = 0;
        int max_j = 0;
        for (int i = 0; i < s.length(); i++) {
            int counter = 0;
            for (int j = i; j < r.length(); j++) {
                if (s.charAt(j) == Statics.getAcidComp(r.charAt(j))) {
                    counter++;
                } else {
                    if (counter > max_count) {
                        max_count = counter;
                        max_i = j - counter;
                        max_j = j;
                    }
                    counter = 0;
                }
            }
        }
        if (max_count > 9999) {
            System.out.println(s);
            for (int i = 0; i < r.length(); i++) {
                System.out.print(Statics.getAcidComp(r.charAt(i)));
            }
            System.out.print(""\n"");
            if ((max_i + max_j) == s.length()) {
                System.out.println(""Is Palindrome"");
            }
            System.out.println(""Max Count: "" + max_count);
            System.out.println(""Start: "" + max_i);
            System.out.println(""End: "" + max_j);
        }
        return max_count;
    }
",1
19910710,44,"    public static void main(String[] args) {
        Integer max = null;
        for (int x = 999; x > 0; x--) {
            for (int y = 999; y > 0; y--) {
                int possiblePalindrome = x * y;
                if (PalindromeChecker.test("""" + possiblePalindrome)) {
                    if (max == null) {
                        max = possiblePalindrome;
                    }
                    if (possiblePalindrome > max) {
                        max = possiblePalindrome;
                    }
                }
            }
        }
        System.out.println(max);
    }
",1
20449037,44,"    private void setupLabels() {
        labels = new Hashtable<String, String>();
        labels.put(""macros"", GT._(""&Macros""));
        labels.put(""file"", GT._(""&File""));
        labels.put(""newwin"", GT._(""&New""));
        labels.put(""open"", GT._(""&Open""));
        labels.put(""openTip"", GT._(""Open a file.""));
        labels.put(""openurl"", GT._(""Open &URL""));
        labels.put(""openpdb"", GT._(""&Get PDB""));
        labels.put(""openmol"", GT._(""Get &MOL""));
        labels.put(""reloadScript"", GT._(""&Reload""));
        labels.put(""openJSpecViewScript"", ""JSpecView"");
        labels.put(""editor"", GT._(""Scrip&t Editor...""));
        labels.put(""console"", GT._(""Conso&le...""));
        labels.put(""jconsole"", GT._(""Jmol Java &Console""));
        labels.put(""atomsetchooser"", GT._(""AtomSet&Chooser...""));
        labels.put(""saveas"", GT._(""&Save As...""));
        labels.put(""exportMenu"", GT._(""&Export""));
        labels.put(""export"", GT._(""Export &Image...""));
        labels.put(""exportTip"", GT._(""Save current view as an image.""));
        labels.put(""toweb"", GT._(""Export to &Web Page...""));
        labels.put(""towebTip"", GT._(""Export one or more views to a web page.""));
        labels.put(""povray"", GT._(""Render in POV-&Ray...""));
        labels.put(""povrayTip"", GT._(""Render in POV-Ray""));
        labels.put(""write"", GT._(""Write &State...""));
        labels.put(""writeTip"", GT._(""Save current view as a Jmol state script.""));
        labels.put(""print"", GT._(""&Print...""));
        labels.put(""printTip"", GT._(""Print view.""));
        labels.put(""close"", GT._(""&Close""));
        labels.put(""exit"", GT._(""E&xit""));
        labels.put(""recentFiles"", GT._(""Recent &Files...""));
        labels.put(""edit"", GT._(""&Edit""));
        labels.put(""selectall"", GT._(""Select &All""));
        labels.put(""deselectall"", GT._(""Deselect All""));
        labels.put(""copyImage"", GT._(""Copy &Image""));
        labels.put(""copyScript"", GT._(""Copy Script""));
        labels.put(""prefs"", GT._(""Pr&eferences...""));
        labels.put(""pasteClipboard"", GT._(""&Paste""));
        labels.put(""editSelectAllScript"", GT._(""Select &All""));
        labels.put(""selectMenu"", GT._(""&Select""));
        labels.put(""selectMenuText"", GT._(""&Select""));
        labels.put(""selectAllScript"", GT._(""&All""));
        labels.put(""selectNoneScript"", GT._(""&None""));
        labels.put(""selectHydrogenScript"", GT._(""Hydrogen""));
        labels.put(""selectCarbonScript"", GT._(""Carbon""));
        labels.put(""selectNitrogenScript"", GT._(""Nitrogen""));
        labels.put(""selectOxygenScript"", GT._(""Oxygen""));
        labels.put(""selectPhosphorusScript"", GT._(""Phosphorus""));
        labels.put(""selectSulfurScript"", GT._(""Sulfur""));
        labels.put(""selectAminoScript"", GT._(""Amino""));
        labels.put(""selectNucleicScript"", GT._(""Nucleic""));
        labels.put(""selectWaterScript"", GT._(""Water""));
        labels.put(""selectHeteroScript"", GT._(""Hetero""));
        labels.put(""display"", GT._(""&Display""));
        labels.put(""atomMenu"", GT._(""&Atom""));
        labels.put(""atomNoneScript"", GT._(""&None""));
        labels.put(""atom15Script"", GT._(""{0}% van der Waals"", ""15""));
        labels.put(""atom20Script"", GT._(""{0}% van der Waals"", ""20""));
        labels.put(""atom25Script"", GT._(""{0}% van der Waals"", ""25""));
        labels.put(""atom100Script"", GT._(""{0}% van der Waals"", ""100""));
        labels.put(""bondMenu"", GT._(""&Bond""));
        labels.put(""bondNoneScript"", GT._(""&None""));
        labels.put(""bondWireframeScript"", GT._(""&Wireframe""));
        labels.put(""bond100Script"", GT._(""{0} Å"", ""0.10""));
        labels.put(""bond150Script"", GT._(""{0} Å"", ""0.15""));
        labels.put(""bond200Script"", GT._(""{0} Å"", ""0.20""));
        labels.put(""labelMenu"", GT._(""&Label""));
        labels.put(""labelNoneScript"", GT._(""&None""));
        labels.put(""labelSymbolScript"", GT._(""&Symbol""));
        labels.put(""labelNameScript"", GT._(""&Name""));
        labels.put(""labelNumberScript"", GT._(""&Number""));
        labels.put(""labelCenteredScript"", GT._(""&Centered""));
        labels.put(""labelUpperRightScript"", GT._(""&Upper right""));
        labels.put(""vectorMenu"", GT._(""&Vector""));
        labels.put(""vectorOffScript"", GT._(""&None""));
        labels.put(""vectorOnScript"", GT._(""&On""));
        labels.put(""vector3Script"", GT._(""{0} pixels"", ""3""));
        labels.put(""vector005Script"", GT._(""{0} Å"", ""0.05""));
        labels.put(""vector01Script"", GT._(""{0} Å"", ""0.1""));
        labels.put(""vectorScale02Script"", GT._(""Scale {0}"", ""0.2""));
        labels.put(""vectorScale05Script"", GT._(""Scale {0}"", ""0.5""));
        labels.put(""vectorScale1Script"", GT._(""Scale {0}"", ""1""));
        labels.put(""vectorScale2Script"", GT._(""Scale {0}"", ""2""));
        labels.put(""vectorScale5Script"", GT._(""Scale {0}"", ""5""));
        labels.put(""zoomMenu"", GT._(""&Zoom""));
        labels.put(""zoom100Script"", GT._(""{0}%"", ""100""));
        labels.put(""zoom150Script"", GT._(""{0}%"", ""150""));
        labels.put(""zoom200Script"", GT._(""{0}%"", ""200""));
        labels.put(""zoom400Script"", GT._(""{0}%"", ""400""));
        labels.put(""zoom800Script"", GT._(""{0}%"", ""800""));
        labels.put(""perspectiveCheck"", GT._(""&Perspective Depth""));
        labels.put(""axesCheck"", GT._(""A&xes""));
        labels.put(""boundboxCheck"", GT._(""B&ounding Box""));
        labels.put(""hydrogensCheck"", GT._(""&Hydrogens""));
        labels.put(""vectorsCheck"", GT._(""V&ectors""));
        labels.put(""measurementsCheck"", GT._(""&Measurements""));
        labels.put(""resize"", GT._(""Resi&ze""));
        labels.put(""view"", GT._(""&View""));
        labels.put(""front"", GT._(""&Front""));
        labels.put(""top"", GT._(""&Top""));
        labels.put(""bottom"", GT._(""&Bottom""));
        labels.put(""right"", GT._(""&Right""));
        labels.put(""left"", GT._(""&Left""));
        labels.put(""transform"", GT._(""Tr&ansform...""));
        labels.put(""definecenter"", GT._(""Define &Center""));
        labels.put(""tools"", GT._(""&Tools""));
        labels.put(""gauss"", GT._(""&Gaussian...""));
        labels.put(""viewMeasurementTable"", GT._(""&Measurements"") + ""..."");
        labels.put(""distanceUnitsMenu"", GT._(""Distance &Units""));
        labels.put(""distanceNanometersScript"", GT._(""&Nanometers 1E-9""));
        labels.put(""distanceAngstromsScript"", GT._(""&Angstroms 1E-10""));
        labels.put(""distancePicometersScript"", GT._(""&Picometers 1E-12""));
        labels.put(""animateMenu"", GT._(""&Animate...""));
        labels.put(""vibrateMenu"", GT._(""&Vibrate...""));
        labels.put(""graph"", GT._(""&Graph...""));
        labels.put(""chemicalShifts"", GT._(""Calculate chemical &shifts...""));
        labels.put(""crystprop"", GT._(""&Crystal Properties""));
        labels.put(""animateOnceScript"", GT._(""&Once""));
        labels.put(""animateLoopScript"", GT._(""&Loop""));
        labels.put(""animatePalindromeScript"", GT._(""P&alindrome""));
        labels.put(""animateStopScript"", GT._(""&Stop animation""));
        labels.put(""animateRewindScript"", GT._(""&Rewind to first frame""));
        labels.put(""animateRewindScriptTip"", GT._(""Rewind to first frame""));
        labels.put(""animateNextScript"", GT._(""Go to &next frame""));
        labels.put(""animateNextScriptTip"", GT._(""Go to next frame""));
        labels.put(""animatePrevScript"", GT._(""Go to &previous frame""));
        labels.put(""animatePrevScriptTip"", GT._(""Go to previous frame""));
        labels.put(""animateAllScript"", GT._(""All &frames""));
        labels.put(""animateAllScriptTip"", GT._(""All frames""));
        labels.put(""animateLastScript"", GT._(""Go to &last frame""));
        labels.put(""animateLastScriptTip"", GT._(""Go to last frame""));
        labels.put(""vibrateStartScript"", GT._(""Start &vibration""));
        labels.put(""vibrateStopScript"", GT._(""&Stop vibration""));
        labels.put(""vibrateRewindScript"", GT._(""&First frequency""));
        labels.put(""vibrateNextScript"", GT._(""&Next frequency""));
        labels.put(""vibratePrevScript"", GT._(""&Previous frequency""));
        labels.put(""surfaceTool"", GT._(""SurfaceTool...""));
        labels.put(""surfaceToolTip"", GT._(""Control Display of Surfaces""));
        labels.put(""help"", GT._(""&Help""));
        labels.put(""about"", GT._(""About Jmol""));
        labels.put(""uguide"", GT._(""User Guide""));
        labels.put(""whatsnew"", GT._(""What's New""));
        labels.put(""Prefs.showHydrogens"", GT._(""Hydrogens""));
        labels.put(""Prefs.showMeasurements"", GT._(""Measurements""));
        labels.put(""Prefs.perspectiveDepth"", GT._(""Perspective Depth""));
        labels.put(""Prefs.showAxes"", GT._(""Axes""));
        labels.put(""Prefs.showBoundingBox"", GT._(""Bounding Box""));
        labels.put(""Prefs.axesOrientationRasmol"", GT._(""RasMol/Chime compatible axes orientation/rotations""));
        labels.put(""Prefs.openFilePreview"", GT._(""File Preview (requires restarting Jmol)""));
        labels.put(""Prefs.clearHistory"", GT._(""Clear history (requires restarting Jmol)""));
        labels.put(""Prefs.isLabelAtomColor"", GT._(""Use Atom Color""));
        labels.put(""Prefs.isBondAtomColor"", GT._(""Use Atom Color""));
        labels.put(""rotateScriptTip"", GT._(""Rotate molecule.""));
        labels.put(""pickScriptTip"", GT._(""Select a set of atoms using SHIFT-LEFT-DRAG.""));
        labels.put(""pickMeasureScriptTip"", GT._(""Click atoms to measure distances""));
        labels.put(""pickCenterScriptTip"", GT._(""Click an atom to center on it""));
        labels.put(""homeTip"", GT._(""Return molecule to home position.""));
        labels.put(""modelkitScriptTip"", GT._(""Open the model kit.""));
        labels.put(""JavaConsole.clear"", GT._(""Clear""));
    }
",1
20789654,44,"    public static void main(String[] args) {
        long maxProduct = 0;
        String result = null;
        for (int i = 999; i > 99; i--) {
            for (int j = 999; j > 99; j--) {
                long product = i * j;
                boolean isPalindrome = PalindromeUtil.checkPalindrome(product);
                if (isPalindrome) {
                    if (product > maxProduct) {
                        maxProduct = product;
                        result = ""Numbers are: "" + i + "", "" + j + "" with product: "" + product;
                    }
                }
            }
        }
        System.out.println(result);
    }
",0
21619743,44,"    public static void main(String[] args) {
        long sum = 0;
        for (int number = 1; number < 1000000; number++) {
            if (PalindromeUtil.checkPalindrome(number)) {
                String binary = Integer.toString(number, 2);
                if (PalindromeUtil.checkPalindrome(binary)) {
                    System.out.println(number + ""\t"" + binary);
                    sum += number;
                }
            }
        }
        System.out.println(""Sum of all numbers: "" + sum);
    }
",1
21665284,44,"    public boolean isPalindrome(String s) {
        return new StringBuilder(s).reverse().toString().equals(s);
    }
",1
22174814,44,"    boolean setAnimationRelative(int direction) {
        int frameStep = this.frameStep * direction * currentDirection;
        int modelIndexNext = currentModelIndex + frameStep;
        boolean isDone = (modelIndexNext > firstModelIndex && modelIndexNext > lastModelIndex || modelIndexNext < firstModelIndex && modelIndexNext < lastModelIndex);
        if (isDone) {
            switch(animationReplayMode) {
                case ONCE:
                    return false;
                case LOOP:
                    modelIndexNext = (animationDirection == currentDirection ? firstModelIndex : lastModelIndex);
                    break;
                case PALINDROME:
                    currentDirection = -currentDirection;
                    modelIndexNext -= 2 * frameStep;
            }
        }
        int nModels = viewer.getModelCount();
        if (modelIndexNext < 0 || modelIndexNext >= nModels) return false;
        setCurrentModelIndex(modelIndexNext);
        return true;
    }
",0
22820417,44,"    public void testPalindrome() {
        assertFalse(Loop.isPalindrome(""abcdef""));
        assertFalse(Loop.isPalindrome(""abccda""));
        assertFalse(Loop.isPalindrome(""abccda""));
        assertFalse(Loop.isPalindrome(""abcxba""));
        assertTrue(Loop.isPalindrome(""a""));
        assertTrue(Loop.isPalindrome(""aa""));
        assertFalse(Loop.isPalindrome(""ab""));
        assertTrue(Loop.isPalindrome(""""));
        assertTrue(Loop.isPalindrome(""aaa""));
        assertTrue(Loop.isPalindrome(""aba""));
        assertFalse(Loop.isPalindrome(""abbba""));
        assertFalse(Loop.isPalindrome(""abba""));
        assertFalse(Loop.isPalindrome(""abbas""));
    }
",1
23355902,44,"    public static boolean checkPalindrome(long number) {
        String num = String.valueOf(number);
        return checkPalindrome(num);
    }
",0
23355905,44,"    public static boolean checkPalindrome(BigInteger currentSum) {
        if (currentSum == null) {
            return false;
        }
        return checkPalindrome(currentSum.toString());
    }
",1
23677145,7,"	public static <T extends Comparable<T>> void BubbleSortComparable1(T[] num) {
		int j;
		boolean flag = true; // set flag to true to begin first pass
		T temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (j = 0; j < num.length - 1; j++) {
				if (num[j].compareTo(num[j + 1]) > 0) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
",1
23677133,7,"	public static void BubbleSortInt1(int[] num) {
		boolean flag = true; // set flag to true to begin first pass
		int temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
",0
20660203,7,"    public static void main(String args[]) {
        int temp;
        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };
        for (int j = 0; j < (a1.length * a1.length); j++) {
            for (int i = 0; i < a1.length - 1; i++) {
                if (a1[i] > a1[i + 1]) {
                    temp = a1[i];
                    a1[i] = a1[i + 1];
                    a1[i + 1] = temp;
                }
            }
        }
        for (int i = 0; i < a1.length; i++) {
            System.out.print("" "" + a1[i]);
        }
    }
",1
23677137,7,"	public static void BubbleSortDouble1(double[] num) {
		boolean flag = true; // set flag to true to begin first pass
		double temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
",1
23677146,7,"	public static <T extends Comparable<T>> void BubbleSortComparable2(T[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j].compareTo(num[j + 1]) > 0)
				{
					T temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
",1
23677134,7,"	public static void BubbleSortInt2(int[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					int temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
",0
15568623,7,"    public Resultado procesar() {
        if (resultado != null) return resultado;
        int[] a = new int[elems.size()];
        Iterator iter = elems.iterator();
        int w = 0;
        while (iter.hasNext()) {
            a[w] = ((Integer) iter.next()).intValue();
            w++;
        }
        int n = a.length;
        long startTime = System.currentTimeMillis();
        int i, j, temp;
        for (i = 0; i < n - 1; i++) {
            for (j = i; j < n - 1; j++) {
                if (a[i] > a[j + 1]) {
                    temp = a[i];
                    a[i] = a[j + 1];
                    a[j + 1] = temp;
                    pasos++;
                }
            }
        }
        long endTime = System.currentTimeMillis();
        resultado = new Resultado((int) (endTime - startTime), pasos, a.length);
        System.out.println(""Resultado BB: "" + resultado);
        return resultado;
    }
",1
21273053,7,"    public RobotList<Enemy> sort_incr_Enemy(RobotList<Enemy> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        if (field.equals("""") || field.equals(""location"")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals(""health"")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say(""impossible to sort list - nothing modified"");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value > enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Enemy> new_enemy_list = new RobotList<Enemy>(Enemy.class);
        for (int i = 0; i < length; i++) {
            new_enemy_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_enemy_list;
    }
",1
23677142,7,"	public static void BubbleSortShort2(short[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					short temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
",1
19260977,7,"    public int[] sort() {
        boolean t = true;
        int temp = 0;
        int[] mas = new int[N];
        Random rand = new Random();
        for (int i = 0; i < N; i++) {
            mas[i] = rand.nextInt(10) + 1;
        }
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    temp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = temp;
                    t = true;
                }
            }
        }
        return mas;
    }
",1
23677138,7,"	public static void BubbleSortDouble2(double[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					double temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
",0
21273052,7,"    public RobotList<Float> sort_decr_Float(RobotList<Float> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i));
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value < distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Float> sol = new RobotList<Float>(Float.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Float(distri[i].value));
        }
        return sol;
    }
",1
21779336,7,"    private void weightAndPlaceClasses() {
        int rows = getRows();
        for (int curRow = _maxPackageRank; curRow < rows; curRow++) {
            xPos = getHGap() / 2;
            ClassdiagramNode[] rowObject = getObjectsInRow(curRow);
            for (int i = 0; i < rowObject.length; i++) {
                if (curRow == _maxPackageRank) {
                    int nDownlinks = rowObject[i].getDownlinks().size();
                    rowObject[i].setWeight((nDownlinks > 0) ? (1 / nDownlinks) : 2);
                } else {
                    Vector uplinks = rowObject[i].getUplinks();
                    int nUplinks = uplinks.size();
                    if (nUplinks > 0) {
                        float average_col = 0;
                        for (int j = 0; j < uplinks.size(); j++) {
                            average_col += ((ClassdiagramNode) (uplinks.elementAt(j))).getColumn();
                        }
                        average_col /= nUplinks;
                        rowObject[i].setWeight(average_col);
                    } else {
                        rowObject[i].setWeight(1000);
                    }
                }
            }
            int[] pos = new int[rowObject.length];
            for (int i = 0; i < pos.length; i++) {
                pos[i] = i;
            }
            boolean swapped = true;
            while (swapped) {
                swapped = false;
                for (int i = 0; i < pos.length - 1; i++) {
                    if (rowObject[pos[i]].getWeight() > rowObject[pos[i + 1]].getWeight()) {
                        int temp = pos[i];
                        pos[i] = pos[i + 1];
                        pos[i + 1] = temp;
                        swapped = true;
                    }
                }
            }
            for (int i = 0; i < pos.length; i++) {
                rowObject[pos[i]].setColumn(i);
                if ((i > _vMax) && (rowObject[pos[i]].getUplinks().size() == 0) && (rowObject[pos[i]].getDownlinks().size() == 0)) {
                    if (getColumns(rows - 1) > _vMax) {
                        rows++;
                    }
                    rowObject[pos[i]].setRank(rows - 1);
                } else {
                    rowObject[pos[i]].setLocation(new Point(xPos, yPos));
                    xPos += rowObject[pos[i]].getSize().getWidth() + getHGap();
                }
            }
            yPos += getRowHeight(curRow) + getVGap();
        }
    }
",1
23677144,7,"	public static void BubbleSortByte2(byte[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					byte temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
",1
23677143,7,"	public static void BubbleSortByte1(byte[] num) {
		boolean flag = true; // set flag to true to begin first pass
		byte temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
",1
23677140,7,"	public static void BubbleSortLong2(long[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					long temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
",1
22888751,7,"    public static float medianElement(float[] array, int size) {
        float[] tmpArray = new float[size];
        System.arraycopy(array, 0, tmpArray, 0, size);
        boolean changed = true;
        while (changed) {
            changed = false;
            for (int i = 0; i < size - 1; i++) {
                if (tmpArray[i] > tmpArray[i + 1]) {
                    changed = true;
                    float tmp = tmpArray[i];
                    tmpArray[i] = tmpArray[i + 1];
                    tmpArray[i + 1] = tmp;
                }
            }
        }
        return tmpArray[size / 2];
    }
",1
23677135,7,"	public static void BubbleSortFloat1(float[] num) {
		boolean flag = true; // set flag to true to begin first pass
		float temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
",1
23677141,7,"	public static void BubbleSortShort1(short[] num) {
		boolean flag = true; // set flag to true to begin first pass
		short temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
",1
23677139,7,"	public static void BubbleSortLong1(long[] num) {
		boolean flag = true; // set flag to true to begin first pass
		long temp; // holding variable

		while (flag) {
			flag = false; // set flag to false awaiting a possible swap
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1]) // change to > for ascending sort
				{
					temp = num[j]; // swap elements
					num[j] = num[j + 1];
					num[j + 1] = temp;
					flag = true; // shows a swap occurred
				}
			}
		}
	}
",1
23677136,7,"	public static void BubbleSortFloat2(float[] num) {
		int last_exchange;
		int right_border = num.length - 1;
		do {
			last_exchange = 0;
			for (int j = 0; j < num.length - 1; j++) {
				if (num[j] > num[j + 1])
				{
					float temp = num[j];
					num[j] = num[j + 1];
					num[j + 1] = temp;
					last_exchange = j;
				}
			}
			right_border = last_exchange;
		} while (right_border > 0);
	}
",1
22135738,7,"    protected void sort(double[] a) throws Exception {
        for (int i = a.length - 1; i >= 0; i--) {
            boolean swapped = false;
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    double d = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = d;
                    swapped = true;
                }
            }
            if (!swapped) return;
        }
    }
",1
22961758,13,"    public void touchSomeFiles(int percentage, int mode) {
        try {
            File[] files = dir.listFiles(mff);
            Random rnd = new Random();
            for (int i = files.length - 1; i >= 0; i--) {
                int j = rnd.nextInt(i + 1);
                File swap = files[i];
                files[i] = files[j];
                files[j] = swap;
            }
            int howfar = files.length * percentage / 100;
            if (mode == TOUCH_MODE_RECREATE || mode == TOUCH_MODE_COPY_TWICE) {
                for (int i = 0; i < howfar; i++) {
                    File f = files[i];
                    if (mode == TOUCH_MODE_COPY_TWICE) {
                        File bf = new File(f.getParent(), ""recreate--"" + f.getName());
                        recreateFile(f, bf);
                    } else {
                        recreateFile(f, f);
                    }
                }
                if (mode == TOUCH_MODE_COPY_TWICE) {
                    try {
                        Thread.sleep(15000);
                    } catch (InterruptedException ex) {
                        ex.printStackTrace();
                    }
                    for (int i = 0; i < howfar; i++) {
                        File f = files[i];
                        File bf = new File(f.getParent(), ""recreate--"" + f.getName());
                        recreateFile(bf, f);
                    }
                }
            } else if (mode == TOUCH_MODE_ACCESS || mode == TOUCH_MODE_MODIFY) {
                for (int i = 0; i < howfar; i++) {
                    RandomAccessFile raf = new RandomAccessFile(files[i], mode == TOUCH_MODE_MODIFY ? ""rw"" : ""r"");
                    if (raf.length() > 0) {
                        int pos = rnd.nextInt(Math.max(0, (int) raf.length()));
                        raf.seek(pos);
                        byte byte1 = raf.readByte();
                        if (mode == TOUCH_MODE_MODIFY) {
                            raf.seek(pos);
                            raf.write(byte1);
                        }
                    }
                    raf.close();
                    files[i].setLastModified(LAST_MODIFIED_DATE);
                }
            } else {
                throw new IllegalArgumentException();
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
",1
23677157,13,"	public static <T> void shuffle3(T[] a) {
		//Standard Fisher-Yates/Knuth Shuffle for Object array
		int length = a.length;
				
		Random random = new Random();
		random.nextInt();
				
		for(int i = 0; i < length; i++) {
			//Chose index to swap with from i <= j < length
			int j = i + random.nextInt(length-i);
			
			//Swap
			T tmp = a[i];
			a[i] = a[j];
			a[j] = tmp;
		}
	}
",1
23677155,13,"	public static void shuffle1(int[] a) {
		//Standard Fisher-Yates/Knuth Shuffle
		int length = a.length;
		
		Random random = new Random();
		random.nextInt();
		
		for(int i = 0; i < length; i++) {
			//Chose index to swap with from i <= j < length
			int j = i + random.nextInt(length-i);
			
			//Swap
			int tmp = a[i];
			a[i] = a[j];
			a[j] = tmp;
		}
	}
",1
20328638,13,"    public static final void shuffle(int[] list) {
        for (int i = list.length - 1; i >= 0; i--) {
            int j = rand.nextInt(i + 1);
            if (i == j) {
                continue;
            }
            int tmp = list[i];
            list[i] = list[j];
            list[j] = tmp;
        }
    }
",0
23677226,44,"	public static boolean isPalindrome(String original) {
		//A not very efficient example
		String reverse = """";
		int length = original.length();
		for (int i = length - 1; i >= 0; i--)
			reverse = reverse + original.charAt(i);

		if (original.equals(reverse))
			return true;
		else
			return false;
	}
",1
